<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>EPnPPointCorrespondencePinholeCameraEstimator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-geometry</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.geometry.estimators</a> &gt; <span class="el_source">EPnPPointCorrespondencePinholeCameraEstimator.java</span></div><h1>EPnPPointCorrespondencePinholeCameraEstimator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2017 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.geometry.estimators;

import com.irurueta.algebra.*;
import com.irurueta.algebra.Utils;
import com.irurueta.geometry.*;

import java.util.ArrayList;
import java.util.List;

/**
 * EPnP (Efficient Perspective-n-Point) implementation to estimate pinhole
 * cameras from 2D/3D point correspondences.
 * This class is an implementation following the one proposed by Vincent Lepetit
 * on &quot;EPnP: An Accurate O(n) Solution to the PnP Problem&quot; with some minor
 * changes and improvements.
 * Paper and source code can be found at:
 * &lt;a href=&quot;http://cvlabwww.epfl.ch/~lepetit/papers/lepetit_ijcv08.pdf&quot;&gt;
 *     http://cvlabwww.epfl.ch/~lepetit/papers/lepetit_ijcv08.pdf
 * &lt;/a&gt;
 * &lt;a href=&quot;http://cvlab.epfl.ch/EPnP/index.php&quot;&gt;http://cvlab.epfl.ch/EPnP/index.php&lt;/a&gt;
 */
@SuppressWarnings(&quot;DuplicatedCode&quot;)
public class EPnPPointCorrespondencePinholeCameraEstimator extends PointCorrespondencePinholeCameraEstimator {

    /**
     * Indicates that by default planar configuration is checked to determine
     * whether point correspondences are in such configuration and find a
     * specific solution for such case.
     */
    public static final boolean DEFAULT_PLANAR_CONFIGURATION_ALLOWED = true;

    /**
     * Indicates that by default a dimension 2 null-space is allowed.
     */
    public static final boolean DEFAULT_NULLSPACE_DIMENSION2_ALLOWED = true;

    /**
     * Indicates that by default a dimension 3 null-space is allowed.
     */
    public static final boolean DEFAULT_NULLSPACE_DIMENSION3_ALLOWED = true;

    /**
     * Default threshold to determine whether 3D matched points are in a
     * planar configuration.
     * Points are considered to be laying in a plane when the smallest singular
     * value of their covariance matrix has a value much smaller than the
     * second smallest as many times as this value.
     */
    public static final double DEFAULT_PLANAR_THRESHOLD = 1e13;

    /**
     * Number of control points used in a general configuration.
     */
    private static final int GENERAL_NUM_CONTROL_POINTS = 4;

    /**
     * Number of control points used in a planar configuration.
     */
    private static final int PLANAR_NUM_CONTROL_POINTS = 3;

    /**
     * Indicates whether planar configuration is checked to determine whether
     * point correspondences are in such configuration and find a specific
     * solution for such case.
     */
<span class="fc" id="L81">    private boolean planarConfigurationAllowed = DEFAULT_PLANAR_CONFIGURATION_ALLOWED;</span>

    /**
     * Indicates whether the case where a dimension 2 null-space is allowed.
     * When allowed, additional constraints are taken into account to ensure
     * equality of scales so that less point correspondences are required.
     * Enabling this parameter is usually ok.
     */
<span class="fc" id="L89">    private boolean nullspaceDimension2Allowed = DEFAULT_NULLSPACE_DIMENSION2_ALLOWED;</span>

    /**
     * Indicates whether the case where a dimension 3 null-space is allowed.
     * When allowed, additional constraints are taken into account to ensure
     * equality of scales so that less point correspondences are required.
     * Enabling this parameter is usually ok although less precise than
     * when a null-space of dimension 2 is used.
     */
<span class="fc" id="L98">    private boolean nullspaceDimension3Allowed = DEFAULT_NULLSPACE_DIMENSION3_ALLOWED;</span>

    /**
     * Threshold to determine whether 3D matched points are in a planar
     * configuration.
     * Points are considered to be laying in a plane when the smallest singular
     * value of their covariance matrix has a value much smaller than the
     * largest one as many times as this value.
     */
<span class="fc" id="L107">    private double planarThreshold = DEFAULT_PLANAR_THRESHOLD;</span>

    /**
     * Intrinsic parameters of camera to be estimated.
     */
    private PinholeCameraIntrinsicParameters intrinsic;

    /**
     * Indicates whether provided correspondences were found to be laying in a
     * planar configuration during the estimation.
     */
    private boolean isPlanar;

    /**
     * Computed control points in world coordinates.
     */
    private List&lt;Point3D&gt; controlWorldPoints;

    /**
     * Contains barycentric coordinates to express 3D world point in terms of
     * control points.
     * For general configuration, each row contains 4 coordinates and alphas
     * has size nx4, where n is the number of provided 3D world points.
     * For planar configuration, each row contains 3 coordinates and alphas
     * has size nx3, where n is the number of provided 3D world points.
     * both reference frames are centered in the centroid, alphas can be used
     * in both world and camera coordinates.
     */
    private Matrix alphas;

    /**
     * M matrix to find control points in camera coordinates.
     * M has size 2*n x 12 (general configuration) or 2*n x 9
     * (planar configuration), where n is the number of provided 2D observed
     * points.
     */
    private Matrix m;

    /**
     * List containing columns of null-space of M. Linear combinations of these
     * columns contain possible solutions for control points coordinates in
     * camera reference (up to scale).
     * First item of the list contains last column of v, which corresponds to
     * the smallest singular value.
     * Last item of the list contains (column - number of control points) column
     * of v.
     */
    private List&lt;double[]&gt; nullspace;

    /**
     * Possible solutions for the estimation.
     */
    private List&lt;Solution&gt; solutions;

    /**
     * Constructor.
     */
    public EPnPPointCorrespondencePinholeCameraEstimator() {
<span class="fc" id="L165">        super();</span>
<span class="fc" id="L166">    }</span>

    /**
     * Constructor with listener.
     *
     * @param listener listener to be notified of events such as when estimation
     *                 starts, ends or estimation progress changes.
     */
    public EPnPPointCorrespondencePinholeCameraEstimator(final PinholeCameraEstimatorListener listener) {
<span class="fc" id="L175">        super(listener);</span>
<span class="fc" id="L176">    }</span>

    /**
     * Constructor.
     *
     * @param points3D list of corresponding 3D points.
     * @param points2D list of corresponding 2D points.
     * @throws IllegalArgumentException if any of the lists are null.
     * @throws WrongListSizesException  if provided lists of points don't have
     *                                  the same size and enough points.
     */
    public EPnPPointCorrespondencePinholeCameraEstimator(
            final List&lt;Point3D&gt; points3D, final List&lt;Point2D&gt; points2D) throws WrongListSizesException {
<span class="fc" id="L189">        super();</span>
<span class="fc" id="L190">        internalSetListsEpnP(points3D, points2D);</span>
<span class="fc" id="L191">    }</span>

    /**
     * Constructor.
     *
     * @param points3D list of corresponding 3D points.
     * @param points2D list of corresponding 2D points.
     * @param listener listener to be notified of events such as when estimation
     *                 starts, ends or estimation progress changes.
     * @throws IllegalArgumentException if any of the lists are null.
     * @throws WrongListSizesException  if provided lists of points don't have
     *                                  the same size and enough points.
     */
    public EPnPPointCorrespondencePinholeCameraEstimator(
            final List&lt;Point3D&gt; points3D, final List&lt;Point2D&gt; points2D, final PinholeCameraEstimatorListener listener)
            throws WrongListSizesException {
<span class="fc" id="L207">        super(listener);</span>
<span class="fc" id="L208">        internalSetListsEpnP(points3D, points2D);</span>
<span class="fc" id="L209">    }</span>

    /**
     * Constructor.
     *
     * @param intrinsic intrinsic parameters of camera to be estimated.
     */
    public EPnPPointCorrespondencePinholeCameraEstimator(final PinholeCameraIntrinsicParameters intrinsic) {
<span class="fc" id="L217">        this();</span>
<span class="fc" id="L218">        this.intrinsic = intrinsic;</span>
<span class="fc" id="L219">    }</span>

    /**
     * Constructor with listener.
     *
     * @param intrinsic intrinsic parameters of camera to be estimated.
     * @param listener  listener to be notified of events such as when estimation
     *                  starts, ends or estimation progress changes.
     * @throws IllegalArgumentException if absolute values of focal lengths are
     *                                  too small.
     */
    public EPnPPointCorrespondencePinholeCameraEstimator(
            final PinholeCameraIntrinsicParameters intrinsic, final PinholeCameraEstimatorListener listener) {
<span class="fc" id="L232">        this(listener);</span>
<span class="fc" id="L233">        this.intrinsic = intrinsic;</span>
<span class="fc" id="L234">    }</span>

    /**
     * Constructor.
     *
     * @param intrinsic intrinsic parameters of camera to be estimated.
     * @param points3D  list of corresponding 3D points.
     * @param points2D  list of corresponding 2D points.
     * @throws IllegalArgumentException if any of the lists are null or if
     *                                  absolute values of focal lengths are too small.
     * @throws WrongListSizesException  if provided lists of points don't have
     *                                  the same size and enough points.
     */
    public EPnPPointCorrespondencePinholeCameraEstimator(
            final PinholeCameraIntrinsicParameters intrinsic, final List&lt;Point3D&gt; points3D,
            final List&lt;Point2D&gt; points2D) throws WrongListSizesException {
<span class="fc" id="L250">        this(points3D, points2D);</span>
<span class="fc" id="L251">        this.intrinsic = intrinsic;</span>
<span class="fc" id="L252">    }</span>

    /**
     * Constructor.
     *
     * @param intrinsic intrinsic parameters of camera to be estimated.
     * @param points3D  list of corresponding 3D points.
     * @param points2D  list of corresponding 2D points.
     * @param listener  listener to be notified of events such as when estimation
     *                  starts, ends or estimation progress changes.
     * @throws IllegalArgumentException if any of the lists are null or if
     *                                  absolute values of focal lengths are too small.
     * @throws WrongListSizesException  if provided lists of points don't have
     *                                  the same size and enough points.
     */
    public EPnPPointCorrespondencePinholeCameraEstimator(
            final PinholeCameraIntrinsicParameters intrinsic, final List&lt;Point3D&gt; points3D,
            final List&lt;Point2D&gt; points2D, final PinholeCameraEstimatorListener listener)
            throws WrongListSizesException {
<span class="fc" id="L271">        this(points3D, points2D, listener);</span>
<span class="fc" id="L272">        this.intrinsic = intrinsic;</span>
<span class="fc" id="L273">    }</span>

    /**
     * Sets list of corresponding points.
     *
     * @param points3D list of corresponding 3D points.
     * @param points2D list of corresponding 2D points.
     * @throws LockedException          if estimator is locked.
     * @throws IllegalArgumentException if any of the lists are null.
     * @throws WrongListSizesException  if provided lists of points don't have
     *                                  the same size and enough points.
     */
    @Override
    public void setLists(final List&lt;Point3D&gt; points3D, final List&lt;Point2D&gt; points2D) throws LockedException,
            WrongListSizesException {
<span class="fc bfc" id="L288" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L289">            throw new LockedException();</span>
        }

<span class="fc" id="L292">        internalSetListsEpnP(points3D, points2D);</span>
<span class="fc" id="L293">    }</span>

    /**
     * Indicates whether planar configuration is checked to determine whether
     * point correspondences are in such configuration and find a specific
     * solution for such case.
     *
     * @return true to allow specific solutions for planar configurations,
     * false to always find a solution assuming the general case.
     */
    public boolean isPlanarConfigurationAllowed() {
<span class="fc" id="L304">        return planarConfigurationAllowed;</span>
    }

    /**
     * Specifies whether planar configuration is checked to determine whether
     * point correspondences are in such configuration and find a specific
     * solution for such case.
     *
     * @param planarConfigurationAllowed true to allow specific solutions for
     *                                   planar configurations, false to always find a solution assuming the
     *                                   general case.
     * @throws LockedException if estimator is locked.
     */
    public void setPlanarConfigurationAllowed(final boolean planarConfigurationAllowed) throws LockedException {
<span class="fc bfc" id="L318" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L319">            throw new LockedException();</span>
        }
<span class="fc" id="L321">        this.planarConfigurationAllowed = planarConfigurationAllowed;</span>
<span class="fc" id="L322">    }</span>

    /**
     * Indicates whether the case where a dimension 2 null-space is allowed.
     * When allowed, additional constraints are taken into account to ensure
     * equality of scales so that less point correspondences are required.
     * Enabling this parameter is usually ok.
     *
     * @return true to allow 2-dimensional null-space, false otherwise.
     */
    public boolean isNullspaceDimension2Allowed() {
<span class="fc" id="L333">        return nullspaceDimension2Allowed;</span>
    }

    /**
     * Specifies whether the case where a dimension 2 null-space is allowed.
     * When allowed, additional constraints are taken into account to ensure
     * equality of scales so that less point correspondences are required.
     * Enabling this parameter is usually ok.
     *
     * @param nullspaceDimension2Allowed true to allow 2-dimensional null-space,
     *                                   false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setNullspaceDimension2Allowed(final boolean nullspaceDimension2Allowed) throws LockedException {
<span class="fc bfc" id="L347" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L348">            throw new LockedException();</span>
        }
<span class="fc" id="L350">        this.nullspaceDimension2Allowed = nullspaceDimension2Allowed;</span>
<span class="fc" id="L351">    }</span>

    /**
     * Indicates whether the case where a dimension 3 null-space is allowed.
     * When allowed, additional constraints are taken into account to ensure
     * equality of scales so that less point correspondences are required.
     * Enabling this parameter is usually ok although less precise than
     * when a null-space of dimension 2 is used.
     *
     * @return true to allow 3-dimensional null-space, false otherwise.
     */
    public boolean isNullspaceDimension3Allowed() {
<span class="fc" id="L363">        return nullspaceDimension3Allowed;</span>
    }

    /**
     * Specifies whether the case where a dimension 3 null-space is allowed.
     * When allowed, additional constraints are taken into account to ensure
     * equality of scales so that less point correspondences are required.
     * Enabling this parameter is usually ok although less precise than
     * when a null-space of dimension 2 is used.
     *
     * @param nullspaceDimension3Allowed true to allow 3-dimensional null-space,
     *                                   false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setNullspaceDimension3Allowed(final boolean nullspaceDimension3Allowed) throws LockedException {
<span class="fc bfc" id="L378" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L379">            throw new LockedException();</span>
        }
<span class="fc" id="L381">        this.nullspaceDimension3Allowed = nullspaceDimension3Allowed;</span>
<span class="fc" id="L382">    }</span>

    /**
     * Gets threshold to determine whether 3D matched points are in a planar
     * configuration.
     * Points are considered to be laying in a plane when the smallest singular
     * value of their covariance matrix has a value much smaller than the
     * largest one as many times as this value.
     *
     * @return threshold to determine whether 3D matched points are in a planar
     * configuration.
     */
    public double getPlanarThreshold() {
<span class="fc" id="L395">        return planarThreshold;</span>
    }

    /**
     * Sets threshold to determine whether 3D matched points are in a planar
     * configuration.
     * Points are considered to be laying in a plane when the smallest singular
     * value of their covariance matrix has a value much smaller than the
     * largest one as many times as this value.
     *
     * @param planarThreshold threshold to determine whether 3D matched points
     *                        are in a planar configuration.
     * @throws IllegalArgumentException if provided threshold is negative.
     * @throws LockedException          if estimator is locked.
     */
    public void setPlanarThreshold(final double planarThreshold) throws LockedException {
<span class="fc bfc" id="L411" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L412">            throw new LockedException();</span>
        }
<span class="pc bpc" id="L414" title="1 of 2 branches missed.">        if (planarThreshold &lt; 0.0) {</span>
<span class="nc" id="L415">            throw new IllegalArgumentException();</span>
        }
<span class="fc" id="L417">        this.planarThreshold = planarThreshold;</span>
<span class="fc" id="L418">    }</span>

    /**
     * Gets intrinsic parameters of camera to be estimated.
     *
     * @return intrinsic parameters of camera to be estimated.
     */
    public PinholeCameraIntrinsicParameters getIntrinsic() {
<span class="fc" id="L426">        return intrinsic;</span>
    }

    /**
     * Sets intrinsic parameters of camera to be estimated.
     *
     * @param intrinsic intrinsic parameters of camera to be estimated.
     * @throws LockedException if estimator is locked.
     */
    public void setIntrinsic(final PinholeCameraIntrinsicParameters intrinsic) throws LockedException {
<span class="fc bfc" id="L436" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L437">            throw new LockedException();</span>
        }
<span class="fc" id="L439">        this.intrinsic = intrinsic;</span>
<span class="fc" id="L440">    }</span>

    /**
     * Indicates if this estimator is ready to start the estimation.
     *
     * @return true if estimator is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
<span class="pc bpc" id="L449" title="1 of 6 branches missed.">        return areListsAvailable() &amp;&amp; areValidLists(points3D, points2D) &amp;&amp; intrinsic != null;</span>
    }

    /**
     * Returns type of pinhole camera estimator.
     *
     * @return type of pinhole camera estimator.
     */
    @Override
    public PinholeCameraEstimatorType getType() {
<span class="fc" id="L459">        return PinholeCameraEstimatorType.EPNP_PINHOLE_CAMERA_ESTIMATOR;</span>
    }

    /**
     * Indicates if provided point correspondences are normalized to increase
     * the accuracy of the estimation.
     *
     * @return true if input point correspondences will be normalized, false
     * otherwise.
     */
    @Override
    public boolean arePointCorrespondencesNormalized() {
<span class="fc" id="L471">        return false;</span>
    }

    /**
     * Specifies whether provided point correspondences are normalized to
     * increase the accuracy of the estimation.
     *
     * @param normalize true if input point correspondences will be normalized,
     *                  false otherwise.
     * @throws LockedException if estimator is locked.
     */
    @Override
    public void setPointCorrespondencesNormalized(final boolean normalize) throws LockedException {
<span class="fc bfc" id="L484" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L485">            throw new LockedException();</span>
        }
<span class="fc" id="L487">    }</span>

    /**
     * Estimates a pinhole camera.
     *
     * @return estimated pinhole camera.
     * @throws LockedException                 if estimator is locked.
     * @throws NotReadyException               if input has not yet been provided.
     * @throws PinholeCameraEstimatorException if an error occurs during
     *                                         estimation, usually because input data is not valid.
     */
    @Override
    public PinholeCamera estimate() throws LockedException, NotReadyException, PinholeCameraEstimatorException {
<span class="fc bfc" id="L500" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L501">            throw new LockedException();</span>
        }
<span class="pc bpc" id="L503" title="1 of 2 branches missed.">        if (!isReady()) {</span>
<span class="nc" id="L504">            throw new NotReadyException();</span>
        }

        try {
<span class="fc" id="L508">            locked = true;</span>
<span class="fc bfc" id="L509" title="All 2 branches covered.">            if (listener != null) {</span>
<span class="fc" id="L510">                listener.onEstimateStart(this);</span>
            }

<span class="fc" id="L513">            computeWorldControlPointsAndPointConfiguration();</span>
<span class="fc" id="L514">            computeBarycentricCoordinates();</span>
<span class="fc" id="L515">            buildM();</span>
<span class="fc" id="L516">            solveNullspace();</span>
<span class="nc" id="L517">        } catch (final AlgebraException e) {</span>
<span class="nc" id="L518">            locked = false;</span>
<span class="nc" id="L519">            throw new PinholeCameraEstimatorException(e);</span>
<span class="fc" id="L520">        }</span>


<span class="fc" id="L523">        solutions = new ArrayList&lt;&gt;();</span>

        // general case
        try {
<span class="fc" id="L527">            generalSolution1();</span>
<span class="nc" id="L528">        } catch (final GeometryException ignore) {</span>
            // continue attempting 2nd solution if 1st one fails
<span class="fc" id="L530">        }</span>
<span class="pc bpc" id="L531" title="1 of 2 branches missed.">        if (nullspaceDimension2Allowed) {</span>
            try {
<span class="fc" id="L533">                generalSolution2();</span>
<span class="nc" id="L534">            } catch (final GeometryException | AlgebraException ignore) {</span>
                // continue attempting 3rd solution if 2nd one fails
<span class="fc" id="L536">            }</span>
        }
<span class="pc bpc" id="L538" title="1 of 4 branches missed.">        if (nullspaceDimension3Allowed &amp;&amp; !isPlanar) {</span>
            try {
<span class="fc" id="L540">                generalSolution3();</span>
<span class="nc" id="L541">            } catch (final GeometryException | AlgebraException ignore) {</span>
                // 3rd solution could not be found
<span class="fc" id="L543">            }</span>
        }

        // pick best solution
<span class="fc" id="L547">        final var bestSolution = pickBestSolution();</span>

<span class="fc bfc" id="L549" title="All 2 branches covered.">        if (listener != null) {</span>
<span class="fc" id="L550">            listener.onEstimateEnd(this);</span>
        }

<span class="pc bpc" id="L553" title="1 of 2 branches missed.">        if (bestSolution == null) {</span>
<span class="nc" id="L554">            throw new PinholeCameraEstimatorException();</span>
        }
<span class="fc" id="L556">        locked = false;</span>
<span class="fc" id="L557">        return attemptRefine(bestSolution.camera);</span>
    }


    /**
     * Indicates whether provided correspondences were found to be laying in a
     * planar configuration during the estimation.
     *
     * @return true if point correspondences are in a planar configuration,
     * false otherwise.
     */
    public boolean isPlanar() {
<span class="fc" id="L569">        return isPlanar;</span>
    }

    /**
     * Internal method that actually computes the normalized pinhole camera
     * internal matrix.
     * This implementation makes no action.
     *
     * @param points3D list of 3D points. Points might or might not be
     *                 normalized.
     * @param points2D list of 2D points. Points might or might not be
     *                 normalized.
     * @return matrix of estimated pinhole camera.
     */
    @Override
    protected Matrix internalEstimate(final List&lt;Point3D&gt; points3D, final List&lt;Point2D&gt; points2D) {
<span class="nc" id="L585">        return null;</span>
    }

    /**
     * Internal method to set list of corresponding points (it does not check
     * if estimator is locked).
     *
     * @param points3D list of corresponding 3D points.
     * @param points2D list of corresponding 2D points.
     * @throws IllegalArgumentException if any of the lists are null
     * @throws WrongListSizesException  if provided lists of points don't have
     *                                  the same size and enough points.
     */
    private void internalSetListsEpnP(final List&lt;Point3D&gt; points3D, final List&lt;Point2D&gt; points2D)
            throws WrongListSizesException {

<span class="fc bfc" id="L601" title="All 4 branches covered.">        if (points3D == null || points2D == null) {</span>
<span class="fc" id="L602">            throw new IllegalArgumentException();</span>
        }

<span class="fc bfc" id="L605" title="All 2 branches covered.">        if (!areValidLists(points3D, points2D)) {</span>
<span class="fc" id="L606">            throw new WrongListSizesException();</span>
        }

<span class="fc" id="L609">        this.points3D = points3D;</span>
<span class="fc" id="L610">        this.points2D = points2D;</span>
<span class="fc" id="L611">    }</span>

    /**
     * Picks best solution (the one having the smallest re-projection error).
     *
     * @return best solution.
     */
    private Solution pickBestSolution() {
<span class="fc" id="L619">        Solution bestSolution = null;</span>
<span class="fc" id="L620">        var bestError = Double.MAX_VALUE;</span>
<span class="fc bfc" id="L621" title="All 2 branches covered.">        for (final var s : solutions) {</span>
<span class="fc bfc" id="L622" title="All 2 branches covered.">            if (s.reprojectionError &lt; bestError) {</span>
<span class="fc" id="L623">                bestError = s.reprojectionError;</span>
<span class="fc" id="L624">                bestSolution = s;</span>
            }
<span class="fc" id="L626">        }</span>

<span class="fc" id="L628">        return bestSolution;</span>
    }

    /**
     * Tests solution 3 for general point configuration.
     * Because solution is up to scale, 8 different solutions for different
     * beta1, beta2 and beta3 signs are tried.
     *
     * @throws AlgebraException          if a numerical degeneracy occurs.
     * @throws LockedException           never happens.
     * @throws NotReadyException         never happens.
     * @throws CoincidentPointsException if a point degeneracy has occurred.
     */
    private void generalSolution3() throws AlgebraException, LockedException, NotReadyException,
            CoincidentPointsException {
<span class="pc bpc" id="L643" title="1 of 2 branches missed.">        if (isPlanar) {</span>
<span class="nc" id="L644">            return;</span>
        }

        // we have the distance constraints between control world points (c) and
        // control camera points (v):
        // ||(beta1*vai + beta2*vbi + beta3*vci) - (beta1*vaj + beta2*vbj + beta3*vcj)||^2 = ||ci - cj||^2,	i,j 1...4

        // ((beta1*vaix + beta2*vbix + beta3*vcix) - (beta1*vajx + beta2*vbjx + beta3*vcjx))^2 +
        // ((beta1*vaiy + beta2*vbiy + beta3*vciy) - (beta1*vajy + beta2*vbjy + beta3*vcjy))^2 +
        // ((beta1*vaiz + beta2*vbiz + beta3*vciz) - (beta1*vajz + beta2*vbjz + beta3*vcjz))^2 =
        // (cix - cjx)^2 + (ciy - cjy)^2 + (ciz - cjz)^2,		i,j 1...4

        // (beta1*(vaix - vajx) + beta2*(vbix - vbjx) + beta3*(vcix - vcjx))^2 +
        // (beta1*(vaiy - vajy) + beta2*(vbiy - vbjy) + beta3*(vciy - vcjy))^2 +
        // (beta1*(vaiz - vajz) + beta2*(vbiz - vbjz) + beta3*(vciz - vcjz))^2 =
        // (cix - cjx)^2 + (ciy - cjy)^2 + (ciz - cjz)^2,		i,j 1...4

        // beta1^2*(vaix - vajx)^2 + 2*beta1*(vaix - vajx)*(beta2*(vbix - vbjx) + beta3*(vcix - vcjx)) + (beta2*(vbix - vbjx) + beta3*(vcix - vcjx))^2 +
        // beta1^2*(vaiy - vajy)^2 + 2*beta1*(vaiy - vajy)*(beta2*(vbiy - vbjy) + beta3*(vciy - vcjy)) + (beta2*(vbiy - vbjy) + beta3*(vciy - vcjy))^2 +
        // beta1^2*(vaiz - vajz)^2 + 2*beta1*(vaiz - vajz)*(beta2*(vbiz - vbjz) + beta3*(vciz - vcjz)) + (beta2*(vbiz - vbjz) + beta3*(vciz - vcjz))^2 =
        // (cix - cjx)^2 + (ciy - cjy)^2 + (ciz - cjz)^2,		i,j 1...4

        // beta1^2*(vaix - vajx)^2 + beta1*beta2*2*(vaix - vajx)*(vbix - vbjx) + beta1*beta3*2*(vaix - vajx)*(vcix - vcjx) + beta2^2*(vbix - vbjx)^2 + beta2*beta3*2*(vbix - vbjx)*(vcix - vcjx) + beta3^2*(vcix - vcjx)^2 +
        // beta1^2*(vaiy - vajy)^2 + beta1*beta2*2*(vaiy - vajy)*(vbiy - vbjy) + beta1*beta3*2*(vaiy - vajy)*(vciy - vcjy) + beta2^2*(vbiy - vbjy)^2 + beta2*beta3*2*(vbiy - vbjy)*(vciy - vcjy) + beta3^2*(vciy - vcjy)^2 +
        // beta1^2*(vaiz - vajz)^2 + beta1*beta2*2*(vaiz - vajz)*(vbiz - vbjz) + beta1*beta3*2*(vaiz - vajz)*(vciz - vcjz) + beta2^2*(vbiz - vbjz)^2 + beta2*beta3*2*(vbiz - vbjz)*(vciz - vcjz) + beta3^2*(vciz - vcjz)^2 =
        // (cix - cjx)^2 + (ciy - cjy)^2 + (ciz - cjz)^2,		i,j 1...4

        // We linearize the equation assuming:
        // alpha1 = beta1^2
        // alpha2 = beta1*beta2
        // alpha3 = beta1*beta3
        // alpha4 = beta2^2
        // alpha5 = beta2*beta3
        // alpha6 = beta3^2

        // alpha1*(vaix - vajx)^2 + alpha2*2*(vaix - vajx)*(vbix - vbjx) + alpha3*2*(vaix - vajx)*(vcix - vcjx) + alpha4*(vbix - vbjx)^2 + alpha5*2*(vbix - vbjx)*(vcix - vcjx) + alpha6*(vcix - vcjx)^2 +
        // alpha1*(vaiy - vajy)^2 + alpha2*2*(vaiy - vajy)*(vbiy - vbjy) + alpha3*2*(vaiy - vajy)*(vciy - vcjy) + alpha4*(vbiy - vbjy)^2 + alpha5*2*(vbiy - vbjy)*(vciy - vcjy) + alpha6*(vciy - vcjy)^2 +
        // alpha1*(vaiz - vajz)^2 + alpha2*2*(vaiz - vajz)*(vbiz - vbjz) + alpha3*2*(vaiz - vajz)*(vciz - vcjz) + alpha4*(vbiz - vbjz)^2 + alpha5*2*(vbiz - vbjz)*(vciz - vcjz) + alpha6*(vciz - vcjz)^2 =
        // (cix - cjx)^2 + (ciy - cjy)^2 + (ciz - cjz)^2,		i,j 1...4

        // Reorder
        // alpha1*((vaix - vajx)^2 + (vaiy - vajy)^2 + (vaiz - vajz)^2) +
        // alpha2*2*((vaix - vajx)*(vbix - vbjx) + (vaiy - vajy)*(vbiy - vbjy) + (vaiz - vajz)*(vbiz - vbjz)) +
        // alpha3*2*((vaix - vajx)*(vcix - vcjx) + (vaiy - vajy)*(vciy - vcjy) + (vaiz - vajz)*(vciz - vcjz)) +
        // alpha4*((vbix - vbjx)^2 + (vbiy - vbjy)^2 + (vbiz - vbjz)^2) +
        // alpha5*2*((vbix - vbjx)*(vcix - vcjx) + (vbiy - vbjy)*(vciy - vcjy) + (vbiz - vbjz)*(vciz - vcjz)) +
        // alpha6*((vcix - vcjx)^2 + (vciy - vcjy)^2 + (vciz - vcjz)^2) =
        // (cix - cjx)^2 + (ciy - cjy)^2 + (ciz - cjz)^2,		i,j 1...4

        // this also produces 6 equations as in case 2.

<span class="fc" id="L695">        final var va = nullspace.get(0);</span>
<span class="fc" id="L696">        final var vb = nullspace.get(1);</span>
<span class="fc" id="L697">        final var vc = nullspace.get(2);</span>

<span class="fc" id="L699">        final var controlCameraPointsA = controlPointsFromV(va);</span>
<span class="fc" id="L700">        final var controlCameraPointsB = controlPointsFromV(vb);</span>
<span class="fc" id="L701">        final var controlCameraPointsC = controlPointsFromV(vc);</span>

<span class="fc" id="L703">        final var c = constraintMatrixSolution3(controlCameraPointsA, controlCameraPointsB, controlCameraPointsC);</span>
<span class="fc" id="L704">        final var rhos = rhos(controlWorldPoints);</span>

<span class="fc" id="L706">        final var a = Utils.solve(c, rhos);</span>

        double beta1;
        double beta2;
        double beta3;
<span class="fc bfc" id="L711" title="All 2 branches covered.">        if (a[0] &lt; 0.0) {</span>
<span class="fc" id="L712">            beta1 = Math.sqrt(-a[0]);</span>
<span class="fc bfc" id="L713" title="All 2 branches covered.">            beta2 = a[3] &lt; 0.0 ? Math.sqrt(-a[3]) : 0.0;</span>
        } else {
<span class="fc" id="L715">            beta1 = Math.sqrt(a[0]);</span>
<span class="fc bfc" id="L716" title="All 2 branches covered.">            beta2 = a[3] &gt; 0.0 ? Math.sqrt(a[3]) : 0.0;</span>
        }

        // fix sign of betas
<span class="fc bfc" id="L720" title="All 2 branches covered.">        if (a[1] &lt; 0.0) {</span>
<span class="fc" id="L721">            beta1 = -beta1;</span>
        }

<span class="fc" id="L724">        beta3 = a[2] / beta1;</span>

        // We linearize the equation assuming:
        // alpha1 = beta1^2
        // alpha2 = beta1*beta2
        // alpha3 = beta1*beta3
        // alpha4 = beta2^2
        // alpha5 = beta*beta3
        // alpha6 = beta3^2

<span class="fc" id="L734">        final var initialBeta1 = beta1;</span>
<span class="fc" id="L735">        final var initialBeta2 = beta2;</span>
<span class="fc" id="L736">        final var initialBeta3 = beta3;</span>

        // compute linear combination of va and vb as
        // v = beta1*va + beta2*vb + beta3*vc
<span class="fc" id="L740">        final var tmp1 = ArrayUtils.multiplyByScalarAndReturnNew(va, beta1);</span>
<span class="fc" id="L741">        final var tmp2 = ArrayUtils.multiplyByScalarAndReturnNew(vb, beta2);</span>
<span class="fc" id="L742">        final var tmp3 = ArrayUtils.multiplyByScalarAndReturnNew(vc, beta3);</span>
<span class="fc" id="L743">        ArrayUtils.sum(tmp1, tmp2, tmp1);</span>
<span class="fc" id="L744">        ArrayUtils.sum(tmp1, tmp3, tmp1);</span>
<span class="fc" id="L745">        var controlCameraPoints = controlPointsFromV(tmp1);</span>

<span class="fc" id="L747">        var solution = computePossibleSolutionWithPoseAndReprojectionError(controlCameraPoints);</span>
<span class="fc" id="L748">        solutions.add(solution);</span>

        // because solutions are square roots, beta1, beta2 and beta3 can have
        // different signs, so we add solutions for each combination so that the
        // one with the smallest re-projection error will be picked
<span class="fc" id="L753">        beta1 = -initialBeta1;</span>
        // no need to set: beta2 = initialBeta2 and beta3 = initialBeta3 because they already have
        // those values

<span class="fc" id="L757">        ArrayUtils.multiplyByScalar(va, beta1, tmp1);</span>
<span class="fc" id="L758">        ArrayUtils.multiplyByScalar(vb, beta2, tmp2);</span>
<span class="fc" id="L759">        ArrayUtils.multiplyByScalar(vc, beta3, tmp3);</span>
<span class="fc" id="L760">        ArrayUtils.sum(tmp1, tmp2, tmp1);</span>
<span class="fc" id="L761">        ArrayUtils.sum(tmp1, tmp3, tmp1);</span>
        // no need to set v = tmp1, because it already has this value
<span class="fc" id="L763">        controlCameraPoints = controlPointsFromV(tmp1);</span>

<span class="fc" id="L765">        solution = computePossibleSolutionWithPoseAndReprojectionError(controlCameraPoints);</span>
<span class="fc" id="L766">        solutions.add(solution);</span>


<span class="fc" id="L769">        beta1 = initialBeta1;</span>
<span class="fc" id="L770">        beta2 = -initialBeta2;</span>
        // no need to set: beta3 = initialBeta3 as it already has that value

<span class="fc" id="L773">        ArrayUtils.multiplyByScalar(va, beta1, tmp1);</span>
<span class="fc" id="L774">        ArrayUtils.multiplyByScalar(vb, beta2, tmp2);</span>
<span class="fc" id="L775">        ArrayUtils.multiplyByScalar(vc, beta3, tmp3);</span>
<span class="fc" id="L776">        ArrayUtils.sum(tmp1, tmp2, tmp1);</span>
<span class="fc" id="L777">        ArrayUtils.sum(tmp1, tmp3, tmp1);</span>
        // no need to set v = tmp1, because it already has this value
<span class="fc" id="L779">        controlCameraPoints = controlPointsFromV(tmp1);</span>

<span class="fc" id="L781">        solution = computePossibleSolutionWithPoseAndReprojectionError(controlCameraPoints);</span>
<span class="fc" id="L782">        solutions.add(solution);</span>

<span class="fc" id="L784">        beta1 = -initialBeta1;</span>
<span class="fc" id="L785">        beta2 = -initialBeta2;</span>
        // no need to set beta3 = initialBeta3, as it already has that value

<span class="fc" id="L788">        ArrayUtils.multiplyByScalar(va, beta1, tmp1);</span>
<span class="fc" id="L789">        ArrayUtils.multiplyByScalar(vb, beta2, tmp2);</span>
<span class="fc" id="L790">        ArrayUtils.multiplyByScalar(vc, beta3, tmp3);</span>
<span class="fc" id="L791">        ArrayUtils.sum(tmp1, tmp2, tmp1);</span>
<span class="fc" id="L792">        ArrayUtils.sum(tmp1, tmp3, tmp1);</span>
        // no need to set v = tmp1, because it already has this value
<span class="fc" id="L794">        controlCameraPoints = controlPointsFromV(tmp1);</span>

<span class="fc" id="L796">        solution = computePossibleSolutionWithPoseAndReprojectionError(controlCameraPoints);</span>
<span class="fc" id="L797">        solutions.add(solution);</span>

<span class="fc" id="L799">        beta1 = initialBeta1;</span>
<span class="fc" id="L800">        beta2 = initialBeta2;</span>
<span class="fc" id="L801">        beta3 = -initialBeta3;</span>

<span class="fc" id="L803">        ArrayUtils.multiplyByScalar(va, beta1, tmp1);</span>
<span class="fc" id="L804">        ArrayUtils.multiplyByScalar(vb, beta2, tmp2);</span>
<span class="fc" id="L805">        ArrayUtils.multiplyByScalar(vc, beta3, tmp3);</span>
<span class="fc" id="L806">        ArrayUtils.sum(tmp1, tmp2, tmp1);</span>
<span class="fc" id="L807">        ArrayUtils.sum(tmp1, tmp3, tmp1);</span>
        // no need to set v = tmp1, because it already has this value
<span class="fc" id="L809">        controlCameraPoints = controlPointsFromV(tmp1);</span>

<span class="fc" id="L811">        solution = computePossibleSolutionWithPoseAndReprojectionError(controlCameraPoints);</span>
<span class="fc" id="L812">        solutions.add(solution);</span>

<span class="fc" id="L814">        beta1 = -initialBeta1;</span>
        // no need to set beta2 = initialBeta2, because it already has this value
<span class="fc" id="L816">        beta3 = -initialBeta3;</span>

<span class="fc" id="L818">        ArrayUtils.multiplyByScalar(va, beta1, tmp1);</span>
<span class="fc" id="L819">        ArrayUtils.multiplyByScalar(vb, beta2, tmp2);</span>
<span class="fc" id="L820">        ArrayUtils.multiplyByScalar(vc, beta3, tmp3);</span>
<span class="fc" id="L821">        ArrayUtils.sum(tmp1, tmp2, tmp1);</span>
<span class="fc" id="L822">        ArrayUtils.sum(tmp1, tmp3, tmp1);</span>
        // no need to set v = tmp1, because it already has this value
<span class="fc" id="L824">        controlCameraPoints = controlPointsFromV(tmp1);</span>

<span class="fc" id="L826">        solution = computePossibleSolutionWithPoseAndReprojectionError(controlCameraPoints);</span>
<span class="fc" id="L827">        solutions.add(solution);</span>

<span class="fc" id="L829">        beta1 = initialBeta1;</span>
<span class="fc" id="L830">        beta2 = -initialBeta2;</span>
<span class="fc" id="L831">        beta3 = -initialBeta3;</span>

<span class="fc" id="L833">        ArrayUtils.multiplyByScalar(va, beta1, tmp1);</span>
<span class="fc" id="L834">        ArrayUtils.multiplyByScalar(vb, beta2, tmp2);</span>
<span class="fc" id="L835">        ArrayUtils.multiplyByScalar(vc, beta3, tmp3);</span>
<span class="fc" id="L836">        ArrayUtils.sum(tmp1, tmp2, tmp1);</span>
<span class="fc" id="L837">        ArrayUtils.sum(tmp1, tmp3, tmp1);</span>
        // no need to set v = tmp1, because it already has this value
<span class="fc" id="L839">        controlCameraPoints = controlPointsFromV(tmp1);</span>

<span class="fc" id="L841">        solution = computePossibleSolutionWithPoseAndReprojectionError(controlCameraPoints);</span>
<span class="fc" id="L842">        solutions.add(solution);</span>

<span class="fc" id="L844">        beta1 = -initialBeta1;</span>
<span class="fc" id="L845">        beta2 = -initialBeta2;</span>
<span class="fc" id="L846">        beta3 = -initialBeta3;</span>

<span class="fc" id="L848">        ArrayUtils.multiplyByScalar(va, beta1, tmp1);</span>
<span class="fc" id="L849">        ArrayUtils.multiplyByScalar(vb, beta2, tmp2);</span>
<span class="fc" id="L850">        ArrayUtils.multiplyByScalar(vc, beta3, tmp3);</span>
<span class="fc" id="L851">        ArrayUtils.sum(tmp1, tmp2, tmp1);</span>
<span class="fc" id="L852">        ArrayUtils.sum(tmp1, tmp3, tmp1);</span>
        // no need to set v = tmp1, because it already has this value
<span class="fc" id="L854">        controlCameraPoints = controlPointsFromV(tmp1);</span>

<span class="fc" id="L856">        solution = computePossibleSolutionWithPoseAndReprojectionError(controlCameraPoints);</span>
<span class="fc" id="L857">        solutions.add(solution);</span>
<span class="fc" id="L858">    }</span>

    /**
     * Tests solution 2 for general point configuration.
     * Because solution is up to scale, 4 different solutions for different
     * beta1 and beta2 signs are tried.
     *
     * @throws AlgebraException          if a numerical degeneracy occurs.
     * @throws LockedException           never happens.
     * @throws NotReadyException         never happens.
     * @throws CoincidentPointsException if a point degeneracy has occurred.
     */
    private void generalSolution2() throws AlgebraException, LockedException, NotReadyException,
            CoincidentPointsException {
        // we have the distance constraints between control world points (c) and
        // control camera points (v):
        // ||beta*vi - beta*vj||^2 = ||ci - cj||^2, i,j 1...4
        // we need to find beta to scale control camera points
        // in the case we pick 2 columns of the null-space v, then v is a linear
        // combination v = beta1*vA + beta2*vB and previous equation becomes
        // ||(beta1*vAi + beta2*vBi) - (beta1*vAj + beta2*vBj)||^2 = ||ci - cj||^2, i,j 1...4
        // This equation can be expanded in x,y,z coordinates as follows:
        // ((beta1*vAix + beta2*vBix) - (beta1*vAjx + beta2*vBjx))^2 + ((beta1*vAiy + beta2*vBiy) - (beta1*vAjy + beta2*vBjy))^2 + ((beta1*vAiz + beta2*vBiz) - (beta1*vAjz + beta2*vBjz))^2 = ((cix - cjx)^2 + (ciy - cjy)^2 + (ciz - cjz)^2),		i,j 1...4
        // (beta1*(vAix - vAjx) + beta2*(vBix - vBjx))^2 + (beta1*(vAiy - vAjy) + beta2*(vBiy - vBjy))^2 + (beta1*(vAiz - vAjz) + beta2*(vBiz - vBjz))^2 = ((cix - cjx)^2 + (ciy - cjy)^2 + (ciz - cjz)^2),		i,j 1...4
        // beta1^2*(vAix - vAjx)^2 + beta1*beta2*2*(vAix - vAjx)*(vBix - vBjx) + beta2^2*(vBix - vBjx)^2 + beta1^2*(vAiy - vAjy)^2 + beta1*beta2*2*(vAiy - vAjy)*(vBiy - vBjy) + beta2^2*(vBiy - vBjy)^2 + beta1^2*(vAiz - vAjz)^2 + beta1*beta2*2*(vAiz - vAjz)*(vBiz - vBjz) + beta2^2*(vBiz - vBjz)^2 = ((cix - cjx)^2 + (ciy - cjy)^2 + (ciz - cjz)^2),		i,j 1...4

        // Since beta1 and beta2 are the unknowns, we can reorganize equation as:
        // beta1^2*((vAix - vAjx)^2 + (vAiy - vAjy)^2 + (vAiz - vAjz)^2) +
        // beta1*beta2*2*((vAix - vAjx)*(vBix - vBjx) + (vAiy - vAjy)*(vBiy - vBjy) + (vAiz - vAjz)*(vBiz - vBjz)) +
        // beta2^2*((vBix - vBjx)^2 + (vBiy - vBjy)^2 + (vBiz - vBjz)^2) =
        // ((cix - cjx)^2 + (ciy - cjy)^2 + (ciz - cjz)^2),		i,j 1...4

        // We linearize the equation assuming:
        // alpha1 = beta1^2
        // alpha2 = beta1*beta2
        // alpha3 = beta2^2

        // alpha1*((vAix - vAjx)^2 + (vAiy - vAjy)^2 + (vAiz - vAjz)^2) + alpha2*2*((vAix - vAjx)*(vBix - vBjx) + (vAiy - vAjy)*(vBiy - vBjy) + (vAiz - vAjz)*(vBiz - vBjz)) + alpha3*((vBix - vBjx)^2 + (vBiy - vBjy)^2 + (vBiz - vBjz)^2) = ((cix - cjx)^2 + (ciy - cjy)^2 + (ciz - cjz)^2),		i,j 1...4

        // finally we evaluate the equation for all 6 possible combinations of
        // i,j 1...4 when we have 4 control points
        // Obtaining the following equations:
        // alpha1*((vA1x - vA2x)^2 + (vA1y - vA2y)^2 + (vA1z - vA2z)^2) + alpha2*2*((vA1x - vA2x)*(vB1x - vB2x) + (vA1y - vA2y)*(vB1y - vB2y) + (vA1z - vA2z)*(vB1z - vB2z)) + alpha3*((vB1x - vB2x)^2 + (vB1y - vB2y)^2 + (vB1z - vB2z)^2) = ((cix - cjx)^2 + (ciy - cjy)^2 + (ciz - cjz)^2)
        // alpha1*((vA1x - vA3x)^2 + (vA1y - vA3y)^2 + (vA1z - vA3z)^2) + alpha2*2*((vA1x - vA3x)*(vB1x - vB3x) + (vA1y - vA3y)*(vB1y - vB3y) + (vA1z - vA3z)*(vB1z - vB3z)) + alpha3*((vB1x - vB3x)^2 + (vB1y - vB3y)^2 + (vB1z - vB3z)^2) = ((cix - cjx)^2 + (ciy - cjy)^2 + (ciz - cjz)^2)
        // alpha1*((vA1x - vA4x)^2 + (vA1y - vA4y)^2 + (vA1z - vA4z)^2) + alpha2*2*((vA1x - vA4x)*(vB1x - vB4x) + (vA1y - vA4y)*(vB1y - vB4y) + (vA1z - vA4z)*(vB1z - vB4z)) + alpha3*((vB1x - vB4x)^2 + (vB1y - vB4y)^2 + (vB1z - vB4z)^2) = ((cix - cjx)^2 + (ciy - cjy)^2 + (ciz - cjz)^2)
        // alpha1*((vA2x - vA3x)^2 + (vA2y - vA3y)^2 + (vA2z - vA3z)^2) + alpha2*2*((vA2x - vA3x)*(vB2x - vB3x) + (vA2y - vA3y)*(vB2y - vB3y) + (vA2z - vA3z)*(vB2z - vB3z)) + alpha3*((vB2x - vB3x)^2 + (vB2y - vB3y)^2 + (vB2z - vB3z)^2) = ((cix - cjx)^2 + (ciy - cjy)^2 + (ciz - cjz)^2)
        // alpha1*((vA2x - vA4x)^2 + (vA2y - vA4y)^2 + (vA2z - vA4z)^2) + alpha2*2*((vA2x - vA4x)*(vB2x - vB4x) + (vA2y - vA4y)*(vB2y - vB4y) + (vA2z - vA4z)*(vB2z - vB4z)) + alpha3*((vB2x - vB4x)^2 + (vB2y - vB4y)^2 + (vB2z - vB4z)^2) = ((cix - cjx)^2 + (ciy - cjy)^2 + (ciz - cjz)^2)
        // alpha1*((vA3x - vA4x)^2 + (vA3y - vA4y)^2 + (vA3z - vA4z)^2) + alpha2*2*((vA3x - vA4x)*(vB3x - vB4x) + (vA3y - vA4y)*(vB3y - vB4y) + (vA3z - vA4z)*(vB3z - vB4z)) + alpha3*((vB3x - vB4x)^2 + (vB3y - vB4y)^2 + (vB3z - vB4z)^2) = ((cix - cjx)^2 + (ciy - cjy)^2 + (ciz - cjz)^2)

        // where alpha1, alpha2 and alpha3 are the unknowns of linear system of
        // equations whose matrix C has size 6,3 (as seen below), and the right
        // terms of the equation can be built by calling method
        // #rhos(List&lt;Point3D&gt;) in this class

<span class="fc" id="L912">        final var va = nullspace.get(0);</span>
<span class="fc" id="L913">        final var vb = nullspace.get(1);</span>

<span class="fc" id="L915">        final var controlCameraPointsA = controlPointsFromV(va);</span>
<span class="fc" id="L916">        final var controlCameraPointsB = controlPointsFromV(vb);</span>

<span class="fc" id="L918">        final var c = constraintMatrixSolution2(controlCameraPointsA, controlCameraPointsB);</span>
<span class="fc" id="L919">        final var rhos = rhos(controlWorldPoints);</span>

<span class="fc" id="L921">        final var a = Utils.solve(c, rhos);</span>

        // obtained a values are related to betas with the following expressions
        // due to linearization:
        // alpha1 = beta1^2
        // alpha2 = beta1*beta2
        // alpha3 = beta2^2

        double beta1;
        double beta2;
<span class="fc bfc" id="L931" title="All 2 branches covered.">        if (a[0] &lt; 0.0) {</span>
<span class="fc" id="L932">            beta1 = Math.sqrt(-a[0]);</span>
<span class="fc bfc" id="L933" title="All 2 branches covered.">            beta2 = a[2] &lt; 0.0 ? Math.sqrt(-a[2]) : 0.0;</span>
        } else {
<span class="fc" id="L935">            beta1 = Math.sqrt(a[0]);</span>
<span class="fc bfc" id="L936" title="All 2 branches covered.">            beta2 = a[2] &gt; 0.0 ? Math.sqrt(a[2]) : 0.0;</span>
        }

        // fix sign of betas
<span class="fc bfc" id="L940" title="All 2 branches covered.">        if (a[1] &lt; 0.0) {</span>
<span class="fc" id="L941">            beta1 = -beta1;</span>
        }

<span class="fc" id="L944">        final var initialBeta1 = beta1;</span>
<span class="fc" id="L945">        final var initialBeta2 = beta2;</span>

        // compute linear combination of va and vb as v = beta1*va + beta2*vb
<span class="fc" id="L948">        final var tmp1 = ArrayUtils.multiplyByScalarAndReturnNew(va, beta1);</span>
<span class="fc" id="L949">        final var tmp2 = ArrayUtils.multiplyByScalarAndReturnNew(vb, beta2);</span>
<span class="fc" id="L950">        ArrayUtils.sum(tmp1, tmp2, tmp1);</span>
<span class="fc" id="L951">        var controlCameraPoints = controlPointsFromV(tmp1);</span>

<span class="fc" id="L953">        var solution = computePossibleSolutionWithPoseAndReprojectionError(controlCameraPoints);</span>
<span class="fc" id="L954">        solutions.add(solution);</span>

        // because solutions are square roots, beta1 and beta2 can have different
        // signs, so we add solutions for each combination so that the one with
        // the smallest re-projection error will be picked
<span class="fc" id="L959">        beta1 = -initialBeta1;</span>
<span class="fc" id="L960">        beta2 = -initialBeta2;</span>

<span class="fc" id="L962">        ArrayUtils.multiplyByScalar(va, beta1, tmp1);</span>
<span class="fc" id="L963">        ArrayUtils.multiplyByScalar(vb, beta2, tmp2);</span>
<span class="fc" id="L964">        ArrayUtils.sum(tmp1, tmp2, tmp1);</span>
        // no need to set v = tmp1, as it already has this value
<span class="fc" id="L966">        controlCameraPoints = controlPointsFromV(tmp1);</span>

<span class="fc" id="L968">        solution = computePossibleSolutionWithPoseAndReprojectionError(controlCameraPoints);</span>
<span class="fc" id="L969">        solutions.add(solution);</span>

<span class="fc" id="L971">        beta1 = initialBeta1;</span>
<span class="fc" id="L972">        beta2 = -initialBeta2;</span>

<span class="fc" id="L974">        ArrayUtils.multiplyByScalar(va, beta1, tmp1);</span>
<span class="fc" id="L975">        ArrayUtils.multiplyByScalar(vb, beta2, tmp2);</span>
<span class="fc" id="L976">        ArrayUtils.sum(tmp1, tmp2, tmp1);</span>
        // no need to set v = tmp1, as it already has this value
<span class="fc" id="L978">        controlCameraPoints = controlPointsFromV(tmp1);</span>

<span class="fc" id="L980">        solution = computePossibleSolutionWithPoseAndReprojectionError(controlCameraPoints);</span>
<span class="fc" id="L981">        solutions.add(solution);</span>

<span class="fc" id="L983">        beta1 = -initialBeta1;</span>
<span class="fc" id="L984">        beta2 = initialBeta2;</span>

<span class="fc" id="L986">        ArrayUtils.multiplyByScalar(va, beta1, tmp1);</span>
<span class="fc" id="L987">        ArrayUtils.multiplyByScalar(vb, beta2, tmp2);</span>
<span class="fc" id="L988">        ArrayUtils.sum(tmp1, tmp2, tmp1);</span>
        // no need to set v = tmp1, as it already has this value
<span class="fc" id="L990">        controlCameraPoints = controlPointsFromV(tmp1);</span>

<span class="fc" id="L992">        solution = computePossibleSolutionWithPoseAndReprojectionError(controlCameraPoints);</span>
<span class="fc" id="L993">        solutions.add(solution);</span>
<span class="fc" id="L994">    }</span>

    /**
     * Fills constraint matrix to solve betas when using control points from the
     * last 3 columns of v (the null-space).
     * The solution will be the linear combination of control points from the
     * last 3 columns using estimated betas. This solution will be control
     * points in camera coordinates.
     *
     * @param controlCameraPointsA control points of last column of v.
     * @param controlCameraPointsB control points of second last column of v.
     * @param controlCameraPointsC control points of third last column of v.
     * @return constraint matrix to solve a linear system of equations.
     * @throws AlgebraException never happens.
     */
    private static Matrix constraintMatrixSolution3(
            final List&lt;Point3D&gt; controlCameraPointsA, final List&lt;Point3D&gt; controlCameraPointsB,
            final List&lt;Point3D&gt; controlCameraPointsC) throws AlgebraException {

<span class="fc" id="L1013">        final var numControl = controlCameraPointsA.size();</span>
<span class="fc" id="L1014">        final var numEquations = numEquations(numControl);</span>

<span class="fc" id="L1016">        final var c = new Matrix(numEquations, 6);</span>
<span class="fc" id="L1017">        int row = 0;</span>
<span class="fc bfc" id="L1018" title="All 2 branches covered.">        for (var i = 0; i &lt; numControl; i++) {</span>
<span class="fc" id="L1019">            final var vai = controlCameraPointsA.get(i);</span>
<span class="fc" id="L1020">            final var vbi = controlCameraPointsB.get(i);</span>
<span class="fc" id="L1021">            final var vci = controlCameraPointsC.get(i);</span>

<span class="fc bfc" id="L1023" title="All 2 branches covered.">            for (var j = i + 1; j &lt; numControl; j++) {</span>
<span class="fc" id="L1024">                final var vaj = controlCameraPointsA.get(j);</span>
<span class="fc" id="L1025">                final var vbj = controlCameraPointsB.get(j);</span>
<span class="fc" id="L1026">                final var vcj = controlCameraPointsC.get(j);</span>

<span class="fc" id="L1028">                fillRowConstraintMatrixSolution3(row, c, vai, vaj, vbi, vbj, vci, vcj);</span>
<span class="fc" id="L1029">                row++;</span>
            }
        }

<span class="fc" id="L1033">        return c;</span>
    }

    /**
     * Fills constraint matrix to solve betas when using control points from the
     * last 2 columns of v (the null-space).
     * The solution will be the linear combination of control points from the
     * last 2 columns using estimated betas. This solution will be control
     * points in camera coordinates.
     *
     * @param controlCameraPointsA control points of last column of v.
     * @param controlCameraPointsB control points of second last column of v.
     * @return constraint matrix to solve a linear system of equations.
     * @throws AlgebraException never happens.
     */
    private static Matrix constraintMatrixSolution2(
            final List&lt;Point3D&gt; controlCameraPointsA, final List&lt;Point3D&gt; controlCameraPointsB)
            throws AlgebraException {

<span class="fc" id="L1052">        final var numControl = controlCameraPointsA.size();</span>
<span class="fc" id="L1053">        final var numEquations = numEquations(numControl);</span>

<span class="fc" id="L1055">        final var c = new Matrix(numEquations, 3);</span>
<span class="fc" id="L1056">        var row = 0;</span>
<span class="fc bfc" id="L1057" title="All 2 branches covered.">        for (var i = 0; i &lt; numControl; i++) {</span>
<span class="fc" id="L1058">            final var vai = controlCameraPointsA.get(i);</span>
<span class="fc" id="L1059">            final var vbi = controlCameraPointsB.get(i);</span>

<span class="fc bfc" id="L1061" title="All 2 branches covered.">            for (var j = i + 1; j &lt; numControl; j++) {</span>
<span class="fc" id="L1062">                final var vaj = controlCameraPointsA.get(j);</span>
<span class="fc" id="L1063">                final var vbj = controlCameraPointsB.get(j);</span>

<span class="fc" id="L1065">                fillRowConstraintMatrixSolution2(row, c, vai, vaj, vbi, vbj);</span>
<span class="fc" id="L1066">                row++;</span>
            }
        }

<span class="fc" id="L1070">        return c;</span>
    }

    /**
     * Fills a row of constraint matrix for solution 3.
     *
     * @param row row to be filled.
     * @param c   matrix to be filled.
     * @param vai i-th control point in camera coordinates of last column of v
     *            (i.e. the null-space).
     * @param vaj j-th control point in camera coordinates of last column of v
     *            (i.e. the null-space).
     * @param vbi i-th control point in camera coordinates of second last column
     *            of v (i.e. the null-space).
     * @param vbj j-th control point in camera coordinates of second last column
     *            of v (i.e. the null-space).
     * @param vci i-th control point in camera coordinates of third last column
     *            of v (i.e. the null-space).
     * @param vcj j-th control point in camera coordinates of third last column
     *            of v (i.e. the null-space).
     */
    private static void fillRowConstraintMatrixSolution3(
            final int row, final Matrix c, final Point3D vai, final Point3D vaj, final Point3D vbi, final Point3D vbj,
            final Point3D vci, final Point3D vcj) {

<span class="fc" id="L1095">        final var vaix = vai.getInhomX();</span>
<span class="fc" id="L1096">        final var vaiy = vai.getInhomY();</span>
<span class="fc" id="L1097">        final var vaiz = vai.getInhomZ();</span>

<span class="fc" id="L1099">        final var vajx = vaj.getInhomX();</span>
<span class="fc" id="L1100">        final var vajy = vaj.getInhomY();</span>
<span class="fc" id="L1101">        final var vajz = vaj.getInhomZ();</span>

<span class="fc" id="L1103">        final var vbix = vbi.getInhomX();</span>
<span class="fc" id="L1104">        final var vbiy = vbi.getInhomY();</span>
<span class="fc" id="L1105">        final var vbiz = vbi.getInhomZ();</span>

<span class="fc" id="L1107">        final var vbjx = vbj.getInhomX();</span>
<span class="fc" id="L1108">        final var vbjy = vbj.getInhomY();</span>
<span class="fc" id="L1109">        final var vbjz = vbj.getInhomZ();</span>

<span class="fc" id="L1111">        final var vcix = vci.getInhomX();</span>
<span class="fc" id="L1112">        final var vciy = vci.getInhomY();</span>
<span class="fc" id="L1113">        final var vciz = vci.getInhomZ();</span>

<span class="fc" id="L1115">        final var vcjx = vcj.getInhomX();</span>
<span class="fc" id="L1116">        final var vcjy = vcj.getInhomY();</span>
<span class="fc" id="L1117">        final var vcjz = vcj.getInhomZ();</span>

        // 1st column
<span class="fc" id="L1120">        c.setElementAt(row, 0, Math.pow(vaix - vajx, 2.0) + Math.pow(vaiy - vajy, 2.0)</span>
<span class="fc" id="L1121">                + Math.pow(vaiz - vajz, 2.0));</span>

        // 2nd column
<span class="fc" id="L1124">        c.setElementAt(row, 1, 2.0 * ((vaix - vajx) * (vbix - vbjx) + (vaiy - vajy) * (vbiy - vbjy)</span>
                + (vaiz - vajz) * (vbiz - vbjz)));

        // 3rd column
<span class="fc" id="L1128">        c.setElementAt(row, 2, 2.0 * ((vaix - vajx) * (vcix - vcjx) + (vaiy - vajy) * (vciy - vcjy)</span>
                + (vaiz - vajz) * (vciz - vcjz)));

        // 4th column
<span class="fc" id="L1132">        c.setElementAt(row, 3, Math.pow(vbix - vbjx, 2.0) + Math.pow(vbiy - vbjy, 2.0)</span>
<span class="fc" id="L1133">                + Math.pow(vbiz - vbjz, 2.0));</span>

        // 5th column
<span class="fc" id="L1136">        c.setElementAt(row, 4, 2.0 * ((vbix - vbjx) * (vcix - vcjx) + (vbiy - vbjy) * (vciy - vcjy)</span>
                + (vbiz - vbjz) * (vciz - vcjz)));

        // 6th column
<span class="fc" id="L1140">        c.setElementAt(row, 5, Math.pow(vcix - vcjx, 2.0) + Math.pow(vciy - vcjy, 2.0)</span>
<span class="fc" id="L1141">                + Math.pow(vciz - vcjz, 2.0));</span>
<span class="fc" id="L1142">    }</span>

    /**
     * Fills a row of constraint matrix for solution 2.
     *
     * @param row row to be filled.
     * @param c   matrix to be filled.
     * @param vai i-th control point in camera coordinates of last column of v
     *            (i.e. the null-space).
     * @param vaj j-th control point in camera coordinates of last column of v
     *            (i.e. the null-space).
     * @param vbi i-th control point in camera coordinates of second last column
     *            of v (i.e. the null-space).
     * @param vbj j-th control point in camera coordinates of second last column
     *            of v (i.e. the null-space).
     */
    private static void fillRowConstraintMatrixSolution2(
            final int row, final Matrix c, final Point3D vai, final Point3D vaj, final Point3D vbi, final Point3D vbj) {

<span class="fc" id="L1161">        final var vaix = vai.getInhomX();</span>
<span class="fc" id="L1162">        final var vaiy = vai.getInhomY();</span>
<span class="fc" id="L1163">        final var vaiz = vai.getInhomZ();</span>

<span class="fc" id="L1165">        final var vajx = vaj.getInhomX();</span>
<span class="fc" id="L1166">        final var vajy = vaj.getInhomY();</span>
<span class="fc" id="L1167">        final var vajz = vaj.getInhomZ();</span>

<span class="fc" id="L1169">        final var vbix = vbi.getInhomX();</span>
<span class="fc" id="L1170">        final var vbiy = vbi.getInhomY();</span>
<span class="fc" id="L1171">        final var vbiz = vbi.getInhomZ();</span>

<span class="fc" id="L1173">        final var vbjx = vbj.getInhomX();</span>
<span class="fc" id="L1174">        final var vbjy = vbj.getInhomY();</span>
<span class="fc" id="L1175">        final var vbjz = vbj.getInhomZ();</span>

        // 1st column
<span class="fc" id="L1178">        c.setElementAt(row, 0, Math.pow(vaix - vajx, 2.0) + Math.pow(vaiy - vajy, 2.0)</span>
<span class="fc" id="L1179">                + Math.pow(vaiz - vajz, 2.0));</span>

        // 2nd column
<span class="fc" id="L1182">        c.setElementAt(row, 1, 2.0 * ((vaix - vajx) * (vbix - vbjx) + (vaiy - vajy) * (vbiy - vbjy)</span>
                + (vaiz - vajz) * (vbiz - vbjz)));

        // 3rd column
<span class="fc" id="L1186">        c.setElementAt(row, 2, Math.pow(vbix - vbjx, 2.0) + Math.pow(vbiy - vbjy, 2.0)</span>
<span class="fc" id="L1187">                + Math.pow(vbiz - vbjz, 2.0));</span>
<span class="fc" id="L1188">    }</span>

    /**
     * Tests solution 1 for general point configuration.
     * Because solution is up to scale. Two possible solutions must be evaluated
     * (positive or negative scale). The one with the smallest re-projection
     * error will be picked.
     *
     * @throws LockedException           never happens.
     * @throws NotReadyException         never happens.
     * @throws CoincidentPointsException if a point degeneracy has occurred.
     */
    private void generalSolution1() throws LockedException, NotReadyException, CoincidentPointsException {
        // pick last column of null-space, contains control points in camera
        // coordinates up to scale (including sign change)
<span class="fc" id="L1203">        var v = nullspace.get(0);</span>
<span class="fc" id="L1204">        var controlCameraPoints = controlPointsFromV(v);</span>

        // similarly to solution2 and solution3, we could find the scale by
        // imposing the restriction: ||beta*vi - beta*vj||^2 = ||ci - cj||^2, i,j 1...4
        // This results in a linear system of 6 equations (when we have 4 control
        // points)
        // The previous constraint can be expanded as follows:
        // (beta*vi - beta*vj)^2 = (ci - cj)^2
        // (beta*vix - beta*vjx)^2 + (beta*viy - beta*vjy)^2 + (beta*viz - beta*vjz)^2 = (cix - cjx)^2 + (ciy - cjy)^2 + (ciz - cjz)^2,		i,j 1...4
        // beta^2*(vix - vjx)^2 + beta^2*(viy - vjy)^2 + beta^2*(viz - vjz)^2 = (cix - cjx)^2 + (ciy - cjy)^2 + (ciz - cjz)^2,		i,j 1...4
        // beta^2*((vix - vjx)^2 + (viy - vjy)^2 + (viz - vjz)^2) = (cix - cjx)^2 + (ciy - cjy)^2 + (ciz - cjz)^2,		i,j 1...4
        //
        // And the system is linearized by assuming
        // alpha = beta^2
        //
        // alpha * ((vix - vjx)^2 + (viy - vjy)^2 + (viz - vjz)^2) = (cix - cjx)^2 + (ciy - cjy)^2 + (ciz - cjz)^2,		i,j 1...4

        // However, in order to find a solution a MetricTransformation3D estimator
        // is used, which is capable to determine the scale relating input and
        // output points, and thus, solving the linear system of equations is not
        // required in this case.
<span class="fc" id="L1225">        var solution = computePossibleSolutionWithPoseAndReprojectionError(controlCameraPoints);</span>
<span class="fc" id="L1226">        solutions.add(solution);</span>

        // because v is a solution up to scale, we provide a solution with
        // opposite sign
<span class="fc" id="L1230">        v = ArrayUtils.multiplyByScalarAndReturnNew(v, -1.0);</span>
<span class="fc" id="L1231">        controlCameraPoints = controlPointsFromV(v);</span>

<span class="fc" id="L1233">        solution = computePossibleSolutionWithPoseAndReprojectionError(controlCameraPoints);</span>
<span class="fc" id="L1234">        solutions.add(solution);</span>
<span class="fc" id="L1235">    }</span>

    /**
     * Computes a possible solution with camera, transformation, re-projection
     * error and control points in camera coordinates.
     *
     * @param controlCameraPoints control points in camera coordinates.
     * @return a possible solution.
     * @throws LockedException           never happens.
     * @throws NotReadyException         never happens.
     * @throws CoincidentPointsException if a point degeneracy has occurred.
     */
    private Solution computePossibleSolutionWithPoseAndReprojectionError(
            final List&lt;Point3D&gt; controlCameraPoints) throws LockedException, NotReadyException,
            CoincidentPointsException {

<span class="fc" id="L1251">        final var worldToCameraTransformation = worldToCameraTransformationMetric(controlCameraPoints);</span>

<span class="fc" id="L1253">        final var rotation = worldToCameraTransformation.getRotation();</span>
<span class="fc" id="L1254">        final var t = worldToCameraTransformation.getTranslation();</span>
<span class="fc" id="L1255">        final var scale = worldToCameraTransformation.getScale();</span>

        // Camera center is C = -1/s*R'*t
<span class="fc" id="L1258">        final var center = new InhomogeneousPoint3D(-t[0] / scale, -t[1] / scale, -t[2] / scale);</span>
<span class="fc" id="L1259">        final var invRotation = rotation.inverseRotationAndReturnNew();</span>
<span class="fc" id="L1260">        invRotation.rotate(center, center);</span>

<span class="fc" id="L1262">        final var camera = new PinholeCamera(intrinsic, rotation, center);</span>

<span class="fc" id="L1264">        final var solution = new Solution();</span>
<span class="fc" id="L1265">        solution.controlCameraPoints = controlCameraPoints;</span>
<span class="fc" id="L1266">        solution.worldToCameraTransformation = worldToCameraTransformation;</span>
<span class="fc" id="L1267">        solution.camera = camera;</span>

        // compute projection error
<span class="fc" id="L1270">        solution.reprojectionError = reprojectionError(camera);</span>

<span class="fc" id="L1272">        return solution;</span>
    }

    /**
     * Estimates world to camera transformation using estimated control points
     * in world and camera coordinates as a metric transformation.
     *
     * @param controlCameraPoints control points in camera coordinates.
     * @return metric transformation relating control points from world to
     * camera coordinates.
     * @throws LockedException           never happens.
     * @throws NotReadyException         never happens.
     * @throws CoincidentPointsException if a point degeneracy has occurred.
     */
    private MetricTransformation3D worldToCameraTransformationMetric(final List&lt;Point3D&gt; controlCameraPoints)
            throws LockedException, NotReadyException, CoincidentPointsException {
<span class="fc" id="L1288">        final var estimator = new MetricTransformation3DEstimator(controlWorldPoints, controlCameraPoints, isPlanar);</span>
<span class="fc" id="L1289">        return estimator.estimate();</span>
    }

    /**
     * Number of equations required to solve constraints for case 1 to 4.
     *
     * @param numControl number of control points.
     * @return number of constraint equations.
     */
    private static int numEquations(final int numControl) {
<span class="fc" id="L1299">        var numEquations = 0;</span>
<span class="fc bfc" id="L1300" title="All 2 branches covered.">        for (var i = 1; i &lt; numControl; i++) {</span>
<span class="fc" id="L1301">            numEquations += i;</span>
        }
<span class="fc" id="L1303">        return numEquations;</span>
    }

    /**
     * Right term of linearized system of equations to solve betas.
     *
     * @param controlWorldPoints control points in world coordinates.
     * @return right term.
     */
    private static double[] rhos(final List&lt;Point3D&gt; controlWorldPoints) {
<span class="fc" id="L1313">        final var numControl = controlWorldPoints.size();</span>
<span class="fc" id="L1314">        final var numEquations = numEquations(numControl);</span>
<span class="fc" id="L1315">        final var rhos = new double[numEquations];</span>

        // squared distance from control world i to control world j
        double dcijSqr;
<span class="fc" id="L1319">        var pos = 0;</span>
<span class="fc bfc" id="L1320" title="All 2 branches covered.">        for (var i = 0; i &lt; numControl; i++) {</span>
<span class="fc" id="L1321">            final var ci = controlWorldPoints.get(i);</span>

<span class="fc bfc" id="L1323" title="All 2 branches covered.">            for (var j = i + 1; j &lt; numControl; j++) {</span>
<span class="fc" id="L1324">                final var cj = controlWorldPoints.get(j);</span>

<span class="fc" id="L1326">                dcijSqr = Math.pow(ci.distanceTo(cj), 2.0);</span>
<span class="fc" id="L1327">                rhos[pos] = dcijSqr;</span>
<span class="fc" id="L1328">                pos++;</span>
            }
        }

<span class="fc" id="L1332">        return rhos;</span>
    }

    /**
     * Total re-projection error for provided camera.
     *
     * @param camera camera to estimate re-projection error.
     * @return reprojection error.
     */
    private double reprojectionError(final PinholeCamera camera) {
<span class="fc" id="L1342">        final var n = points2D.size();</span>

        Point3D point3D;
<span class="fc" id="L1345">        final var projected = Point2D.create();</span>
        Point2D point2D;
<span class="fc" id="L1347">        var error = 0.0;</span>
<span class="fc bfc" id="L1348" title="All 2 branches covered.">        for (var i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L1349">            point3D = points3D.get(i);</span>
<span class="fc" id="L1350">            point2D = points2D.get(i);</span>
<span class="fc" id="L1351">            camera.project(point3D, projected);</span>
<span class="fc" id="L1352">            error += projected.distanceTo(point2D);</span>
        }
<span class="fc" id="L1354">        return error;</span>
    }

    /**
     * Computes list of control points from provided array containing one column
     * of the null-space of M or a linear combination of columns of the
     * null-space.
     *
     * @param v one column of the null-space of M or a linear combination of
     *          columns of the null-space.
     * @return control points.
     */
    private List&lt;Point3D&gt; controlPointsFromV(final double[] v) {
<span class="fc" id="L1367">        final var numControl = controlWorldPoints.size();</span>
<span class="fc" id="L1368">        final var points = new ArrayList&lt;Point3D&gt;();</span>

<span class="fc bfc" id="L1370" title="All 2 branches covered.">        for (var j = 0; j &lt; numControl; j++) {</span>
<span class="fc" id="L1371">            final var k = j * 3;</span>
<span class="fc" id="L1372">            final var p = new InhomogeneousPoint3D(v[k], v[k + 1], v[k + 2]);</span>
<span class="fc" id="L1373">            points.add(p);</span>
        }

<span class="fc" id="L1376">        return points;</span>
    }

    /**
     * Solves null-space of matrix M containing possible solutions of camera
     * coordinates of control points.
     *
     * @throws AlgebraException if something fails due to numerical
     *                          instabilities.
     */
    private void solveNullspace() throws AlgebraException {
<span class="fc" id="L1387">        final var rows = m.getRows();</span>
<span class="fc" id="L1388">        final var cols = m.getColumns();</span>
<span class="fc" id="L1389">        final var numControl = cols / Point3D.POINT3D_INHOMOGENEOUS_COORDINATES_LENGTH;</span>

        // normalize rows of m to increase numerical accuracy
<span class="fc bfc" id="L1392" title="All 2 branches covered.">        for (var i = 0; i &lt; rows; i++) {</span>
<span class="fc" id="L1393">            normalizeRow(m, i);</span>
        }

<span class="fc" id="L1396">        final var decomposer = new SingularValueDecomposer(m);</span>
<span class="fc" id="L1397">        decomposer.decompose();</span>

        // Singular values are always in descending order, hence null space is in
        // the last columns of v.
        // V is 12x12 (general configuration) or 9x9 (planar configuration).
        // Each column of v contains coordinates of control points in camera
        // coordinates.
        // A solution for the linear system M*x = 0 is obtained as a linear
        // combination of the columns of v forming the null-space.
<span class="fc" id="L1406">        final var v = decomposer.getV();</span>

        // although nullity of M could be determined after SVD, it is assumed
        // instead that null-space could be located in any of the latter columns
        // of v up to the number of control points.
        // Hence, for general configuration we pick the last 4 columns of v and
        // for planar configuration we pick the last 3.

        // extract null points from the null space
<span class="fc" id="L1415">        nullspace = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1416">        final var colsMinusOne = cols - 1;</span>
<span class="fc bfc" id="L1417" title="All 2 branches covered.">        for (var i = 0; i &lt; numControl; i++) {</span>
<span class="fc" id="L1418">            final var column = colsMinusOne - i;</span>

            // each picked column of v contains a possible solution
<span class="fc" id="L1421">            final var vCol = v.getSubmatrixAsArray(0, column, colsMinusOne, column);</span>
<span class="fc" id="L1422">            nullspace.add(vCol);</span>
        }
<span class="fc" id="L1424">    }</span>

    /**
     * Normalizes provided row of m.
     *
     * @param m   matrix to be normalized.
     * @param row row to be normalized.
     */
    private static void normalizeRow(final Matrix m, final int row) {
<span class="fc" id="L1433">        final var cols = m.getColumns();</span>

<span class="fc" id="L1435">        var norm = 0.0;</span>
<span class="fc bfc" id="L1436" title="All 2 branches covered.">        for (int i = 0; i &lt; cols; i++) {</span>
<span class="fc" id="L1437">            norm += Math.pow(m.getElementAt(row, i), 2.0);</span>
        }
<span class="fc" id="L1439">        norm = Math.sqrt(norm);</span>

<span class="fc bfc" id="L1441" title="All 2 branches covered.">        for (var i = 0; i &lt; cols; i++) {</span>
<span class="fc" id="L1442">            m.setElementAt(row, i, m.getElementAt(row, i) / norm);</span>
        }
<span class="fc" id="L1444">    }</span>

    /**
     * In order to find control points in camera coordinates, an homogeneous
     * linear system of equations must be solved having the form M*x = 0, where
     * x contains the coordinates of all control points in the form [x1, y1, z1,
     * x2, y2, z2, ... ].
     * For general configuration there are 4 control points, hence x has length
     * 12 (3 coordinates * 4 control points).
     * For a planar configuration there are 3 control points, hence x has length
     * 9 (3 coordinates * 3 control points).
     * This method builds M matrix required to solve such linear system of
     * equations, where M has size 2*n x 12 (general configuration) or 2*n x 9
     * (planar configuration), where n is the number of provided 2D observed
     * points.
     *
     * @throws AlgebraException if numerical instabilities occur.
     */
    private void buildM() throws AlgebraException {
<span class="fc" id="L1463">        final var n = points2D.size();</span>
<span class="fc" id="L1464">        final var numControlPoints = alphas.getColumns();</span>

<span class="fc" id="L1466">        m = new Matrix(2 * n, 3 * numControlPoints);</span>

        int row;
        int col;
        double alpha;

<span class="fc" id="L1472">        final var horizontalFocalLength = intrinsic.getHorizontalFocalLength();</span>
<span class="fc" id="L1473">        final var verticalFocalLength = intrinsic.getVerticalFocalLength();</span>
<span class="fc" id="L1474">        final var skewness = intrinsic.getSkewness();</span>
<span class="fc" id="L1475">        final var horizontalPrincipalPoint = intrinsic.getHorizontalPrincipalPoint();</span>
<span class="fc" id="L1476">        final var verticalPrincipalPoint = intrinsic.getVerticalPrincipalPoint();</span>

        Point2D p;
        double pX;
        double pY;
<span class="fc bfc" id="L1481" title="All 2 branches covered.">        for (var i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L1482">            p = points2D.get(i);</span>
<span class="fc" id="L1483">            pX = p.getInhomX();</span>
<span class="fc" id="L1484">            pY = p.getInhomY();</span>

<span class="fc" id="L1486">            row = i * 2;</span>

<span class="fc bfc" id="L1488" title="All 2 branches covered.">            for (var j = 0; j &lt; numControlPoints; j++) {</span>
<span class="fc" id="L1489">                col = j * 3;</span>

<span class="fc" id="L1491">                alpha = alphas.getElementAt(i, j);</span>

<span class="fc" id="L1493">                m.setElementAt(row, col, alpha * horizontalFocalLength);</span>
<span class="fc" id="L1494">                m.setElementAt(row, col + 1, alpha * skewness);</span>
<span class="fc" id="L1495">                m.setElementAt(row, col + 2, alpha * (horizontalPrincipalPoint - pX));</span>

<span class="fc" id="L1497">                m.setElementAt(row + 1, col, 0.0);</span>
<span class="fc" id="L1498">                m.setElementAt(row + 1, col + 1, alpha * verticalFocalLength);</span>
<span class="fc" id="L1499">                m.setElementAt(row + 1, col + 2, alpha * (verticalPrincipalPoint - pY));</span>
            }
        }
<span class="fc" id="L1502">    }</span>

    /**
     * Computes the coordinates of each provided world point in terms of
     * estimated control points in world coordinates.
     * Such coordinates (i.e. barycentric coordinates) are stored in alphas
     * matrix, where each row contains the coordinates of each world point in
     * terms of control points.
     * For general configuration, each row contains 4 coordinates and alphas
     * has size nx4, where n is the number of provided 3D world points.
     * For planar configuration, each row contains 3 coordinates and alphas
     * has size nx3, where n is the number of provided 3D world points.
     * Because world and camera coordinates are related by a rotation (since
     * both reference frames are centered in the centroid), alphas can be used
     * in both world and camera coordinates.
     *
     * @throws AlgebraException if there are numerical instabilities.
     */
    private void computeBarycentricCoordinates() throws AlgebraException {
        // we need to express world points in terms of control points in world
        // coordinates

        // In the general configuration case:
        // For a point p1 in world inhomogeneous coordinates
        // p1 =  alpha1 + c1 + alpha2 * c2 + alpha3 * c3 + alpha4 * c4
        // where alpha1, alpha2, alpha3, alpha4 are scalars and
        // c1, c2, c3 are the control points in the principal axes and
        // centroid is the last control point c4, all 4 expressed in world
        // inhomogeneous coordinates as 3-column vectors.

        // Assuming a matrix form:
        // [p1] = [c1 c2 c3 c4]*[alpha1]
        //                      [alpha2]
        //                      [alpha3]
        //                      [alpha4]

        // or in simpler for p = C * alpha, where p is a 3-column vector, C is a
        // 3x4 matrix and alpha is a 4-1 vector.
        // This can be repeated for each i-th point so that:
        // pi = C * alphai --&gt; alphai = inv(C)*pi
        // However, in this form C is not invertible because it is rank deficient
        // To avoid this deficiency we add the constraint that the sum of alphas
        // for a point must be 1, so we can use the reduced form:
        // [p1 - c4] = [(c1 - c4) (c2 - c4) (c3 - c4)]*[alpha1]
        //                                             [alpha2]
        //                                             [alpha3]
        // and set alpha4 = 1 - alpha1 - alpha2 - alpha3

        // This way the equation still holds:
        // p1 - c4 = (c1 - c4) * alpha1 + (c2 - c4) * alpha2 + (c3 - c4) * alpha3 =
        //         = c1 * alpha1 + c2 * alpha2 + c3 * alpha3 - c4 * (alpha1 + alpha2 + alpha3)
        // p1 = c1 * alpha1 + c2 * alpha2 * c3 * alpha3 + c4 * (1 - alpha1 - alpha2 - alpha3)

        // This way, we create reduced matrix C as having 3 rows (one for each
        // inhomogeneous coordinate) and 3 columns in the general case.

        // In the planar case we have only 3 control points, and the last one
        // (c3) is the centroid.

<span class="fc" id="L1561">        final var numControl = controlWorldPoints.size();</span>
<span class="fc" id="L1562">        final var numDimensions = numControl - 1;</span>
<span class="fc" id="L1563">        final var numControlMinusTwo = numControl - 2;</span>
<span class="fc" id="L1564">        final var c = new Matrix(Point3D.POINT3D_INHOMOGENEOUS_COORDINATES_LENGTH, numDimensions);</span>

        // the last control point is the centroid (or mean point)
<span class="fc" id="L1567">        final var mean = controlWorldPoints.get(numDimensions);</span>
<span class="fc" id="L1568">        final var meanX = mean.getInhomX();</span>
<span class="fc" id="L1569">        final var meanY = mean.getInhomY();</span>
<span class="fc" id="L1570">        final var meanZ = mean.getInhomZ();</span>

<span class="fc bfc" id="L1572" title="All 2 branches covered.">        for (var i = 0; i &lt; numDimensions; i++) {</span>
<span class="fc" id="L1573">            final var controlPoint = controlWorldPoints.get(i);</span>
<span class="fc" id="L1574">            c.setElementAt(0, i, controlPoint.getInhomX() - meanX);</span>
<span class="fc" id="L1575">            c.setElementAt(1, i, controlPoint.getInhomY() - meanY);</span>
<span class="fc" id="L1576">            c.setElementAt(2, i, controlPoint.getInhomZ() - meanZ);</span>
        }

        // to find  reduced alphas, we need to inverse the reduced C matrix and
        // multiply it by [p - centroid], where centroid can be c4 or c3 in
        // planar case.

<span class="fc" id="L1583">        final var invC = Utils.inverse(c);</span>

        // x is p - centroid, where p is each 3D world point
<span class="fc" id="L1586">        final var n = points3D.size();</span>
<span class="fc" id="L1587">        final var reducedPoint = new Matrix(Point3D.POINT3D_INHOMOGENEOUS_COORDINATES_LENGTH, 1);</span>
<span class="fc" id="L1588">        final var reducedAlpha = new Matrix(numDimensions, 1);</span>
        double[] buffer;
        Point3D worldPoint;
<span class="fc" id="L1591">        alphas = new Matrix(n, numControl);</span>
<span class="fc bfc" id="L1592" title="All 2 branches covered.">        for (var i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L1593">            worldPoint = points3D.get(i);</span>
<span class="fc" id="L1594">            reducedPoint.setElementAtIndex(0, worldPoint.getInhomX() - meanX);</span>
<span class="fc" id="L1595">            reducedPoint.setElementAtIndex(1, worldPoint.getInhomY() - meanY);</span>
<span class="fc" id="L1596">            reducedPoint.setElementAtIndex(2, worldPoint.getInhomZ() - meanZ);</span>

<span class="fc" id="L1598">            invC.multiply(reducedPoint, reducedAlpha);</span>
<span class="fc" id="L1599">            buffer = reducedAlpha.getBuffer();</span>

            // copy reducedAlpha into the former components of i-th row of alphas
<span class="fc" id="L1602">            alphas.setSubmatrix(i, 0, i, numControlMinusTwo, buffer);</span>

            // The last component of each alpha for each point is computed so
            // that their sum is equal to one
<span class="fc bfc" id="L1606" title="All 2 branches covered.">            if (numControl == GENERAL_NUM_CONTROL_POINTS) {</span>
                // general configuration
<span class="fc" id="L1608">                alphas.setElementAt(i, numDimensions, 1.0 - buffer[0] - buffer[1] - buffer[2]);</span>
            } else {
                // planar configuration
<span class="fc" id="L1611">                alphas.setElementAt(i, numDimensions, 1.0 - buffer[0] - buffer[1]);</span>
            }
        }
<span class="fc" id="L1614">    }</span>


    /**
     * Computes control points in world coordinates and determines whether
     * they are located in a planar configuration or not.
     * This method computes the centroid of provided 3D points and their
     * covariance.
     * Uses PCA by means of SVD decomposition of their covariance matrix in
     * order to find the principal directions of the cloud formed by the
     * collection of points and sets control points as the computed centroid
     * and points along the principal axes so that they form a basis that
     * can be used to express any 3D points into.
     * If the smallest singular value is close to zero in comparison to the
     * largest one, then it is assumed that 3D points are in a planar
     * configuration.
     * If a planar configuration is allowed, then only 3 control points are
     * computed along the plane using the centroid and two points on the
     * principal directions of such plane.
     * Otherwise, in general configuration, 4 control points are computed as
     * the centroid and 3 points along the principal axes of the cloud of 3D
     * points.
     *
     * @throws AlgebraException if something fails because of numerical
     *                          instabilities.
     */
    private void computeWorldControlPointsAndPointConfiguration() throws AlgebraException {
<span class="fc" id="L1641">        final var centroid = Point3D.centroid(points3D);</span>

        // covariance matrix elements, summed up here for speed
<span class="fc" id="L1644">        var c11 = 0.0;</span>
<span class="fc" id="L1645">        var c12 = 0.0;</span>
<span class="fc" id="L1646">        var c13 = 0.0;</span>
<span class="fc" id="L1647">        var c22 = 0.0;</span>
<span class="fc" id="L1648">        var c23 = 0.0;</span>
<span class="fc" id="L1649">        var c33 = 0.0;</span>
        double dx;
        double dy;
        double dz;
<span class="fc" id="L1653">        final var n = points3D.size();</span>
<span class="fc bfc" id="L1654" title="All 2 branches covered.">        for (final var point : points3D) {</span>
<span class="fc" id="L1655">            dx = point.getInhomX() - centroid.getInhomX();</span>
<span class="fc" id="L1656">            dy = point.getInhomY() - centroid.getInhomY();</span>
<span class="fc" id="L1657">            dz = point.getInhomZ() - centroid.getInhomZ();</span>

<span class="fc" id="L1659">            c11 += dx * dx;</span>
<span class="fc" id="L1660">            c12 += dx * dy;</span>
<span class="fc" id="L1661">            c13 += dx * dz;</span>

<span class="fc" id="L1663">            c22 += dy * dy;</span>
<span class="fc" id="L1664">            c23 += dy * dz;</span>

<span class="fc" id="L1666">            c33 += dz * dz;</span>
<span class="fc" id="L1667">        }</span>
<span class="fc" id="L1668">        c11 /= n;</span>
<span class="fc" id="L1669">        c12 /= n;</span>
<span class="fc" id="L1670">        c13 /= n;</span>
<span class="fc" id="L1671">        c22 /= n;</span>
<span class="fc" id="L1672">        c23 /= n;</span>
<span class="fc" id="L1673">        c33 /= n;</span>

<span class="fc" id="L1675">        final var covar = new Matrix(3, 3);</span>
<span class="fc" id="L1676">        covar.setElementAt(0, 0, c11);</span>
<span class="fc" id="L1677">        covar.setElementAt(1, 0, c12);</span>
<span class="fc" id="L1678">        covar.setElementAt(2, 0, c13);</span>

<span class="fc" id="L1680">        covar.setElementAt(0, 1, c12);</span>
<span class="fc" id="L1681">        covar.setElementAt(1, 1, c22);</span>
<span class="fc" id="L1682">        covar.setElementAt(2, 1, c23);</span>

<span class="fc" id="L1684">        covar.setElementAt(0, 2, c13);</span>
<span class="fc" id="L1685">        covar.setElementAt(1, 2, c23);</span>
<span class="fc" id="L1686">        covar.setElementAt(2, 2, c33);</span>

<span class="fc" id="L1688">        final var decomposer = new SingularValueDecomposer(covar);</span>
<span class="fc" id="L1689">        decomposer.decompose();</span>

<span class="fc" id="L1691">        final var singularValues = decomposer.getSingularValues();</span>
<span class="fc" id="L1692">        final var v = decomposer.getV();</span>

        // planar check
        int numControl;
<span class="pc bpc" id="L1696" title="1 of 2 branches missed.">        if (!planarConfigurationAllowed</span>
<span class="fc bfc" id="L1697" title="All 2 branches covered.">                || Math.abs(singularValues[0]) &lt; Math.abs(singularValues[2]) * planarThreshold) {</span>
            // general configuration
<span class="fc" id="L1699">            numControl = GENERAL_NUM_CONTROL_POINTS;</span>
<span class="fc" id="L1700">            isPlanar = false;</span>
        } else {
            // planar configuration (only if allowed)
<span class="fc" id="L1703">            numControl = PLANAR_NUM_CONTROL_POINTS;</span>
<span class="fc" id="L1704">            isPlanar = true;</span>
        }

<span class="fc" id="L1707">        controlWorldPoints = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L1709">        final var centroidX = centroid.getInhomX();</span>
<span class="fc" id="L1710">        final var centroidY = centroid.getInhomY();</span>
<span class="fc" id="L1711">        final var centroidZ = centroid.getInhomZ();</span>

<span class="fc" id="L1713">        final var numDimensions = numControl - 1;</span>
<span class="fc" id="L1714">        final var k = Math.sqrt(singularValues[0] / n);</span>
        double vx;
        double vy;
        double vz;
<span class="fc bfc" id="L1718" title="All 2 branches covered.">        for (var i = 0; i &lt; numDimensions; i++) {</span>
<span class="fc" id="L1719">            vx = v.getElementAt(0, i) * k;</span>
<span class="fc" id="L1720">            vy = v.getElementAt(1, i) * k;</span>
<span class="fc" id="L1721">            vz = v.getElementAt(2, i) * k;</span>

<span class="fc" id="L1723">            controlWorldPoints.add(new InhomogeneousPoint3D(centroidX + vx, centroidY + vy, centroidZ + vz));</span>
        }

        // add centroid (it will be used for the metric transformation
        // estimation)
<span class="fc" id="L1728">        controlWorldPoints.add(centroid);</span>
<span class="fc" id="L1729">    }</span>

    /**
     * A possible solution.
     */
    private static class Solution {
        /**
         * Control points in camera coordinates.
         */
        List&lt;Point3D&gt; controlCameraPoints;

        /**
         * Transformation from world to camera coordinates.
         * Point projection is expressed by x = P * Xw, where P is a pinhole
         * camera and Xw is a point in world coordinates.
         * Points in camera coordinates are expressed as:
         * Xc = Tw-&amp;lt;c * Xw, where Tw-&amp;lt;c is the transformation from world to
         * camera.
         * The Euclidean transformation Tw-&amp;lt;c is expressed as:
         * Tw-&amp;lt;c = [R  t]
         * [0' 1]
         * Projection of a point in camera coordinates can also be expressed
         * as x = Pc * Xc = K * [I 0] * Xc
         * where Pc is a camera and has the form Pc = K *[I 0], so that
         * x = Pc * Xc = K * [I 0] * Xc = K * [I 0] * Tw-&amp;lt;c * Xw
         * x = K * [I 0] * [R  t] * Xw = K * [I*R + 0, I*t + 0] * Xw =
         * [0' 1]
         * x = K * [R t] * Xw = K * [R - R*C] * Xw = x = P * Xw,
         * where R is a rotation and C is the camera center in world
         * coordinates.
         * Assuming that control points are obtained up to scale, then instead
         * of an Euclidean transformation we will assume that Tw-&amp;lt;c is a metric
         * transformation, hence:
         * Tw-&amp;lt;c = [s*R t2]
         * [0'  1 ]
         * To obtain the previous equation, then point in camera coordinates
         * must be 1/s*Xc so that:
         * x = Pc * 1/s * Xc = K * [I 0] * 1/s * Xc
         * x = K * [I 0] * 1/s * Tw-&amp;lt;c * Xw
         * x = K * [I 0] * 1/s *[s*R t2] * Xw = K * 1/s * [I*s*R + 0, I*t2 + 0]
         * [0'  1 ]
         * x = K * 1 / s * [s*R t2] * Xw = K * [R 1/s*t2] * Xw
         * where t = 1/s*t2 = -R*C and so again
         * x = K * [R t] * Xw
         * and camera center is C = -1/s*R'*t2
         */
        MetricTransformation3D worldToCameraTransformation;

        /**
         * Pinhole camera using provided intrinsic parameters and estimated
         * transformation for this solution.
         */
        PinholeCamera camera;

        /**
         * Re-projection error.
         */
        double reprojectionError;
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>