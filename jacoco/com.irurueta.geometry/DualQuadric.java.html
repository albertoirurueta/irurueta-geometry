<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DualQuadric.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-geometry</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.geometry</a> &gt; <span class="el_source">DualQuadric.java</span></div><h1>DualQuadric.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2012 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.geometry;

import com.irurueta.algebra.AlgebraException;
import com.irurueta.algebra.Matrix;
import com.irurueta.algebra.SingularValueDecomposer;
import com.irurueta.algebra.WrongSizeException;

import java.io.Serializable;

/**
 * This class contains implementation of a dual quadric.
 */
@SuppressWarnings(&quot;DuplicatedCode&quot;)
public class DualQuadric extends BaseQuadric implements Serializable {

    /**
     * Constructor.
     */
    public DualQuadric() {
<span class="fc" id="L35">        super();</span>
<span class="fc" id="L36">    }</span>

    /**
     * Constructor of this class. This constructor accepts every parameter
     * describing a dual quadric (parameters a, b, c, d, e, f, g, h, i, j).
     *
     * @param a Parameter A of the quadric.
     * @param b Parameter B of the quadric.
     * @param c Parameter C of the quadric.
     * @param d Parameter D of the quadric.
     * @param e Parameter E of the quadric.
     * @param f Parameter F of the quadric.
     * @param g Parameter G of the quadric.
     * @param h Parameter H of the quadric.
     * @param i Parameter I of the quadric.
     * @param j Parameter J of the quadric.
     */
    public DualQuadric(
            final double a, final double b, final double c, final double d, final double e, final double f,
            final double g, final double h, final double i, final double j) {
<span class="fc" id="L56">        super(a, b, c, d, e, f, g, h, i, j);</span>
<span class="fc" id="L57">    }</span>

    /**
     * This method sets the matrix used to describe a dual quadric.
     * This matrix must be 4x4 and symmetric.
     *
     * @param m 4x4 Matrix describing the quadric.
     * @throws IllegalArgumentException    Raised when the size of the matrix is
     *                                     not 4x4.
     * @throws NonSymmetricMatrixException Raised when the quadric matrix is not
     *                                     symmetric.
     */
    public DualQuadric(final Matrix m) throws NonSymmetricMatrixException {
<span class="fc" id="L70">        super(m);</span>
<span class="fc" id="L71">    }</span>

    /**
     * Creates a dual matrix where provided planes are its locus, or in other
     * words, provided planes are tangent to the quadric corresponding to the
     * created dual quadric.
     *
     * @param plane1 1st plane.
     * @param plane2 2nd plane.
     * @param plane3 3rd plane.
     * @param plane4 4th plane.
     * @param plane5 5th plane.
     * @param plane6 6th plane.
     * @param plane7 7th plane.
     * @param plane8 8th plane.
     * @param plane9 9th plane.
     * @throws CoincidentPlanesException if provided planes are in a
     *                                   configuration where more than one plane is coincident, creating a
     *                                   degeneracy.
     */
    public DualQuadric(
            final Plane plane1, final Plane plane2, final Plane plane3, final Plane plane4, final Plane plane5,
            final Plane plane6, final Plane plane7, final Plane plane8, final Plane plane9)
<span class="fc" id="L94">            throws CoincidentPlanesException {</span>
<span class="fc" id="L95">        setParametersFromPlanes(plane1, plane2, plane3, plane4, plane5, plane6, plane7, plane8, plane9);</span>
<span class="fc" id="L96">    }</span>

    /**
     * Checks if provided plane is locus of this dual quadric, or in other
     * words, checks whether provided plane lies within this quadric, or whether
     * provided plane is tangent to the quadric corresponding to this dual
     * quadric.
     *
     * @param plane     Plane to be tested.
     * @param threshold Threshold of tolerance to determine whether this plane
     *                  is locus or not. This is needed because of limited machine precision. If
     *                  threshold is not provided, then DEFAULT_LOCUS_THRESHOLD is used instead.
     * @return True if provided plane is locus of this dual quadric, false
     * otherwise.
     * @throws IllegalArgumentException Raised if provided threshold is negative.
     */
    public boolean isLocus(final Plane plane, final double threshold) {
<span class="pc bpc" id="L113" title="1 of 2 branches missed.">        if (threshold &lt; MIN_THRESHOLD) {</span>
<span class="nc" id="L114">            throw new IllegalArgumentException();</span>
        }

        try {
<span class="fc" id="L118">            normalize();</span>
<span class="fc" id="L119">            final var dualQ = asMatrix();</span>
<span class="fc" id="L120">            final var homPlane = new Matrix(Plane.PLANE_NUMBER_PARAMS, 1);</span>
<span class="fc" id="L121">            plane.normalize();</span>
<span class="fc" id="L122">            homPlane.setElementAt(0, 0, plane.getA());</span>
<span class="fc" id="L123">            homPlane.setElementAt(1, 0, plane.getB());</span>
<span class="fc" id="L124">            homPlane.setElementAt(2, 0, plane.getC());</span>
<span class="fc" id="L125">            homPlane.setElementAt(3, 0, plane.getD());</span>
<span class="fc" id="L126">            final var locusMatrix = homPlane.transposeAndReturnNew();</span>
<span class="fc" id="L127">            locusMatrix.multiply(dualQ);</span>
<span class="fc" id="L128">            locusMatrix.multiply(homPlane);</span>

<span class="fc bfc" id="L130" title="All 2 branches covered.">            return Math.abs(locusMatrix.getElementAt(0, 0)) &lt; threshold;</span>
<span class="nc" id="L131">        } catch (final WrongSizeException ignore) {</span>
<span class="nc" id="L132">            return false;</span>
        }
    }

    /**
     * Checks if provided plane is locus of this dual quadric, or in other
     * words, checks whether provided plane lies within this quadric, or whether
     * provided plane is tangent to the quadric corresponding to this dual
     * quadric.
     *
     * @param plane Plane to be tested.
     * @return True if provided plane is locus of this dual quadric, false
     * otherwise.
     * @see #isLocus(Plane, double)
     */
    public boolean isLocus(final Plane plane) {
<span class="fc" id="L148">        return isLocus(plane, DEFAULT_LOCUS_THRESHOLD);</span>
    }

    /**
     * Computes the angle between two planes in radians.
     *
     * @param planeA First plane to be tested.
     * @param planeB Second plane to be tested.
     * @return Angle between the two provided planes in radians. This angle is
     * equal to the angle of their corresponding director vectors in an
     * Euclidean geometry, but it might not be the case for the geometry defined
     * by this dual quadric.
     */
    public double angleBetweenPlanes(final Plane planeA, final Plane planeB) {
        try {
            // retrieve quadric as matrix
<span class="fc" id="L164">            normalize();</span>
<span class="fc" id="L165">            final var dualQ = asMatrix();</span>
<span class="fc" id="L166">            final var transHomPlaneA = new Matrix(1, Plane.PLANE_NUMBER_PARAMS);</span>
<span class="fc" id="L167">            planeA.normalize();</span>
<span class="fc" id="L168">            transHomPlaneA.setElementAt(0, 0, planeA.getA());</span>
<span class="fc" id="L169">            transHomPlaneA.setElementAt(0, 1, planeA.getB());</span>
<span class="fc" id="L170">            transHomPlaneA.setElementAt(0, 2, planeA.getC());</span>
<span class="fc" id="L171">            transHomPlaneA.setElementAt(0, 3, planeA.getD());</span>

<span class="fc" id="L173">            final var tmp = transHomPlaneA.multiplyAndReturnNew(dualQ);</span>
<span class="fc" id="L174">            tmp.multiply(transHomPlaneA.transposeAndReturnNew()); //This is</span>
            // homPlaneA' * dualQ * homPlaneA

<span class="fc" id="L177">            final var normA = tmp.getElementAt(0, 0);</span>

<span class="fc" id="L179">            final var homPlaneB = new Matrix(Plane.PLANE_NUMBER_PARAMS, 1);</span>
<span class="fc" id="L180">            planeB.normalize();</span>
<span class="fc" id="L181">            homPlaneB.setElementAt(0, 0, planeB.getA());</span>
<span class="fc" id="L182">            homPlaneB.setElementAt(1, 0, planeB.getB());</span>
<span class="fc" id="L183">            homPlaneB.setElementAt(2, 0, planeB.getC());</span>
<span class="fc" id="L184">            homPlaneB.setElementAt(3, 0, planeB.getD());</span>

<span class="fc" id="L186">            homPlaneB.transpose(tmp);</span>
<span class="fc" id="L187">            tmp.multiply(dualQ);</span>
<span class="fc" id="L188">            tmp.multiply(homPlaneB);</span>

<span class="fc" id="L190">            final var normB = tmp.getElementAt(0, 0);</span>

<span class="fc" id="L192">            transHomPlaneA.multiply(dualQ);</span>
<span class="fc" id="L193">            transHomPlaneA.multiply(homPlaneB);</span>
            // This is homPlaneA' * dualQ * homPlaneB

<span class="fc" id="L196">            final var angleNumerator = transHomPlaneA.getElementAt(0, 0);</span>

<span class="fc" id="L198">            final var cosTheta = angleNumerator / Math.sqrt(normA * normB);</span>
<span class="fc" id="L199">            return Math.acos(cosTheta);</span>
<span class="nc" id="L200">        } catch (final WrongSizeException ignore) {</span>
            // This will never happen
<span class="nc" id="L202">            return 0.0;</span>
        }
    }

    /**
     * Checks if two planes are perpendicular attending to the geometry defined
     * by this dual quadric, or in other words, if lA' * dualQ * lB is zero.
     *
     * @param planeA    First plane to be checked.
     * @param planeB    Second plane to be checked.
     * @param threshold Threshold of tolerance to determine whether the planes
     *                  are perpendicular or not. This is needed because of limited machine
     *                  precision. If threshold is not provided, then
     *                  DEFAULT_PERPENDICULAR_THRESHOLD is used instead.
     * @return True if provided planes are perpendicular, false otherwise.
     * @throws IllegalArgumentException Raised if provided threshold is
     *                                  negative.
     */
    public boolean arePerpendicularPlanes(final Plane planeA, final Plane planeB, final double threshold) {
        try {
            // retrieve quadric as matrix
<span class="fc" id="L223">            final var transHomPlaneA = new Matrix(1, Plane.PLANE_NUMBER_PARAMS);</span>
<span class="fc" id="L224">            planeA.normalize();</span>
<span class="fc" id="L225">            transHomPlaneA.setElementAt(0, 0, planeA.getA());</span>
<span class="fc" id="L226">            transHomPlaneA.setElementAt(0, 1, planeA.getB());</span>
<span class="fc" id="L227">            transHomPlaneA.setElementAt(0, 2, planeA.getC());</span>
<span class="fc" id="L228">            transHomPlaneA.setElementAt(0, 3, planeA.getD());</span>

<span class="fc" id="L230">            final var homPlaneB = new Matrix(Point3D.POINT3D_HOMOGENEOUS_COORDINATES_LENGTH, 1);</span>
<span class="fc" id="L231">            planeB.normalize();</span>
<span class="fc" id="L232">            homPlaneB.setElementAt(0, 0, planeB.getA());</span>
<span class="fc" id="L233">            homPlaneB.setElementAt(1, 0, planeB.getB());</span>
<span class="fc" id="L234">            homPlaneB.setElementAt(2, 0, planeB.getC());</span>
<span class="fc" id="L235">            homPlaneB.setElementAt(3, 0, planeB.getD());</span>

<span class="fc" id="L237">            normalize();</span>
<span class="fc" id="L238">            final var dualQ = asMatrix();</span>
<span class="fc" id="L239">            transHomPlaneA.multiply(dualQ);</span>
<span class="fc" id="L240">            transHomPlaneA.multiply(homPlaneB);</span>
            // This is homPlaneA' * dualQ * homPlaneB

<span class="fc" id="L243">            final var perpend = transHomPlaneA.getElementAt(0, 0);</span>

<span class="fc bfc" id="L245" title="All 2 branches covered.">            return Math.abs(perpend) &lt; threshold;</span>
<span class="nc" id="L246">        } catch (final WrongSizeException ignore) {</span>
            // This will never happen
<span class="nc" id="L248">            return false;</span>
        }
    }

    /**
     * Checks if two planes are perpendicular attending to the geometry defined
     * by this dual quadric, or in other words, if lA' * dualQ * lB is zero.
     *
     * @param planeA First plane to be checked.
     * @param planeB Second plane to be checked.
     * @return True if provided planes are perpendicular, false otherwise.
     */
    public boolean arePerpendicularPlanes(final Plane planeA, final Plane planeB) {
<span class="fc" id="L261">        return arePerpendicularPlanes(planeA, planeB, DEFAULT_PERPENDICULAR_THRESHOLD);</span>
    }

    /**
     * Computes the quadric corresponding to this dual quadric.
     *
     * @return A new quadric instance of this dual quadric.
     * @throws QuadricNotAvailableException Raised if the rank of the dual
     *                                      quadric matrix is not complete due to wrong parameters or numerical
     *                                      instability.
     */
    public Quadric getQuadric() throws QuadricNotAvailableException {
<span class="fc" id="L273">        final var q = new Quadric();</span>
<span class="fc" id="L274">        quadric(q);</span>
<span class="fc" id="L275">        return q;</span>
    }

    /**
     * Computes the quadric corresponding to this dual quadric and stores the
     * result in provided instance.
     *
     * @param quadric Quadric where result is stored.
     * @throws QuadricNotAvailableException Raised if the rank of the dual
     *                                      quadric matrix is not complete due to wrong parameters or numerical
     *                                      instability.
     */
    public void quadric(final Quadric quadric) throws QuadricNotAvailableException {
<span class="fc" id="L288">        final var dualQuadricMatrix = asMatrix();</span>
        try {
<span class="fc" id="L290">            final var invMatrix = com.irurueta.algebra.Utils.inverse(dualQuadricMatrix);</span>

<span class="fc" id="L292">            final var a = invMatrix.getElementAt(0, 0);</span>
<span class="fc" id="L293">            final var b = invMatrix.getElementAt(1, 1);</span>
<span class="fc" id="L294">            final var c = invMatrix.getElementAt(2, 2);</span>
<span class="fc" id="L295">            final var d = 0.5 * (invMatrix.getElementAt(0, 1) + invMatrix.getElementAt(1, 0));</span>
<span class="fc" id="L296">            final var e = 0.5 * (invMatrix.getElementAt(2, 1) + invMatrix.getElementAt(1, 2));</span>
<span class="fc" id="L297">            final var f = 0.5 * (invMatrix.getElementAt(2, 0) + invMatrix.getElementAt(0, 2));</span>
<span class="fc" id="L298">            final var g = 0.5 * (invMatrix.getElementAt(3, 0) + invMatrix.getElementAt(0, 3));</span>
<span class="fc" id="L299">            final double h = 0.5 * (invMatrix.getElementAt(3, 1)</span>
<span class="fc" id="L300">                    + invMatrix.getElementAt(1, 3));</span>
<span class="fc" id="L301">            final var i = 0.5 * (invMatrix.getElementAt(3, 2) + invMatrix.getElementAt(2, 3));</span>
<span class="fc" id="L302">            final var j = invMatrix.getElementAt(3, 3);</span>
<span class="fc" id="L303">            quadric.setParameters(a, b, c, d, e, f, g, h, i, j);</span>
<span class="nc" id="L304">        } catch (final AlgebraException e) {</span>
<span class="nc" id="L305">            throw new QuadricNotAvailableException(e);</span>
<span class="fc" id="L306">        }</span>
<span class="fc" id="L307">    }</span>

    /**
     * Sets parameters of this dual quadric so that provided planes lie within
     * it (are locus).
     *
     * @param plane1 1st plane.
     * @param plane2 2nd plane.
     * @param plane3 3rd plane.
     * @param plane4 4th plane.
     * @param plane5 5th plane.
     * @param plane6 6th plane.
     * @param plane7 7th plane.
     * @param plane8 8th plane.
     * @param plane9 9th plane.
     * @throws CoincidentPlanesException Raised if planes are coincident or
     *                                   produce a degenerated configuration.
     */
    public final void setParametersFromPlanes(
            final Plane plane1, final Plane plane2, final Plane plane3, final Plane plane4, final Plane plane5,
            final Plane plane6, final Plane plane7, final Plane plane8, final Plane plane9)
            throws CoincidentPlanesException {

        // normalize planes to increase accuracy
<span class="fc" id="L331">        plane1.normalize();</span>
<span class="fc" id="L332">        plane2.normalize();</span>
<span class="fc" id="L333">        plane3.normalize();</span>
<span class="fc" id="L334">        plane4.normalize();</span>
<span class="fc" id="L335">        plane5.normalize();</span>
<span class="fc" id="L336">        plane6.normalize();</span>
<span class="fc" id="L337">        plane7.normalize();</span>
<span class="fc" id="L338">        plane8.normalize();</span>
<span class="fc" id="L339">        plane9.normalize();</span>

        try {
            // each plane belonging to a dual quadric follows equation:
            // p' * Q * p = 0 ==&gt;
            // pA^2 + pB^2 + pC^2 + 2*pA*pB + 2*pA*pC + 2*pB*pC + 2*pA*pD +
            // 2*pB*pD + 2*pC*pD + pD^2 = 0

<span class="fc" id="L347">            final var m = new Matrix(9, 10);</span>
<span class="fc" id="L348">            var pA = plane1.getA();</span>
<span class="fc" id="L349">            var pB = plane1.getB();</span>
<span class="fc" id="L350">            var pC = plane1.getC();</span>
<span class="fc" id="L351">            var pD = plane1.getD();</span>
<span class="fc" id="L352">            m.setElementAt(0, 0, pA * pA);</span>
<span class="fc" id="L353">            m.setElementAt(0, 1, pB * pB);</span>
<span class="fc" id="L354">            m.setElementAt(0, 2, pC * pC);</span>
<span class="fc" id="L355">            m.setElementAt(0, 3, 2.0 * pA * pB);</span>
<span class="fc" id="L356">            m.setElementAt(0, 4, 2.0 * pA * pC);</span>
<span class="fc" id="L357">            m.setElementAt(0, 5, 2.0 * pB * pC);</span>
<span class="fc" id="L358">            m.setElementAt(0, 6, 2.0 * pA * pD);</span>
<span class="fc" id="L359">            m.setElementAt(0, 7, 2.0 * pB * pD);</span>
<span class="fc" id="L360">            m.setElementAt(0, 8, 2.0 * pC * pD);</span>
<span class="fc" id="L361">            m.setElementAt(0, 9, pD * pD);</span>
<span class="fc" id="L362">            pA = plane2.getA();</span>
<span class="fc" id="L363">            pB = plane2.getB();</span>
<span class="fc" id="L364">            pC = plane2.getC();</span>
<span class="fc" id="L365">            pD = plane2.getD();</span>
<span class="fc" id="L366">            m.setElementAt(1, 0, pA * pA);</span>
<span class="fc" id="L367">            m.setElementAt(1, 1, pB * pB);</span>
<span class="fc" id="L368">            m.setElementAt(1, 2, pC * pC);</span>
<span class="fc" id="L369">            m.setElementAt(1, 3, 2.0 * pA * pB);</span>
<span class="fc" id="L370">            m.setElementAt(1, 4, 2.0 * pA * pC);</span>
<span class="fc" id="L371">            m.setElementAt(1, 5, 2.0 * pB * pC);</span>
<span class="fc" id="L372">            m.setElementAt(1, 6, 2.0 * pA * pD);</span>
<span class="fc" id="L373">            m.setElementAt(1, 7, 2.0 * pB * pD);</span>
<span class="fc" id="L374">            m.setElementAt(1, 8, 2.0 * pC * pD);</span>
<span class="fc" id="L375">            m.setElementAt(1, 9, pD * pD);</span>
<span class="fc" id="L376">            pA = plane3.getA();</span>
<span class="fc" id="L377">            pB = plane3.getB();</span>
<span class="fc" id="L378">            pC = plane3.getC();</span>
<span class="fc" id="L379">            pD = plane3.getD();</span>
<span class="fc" id="L380">            m.setElementAt(2, 0, pA * pA);</span>
<span class="fc" id="L381">            m.setElementAt(2, 1, pB * pB);</span>
<span class="fc" id="L382">            m.setElementAt(2, 2, pC * pC);</span>
<span class="fc" id="L383">            m.setElementAt(2, 3, 2.0 * pA * pB);</span>
<span class="fc" id="L384">            m.setElementAt(2, 4, 2.0 * pA * pC);</span>
<span class="fc" id="L385">            m.setElementAt(2, 5, 2.0 * pB * pC);</span>
<span class="fc" id="L386">            m.setElementAt(2, 6, 2.0 * pA * pD);</span>
<span class="fc" id="L387">            m.setElementAt(2, 7, 2.0 * pB * pD);</span>
<span class="fc" id="L388">            m.setElementAt(2, 8, 2.0 * pC * pD);</span>
<span class="fc" id="L389">            m.setElementAt(2, 9, pD * pD);</span>
<span class="fc" id="L390">            pA = plane4.getA();</span>
<span class="fc" id="L391">            pB = plane4.getB();</span>
<span class="fc" id="L392">            pC = plane4.getC();</span>
<span class="fc" id="L393">            pD = plane4.getD();</span>
<span class="fc" id="L394">            m.setElementAt(3, 0, pA * pA);</span>
<span class="fc" id="L395">            m.setElementAt(3, 1, pB * pB);</span>
<span class="fc" id="L396">            m.setElementAt(3, 2, pC * pC);</span>
<span class="fc" id="L397">            m.setElementAt(3, 3, 2.0 * pA * pB);</span>
<span class="fc" id="L398">            m.setElementAt(3, 4, 2.0 * pA * pC);</span>
<span class="fc" id="L399">            m.setElementAt(3, 5, 2.0 * pB * pC);</span>
<span class="fc" id="L400">            m.setElementAt(3, 6, 2.0 * pA * pD);</span>
<span class="fc" id="L401">            m.setElementAt(3, 7, 2.0 * pB * pD);</span>
<span class="fc" id="L402">            m.setElementAt(3, 8, 2.0 * pC * pD);</span>
<span class="fc" id="L403">            m.setElementAt(3, 9, pD * pD);</span>
<span class="fc" id="L404">            pA = plane5.getA();</span>
<span class="fc" id="L405">            pB = plane5.getB();</span>
<span class="fc" id="L406">            pC = plane5.getC();</span>
<span class="fc" id="L407">            pD = plane5.getD();</span>
<span class="fc" id="L408">            m.setElementAt(4, 0, pA * pA);</span>
<span class="fc" id="L409">            m.setElementAt(4, 1, pB * pB);</span>
<span class="fc" id="L410">            m.setElementAt(4, 2, pC * pC);</span>
<span class="fc" id="L411">            m.setElementAt(4, 3, 2.0 * pA * pB);</span>
<span class="fc" id="L412">            m.setElementAt(4, 4, 2.0 * pA * pC);</span>
<span class="fc" id="L413">            m.setElementAt(4, 5, 2.0 * pB * pC);</span>
<span class="fc" id="L414">            m.setElementAt(4, 6, 2.0 * pA * pD);</span>
<span class="fc" id="L415">            m.setElementAt(4, 7, 2.0 * pB * pD);</span>
<span class="fc" id="L416">            m.setElementAt(4, 8, 2.0 * pC * pD);</span>
<span class="fc" id="L417">            m.setElementAt(4, 9, pD * pD);</span>
<span class="fc" id="L418">            pA = plane6.getA();</span>
<span class="fc" id="L419">            pB = plane6.getB();</span>
<span class="fc" id="L420">            pC = plane6.getC();</span>
<span class="fc" id="L421">            pD = plane6.getD();</span>
<span class="fc" id="L422">            m.setElementAt(5, 0, pA * pA);</span>
<span class="fc" id="L423">            m.setElementAt(5, 1, pB * pB);</span>
<span class="fc" id="L424">            m.setElementAt(5, 2, pC * pC);</span>
<span class="fc" id="L425">            m.setElementAt(5, 3, 2.0 * pA * pB);</span>
<span class="fc" id="L426">            m.setElementAt(5, 4, 2.0 * pA * pC);</span>
<span class="fc" id="L427">            m.setElementAt(5, 5, 2.0 * pB * pC);</span>
<span class="fc" id="L428">            m.setElementAt(5, 6, 2.0 * pA * pD);</span>
<span class="fc" id="L429">            m.setElementAt(5, 7, 2.0 * pB * pD);</span>
<span class="fc" id="L430">            m.setElementAt(5, 8, 2.0 * pC * pD);</span>
<span class="fc" id="L431">            m.setElementAt(5, 9, pD * pD);</span>
<span class="fc" id="L432">            pA = plane7.getA();</span>
<span class="fc" id="L433">            pB = plane7.getB();</span>
<span class="fc" id="L434">            pC = plane7.getC();</span>
<span class="fc" id="L435">            pD = plane7.getD();</span>
<span class="fc" id="L436">            m.setElementAt(6, 0, pA * pA);</span>
<span class="fc" id="L437">            m.setElementAt(6, 1, pB * pB);</span>
<span class="fc" id="L438">            m.setElementAt(6, 2, pC * pC);</span>
<span class="fc" id="L439">            m.setElementAt(6, 3, 2.0 * pA * pB);</span>
<span class="fc" id="L440">            m.setElementAt(6, 4, 2.0 * pA * pC);</span>
<span class="fc" id="L441">            m.setElementAt(6, 5, 2.0 * pB * pC);</span>
<span class="fc" id="L442">            m.setElementAt(6, 6, 2.0 * pA * pD);</span>
<span class="fc" id="L443">            m.setElementAt(6, 7, 2.0 * pB * pD);</span>
<span class="fc" id="L444">            m.setElementAt(6, 8, 2.0 * pC * pD);</span>
<span class="fc" id="L445">            m.setElementAt(6, 9, pD * pD);</span>
<span class="fc" id="L446">            pA = plane8.getA();</span>
<span class="fc" id="L447">            pB = plane8.getB();</span>
<span class="fc" id="L448">            pC = plane8.getC();</span>
<span class="fc" id="L449">            pD = plane8.getD();</span>
<span class="fc" id="L450">            m.setElementAt(7, 0, pA * pA);</span>
<span class="fc" id="L451">            m.setElementAt(7, 1, pB * pB);</span>
<span class="fc" id="L452">            m.setElementAt(7, 2, pC * pC);</span>
<span class="fc" id="L453">            m.setElementAt(7, 3, 2.0 * pA * pB);</span>
<span class="fc" id="L454">            m.setElementAt(7, 4, 2.0 * pA * pC);</span>
<span class="fc" id="L455">            m.setElementAt(7, 5, 2.0 * pB * pC);</span>
<span class="fc" id="L456">            m.setElementAt(7, 6, 2.0 * pA * pD);</span>
<span class="fc" id="L457">            m.setElementAt(7, 7, 2.0 * pB * pD);</span>
<span class="fc" id="L458">            m.setElementAt(7, 8, 2.0 * pC * pD);</span>
<span class="fc" id="L459">            m.setElementAt(7, 9, pD * pD);</span>
<span class="fc" id="L460">            pA = plane9.getA();</span>
<span class="fc" id="L461">            pB = plane9.getB();</span>
<span class="fc" id="L462">            pC = plane9.getC();</span>
<span class="fc" id="L463">            pD = plane9.getD();</span>
<span class="fc" id="L464">            m.setElementAt(8, 0, pA * pA);</span>
<span class="fc" id="L465">            m.setElementAt(8, 1, pB * pB);</span>
<span class="fc" id="L466">            m.setElementAt(8, 2, pC * pC);</span>
<span class="fc" id="L467">            m.setElementAt(8, 3, 2.0 * pA * pB);</span>
<span class="fc" id="L468">            m.setElementAt(8, 4, 2.0 * pA * pC);</span>
<span class="fc" id="L469">            m.setElementAt(8, 5, 2.0 * pB * pC);</span>
<span class="fc" id="L470">            m.setElementAt(8, 6, 2.0 * pA * pD);</span>
<span class="fc" id="L471">            m.setElementAt(8, 7, 2.0 * pB * pD);</span>
<span class="fc" id="L472">            m.setElementAt(8, 8, 2.0 * pC * pD);</span>
<span class="fc" id="L473">            m.setElementAt(8, 9, pD * pD);</span>

            // normalize each row to increase accuracy
<span class="fc" id="L476">            final var row = new double[10];</span>
            double rowNorm;
<span class="fc bfc" id="L478" title="All 2 branches covered.">            for (var j = 0; j &lt; 9; j++) {</span>
<span class="fc" id="L479">                m.getSubmatrixAsArray(j, 0, j, 9, row);</span>
<span class="fc" id="L480">                rowNorm = com.irurueta.algebra.Utils.normF(row);</span>
<span class="fc bfc" id="L481" title="All 2 branches covered.">                for (var i = 0; i &lt; 10; i++)</span>
<span class="fc" id="L482">                    m.setElementAt(j, i, m.getElementAt(j, i) / rowNorm);</span>
            }

<span class="fc" id="L485">            final var decomposer = new SingularValueDecomposer(m);</span>
<span class="fc" id="L486">            decomposer.decompose();</span>

<span class="fc bfc" id="L488" title="All 2 branches covered.">            if (decomposer.getRank() &lt; 9) {</span>
<span class="fc" id="L489">                throw new CoincidentPlanesException();</span>
            }

            // the right null-space of m contains the parameters a, b, c, d, e ,f
            // of the conic
<span class="fc" id="L494">            final var v = decomposer.getV();</span>

<span class="fc" id="L496">            final var a = v.getElementAt(0, 9);</span>
<span class="fc" id="L497">            final var b = v.getElementAt(1, 9);</span>
<span class="fc" id="L498">            final var c = v.getElementAt(2, 9);</span>
<span class="fc" id="L499">            final var d = v.getElementAt(3, 9);</span>

<span class="fc" id="L501">            final var f = v.getElementAt(4, 9);</span>
<span class="fc" id="L502">            final var e = v.getElementAt(5, 9);</span>

<span class="fc" id="L504">            final var g = v.getElementAt(6, 9);</span>
<span class="fc" id="L505">            final var h = v.getElementAt(7, 9);</span>
<span class="fc" id="L506">            final var i = v.getElementAt(8, 9);</span>
<span class="fc" id="L507">            final var j = v.getElementAt(9, 9);</span>

<span class="fc" id="L509">            setParameters(a, b, c, d, e, f, g, h, i, j);</span>
<span class="nc" id="L510">        } catch (final AlgebraException ex) {</span>
<span class="nc" id="L511">            throw new CoincidentPlanesException(ex);</span>
<span class="fc" id="L512">        }</span>
<span class="fc" id="L513">    }</span>

    /**
     * Creates a canonical instance of the dual absolute quadric in the metric
     * stratum.
     * In an ideal metric stratum, in order to preserve orthogonality, the dual
     * absolute quadric is defined as a degenerate dual quadric (i.e. cannot be
     * inverted to obtain a quadric) containing the canonical dual absolute
     * conic (i.e. the identity) in its top left sub-matrix
     *
     * @return a canonical instance of the dual absolute quadric
     */
    public static DualQuadric createCanonicalDualAbsoluteQuadric() {
<span class="fc" id="L526">        return new DualQuadric(1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>