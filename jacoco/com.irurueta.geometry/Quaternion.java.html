<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Quaternion.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-geometry</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.geometry</a> &gt; <span class="el_source">Quaternion.java</span></div><h1>Quaternion.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2015 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.geometry;

import com.irurueta.algebra.ArrayUtils;
import com.irurueta.algebra.Matrix;
import com.irurueta.algebra.WrongSizeException;

import java.io.Serializable;
import java.util.Arrays;

/**
 * Contains a representation of a 3D rotation in a more precise and compact way
 * than in matrix notation.
 * This implementation of a quaternion contains values in the basis 1, i, j, k
 * expressed as (a, b, c, d).
 * a value is related only to the rotation angle, while b, c, d values are related
 * both to the rotation axis and the rotation angle.
 */
@SuppressWarnings(&quot;DuplicatedCode&quot;)
public class Quaternion extends Rotation3D implements Serializable, Cloneable {

    /**
     * Number of parameters contained in a quaternion.
     */
    public static final int N_PARAMS = 4;

    /**
     * Number of euler angles.
     */
    public static final int N_ANGLES = 3;

    /**
     * Threshold of axis norm to convert quaternions to axis and rotation angle.
     */
    public static final double AXIS_NORM_THRESHOLD = 1e-7;

    /**
     * Large threshold of axis norm to convert quaternions to axis and rotation
     * angle.
     */
    public static final double LARGE_AXIS_NORM_THRESHOLD = 1e-6;

    /**
     * Trace threshold to convert rotation matrices into quaternions.
     */
    public static final double TRACE_THRESHOLD = 1e-8;

    /**
     * Value corresponding to real numbers basis.
     */
    private double a;

    /**
     * Value corresponding to basis i.
     */
    private double b;

    /**
     * Value corresponding to basis j.
     */
    private double c;

    /**
     * Value corresponding to basis k.
     */
    private double d;

    /**
     * Indicates whether quaternion is normalized or not.
     */
    private boolean normalized;

    /**
     * Default constructor.
     * Creates a quaternion containing no rotation.
     */
<span class="fc" id="L91">    public Quaternion() {</span>
<span class="fc" id="L92">        a = 1.0;</span>
<span class="fc" id="L93">    }</span>

    /**
     * Constructor.
     *
     * @param a value corresponding to real numbers basis.
     * @param b value corresponding to basis i.
     * @param c value corresponding to basis j.
     * @param d value corresponding to basis k.
     */
<span class="fc" id="L103">    public Quaternion(final double a, final double b, final double c, final double d) {</span>
<span class="fc" id="L104">        this.a = a;</span>
<span class="fc" id="L105">        this.b = b;</span>
<span class="fc" id="L106">        this.c = c;</span>
<span class="fc" id="L107">        this.d = d;</span>
<span class="fc" id="L108">    }</span>

    /**
     * Constructor.
     *
     * @param quaternion quaternion to be copied from.
     */
<span class="fc" id="L115">    public Quaternion(final Quaternion quaternion) {</span>
<span class="fc" id="L116">        fromQuaternion(quaternion);</span>
<span class="fc" id="L117">    }</span>

    /**
     * Constructor.
     *
     * @param values values to be stored in the quaternion expressed in the
     *               basis (1, i, j, k)
     * @throws IllegalArgumentException if provided array does not have length
     *                                  4.
     */
<span class="fc" id="L127">    public Quaternion(final double[] values) {</span>
<span class="fc" id="L128">        setValues(values);</span>
<span class="fc" id="L129">    }</span>

    /**
     * Constructor.
     *
     * @param axis  a rotation axis.
     * @param theta a rotation angle expressed in radians.
     * @throws IllegalArgumentException if provided axis array does not have
     *                                  length 3.
     */
<span class="fc" id="L139">    public Quaternion(final double[] axis, final double theta) {</span>
<span class="fc" id="L140">        setFromAxisAndRotation(axis, theta);</span>
<span class="fc" id="L141">    }</span>

    /**
     * Constructor from and axis 3D rotation.
     *
     * @param axisRotation an axis 3D rotation.
     */
<span class="fc" id="L148">    public Quaternion(final AxisRotation3D axisRotation) {</span>
<span class="fc" id="L149">        setFromAxisAndRotation(axisRotation);</span>
<span class="fc" id="L150">    }</span>

    /**
     * Constructor from euler angles.
     *
     * @param roll  roll angle expressed in radians.
     * @param pitch pitch angle expressed in radians.
     * @param yaw   yaw angle expressed in radians.
     */
<span class="fc" id="L159">    public Quaternion(final double roll, final double pitch, final double yaw) {</span>
<span class="fc" id="L160">        setFromEulerAngles(roll, pitch, yaw);</span>
<span class="fc" id="L161">    }</span>

    /**
     * Constructor from matrix rotation.
     *
     * @param matrixRotation matrix rotation.
     */
<span class="fc" id="L168">    public Quaternion(final MatrixRotation3D matrixRotation) {</span>
<span class="fc" id="L169">        setFromMatrixRotation(matrixRotation);</span>
<span class="fc" id="L170">    }</span>

    /**
     * Gets value corresponding to real numbers basis.
     *
     * @return value corresponding to real numbers basis.
     */
    public double getA() {
<span class="fc" id="L178">        return a;</span>
    }

    /**
     * Sets value corresponding to real numbers basis.
     *
     * @param a value corresponding to real numbers basis.
     */
    public void setA(final double a) {
<span class="fc" id="L187">        this.a = a;</span>
<span class="fc" id="L188">        normalized = false;</span>
<span class="fc" id="L189">    }</span>

    /**
     * Gets value corresponding to basis i.
     *
     * @return value corresponding to basis i.
     */
    public double getB() {
<span class="fc" id="L197">        return b;</span>
    }

    /**
     * Sets value corresponding to basis i.
     *
     * @param b value corresponding to basis i.
     */
    public void setB(final double b) {
<span class="fc" id="L206">        this.b = b;</span>
<span class="fc" id="L207">        normalized = false;</span>
<span class="fc" id="L208">    }</span>

    /**
     * Gets value corresponding to basis j.
     *
     * @return value corresponding to basis j.
     */
    public double getC() {
<span class="fc" id="L216">        return c;</span>
    }

    /**
     * Sets value corresponding to basis j.
     *
     * @param c value corresponding to basis j.
     */
    public void setC(final double c) {
<span class="fc" id="L225">        this.c = c;</span>
<span class="fc" id="L226">        normalized = false;</span>
<span class="fc" id="L227">    }</span>

    /**
     * Gets value corresponding to basis k.
     *
     * @return value corresponding to basis k.
     */
    public double getD() {
<span class="fc" id="L235">        return d;</span>
    }

    /**
     * Sets value corresponding to basis k.
     *
     * @param d value corresponding to basis k.
     */
    public void setD(final double d) {
<span class="fc" id="L244">        this.d = d;</span>
<span class="fc" id="L245">        normalized = false;</span>
<span class="fc" id="L246">    }</span>

    /**
     * Gets values that parameterize this quaternion.
     *
     * @return values of this quaternion.
     */
    public double[] getValues() {
<span class="fc" id="L254">        final var result = new double[N_PARAMS];</span>
<span class="fc" id="L255">        values(result);</span>
<span class="fc" id="L256">        return result;</span>
    }

    /**
     * Stores values that parameterize this quaternion into provided array.
     *
     * @param result array where quaternion parameters will be stored.
     * @throws IllegalArgumentException if length of provided array is not 4.
     */
    public void values(final double[] result) {
<span class="pc bpc" id="L266" title="1 of 2 branches missed.">        if (result.length != N_PARAMS) {</span>
<span class="nc" id="L267">            throw new IllegalArgumentException(&quot;result length must be 4&quot;);</span>
        }

<span class="fc" id="L270">        result[0] = a;</span>
<span class="fc" id="L271">        result[1] = b;</span>
<span class="fc" id="L272">        result[2] = c;</span>
<span class="fc" id="L273">        result[3] = d;</span>
<span class="fc" id="L274">    }</span>

    /**
     * Sets values that parameterize this quaternion in basis (1, i, j ,k).
     *
     * @param values values that parameterize this quaternion in basis (1, i, j,
     *               k).
     * @throws IllegalArgumentException if provided array length is not 4.
     */
    public final void setValues(final double[] values) {
<span class="fc bfc" id="L284" title="All 2 branches covered.">        if (values.length != N_PARAMS) {</span>
<span class="fc" id="L285">            throw new IllegalArgumentException(&quot;values length must be 4&quot;);</span>
        }

<span class="fc" id="L288">        a = values[0];</span>
<span class="fc" id="L289">        b = values[1];</span>
<span class="fc" id="L290">        c = values[2];</span>
<span class="fc" id="L291">        d = values[3];</span>
<span class="fc" id="L292">        normalized = false;</span>
<span class="fc" id="L293">    }</span>

    /**
     * Copies values from provided quaternion into this instance.
     *
     * @param quaternion quaternion to copy from.
     */
    public final void fromQuaternion(final Quaternion quaternion) {
<span class="fc" id="L301">        a = quaternion.a;</span>
<span class="fc" id="L302">        b = quaternion.b;</span>
<span class="fc" id="L303">        c = quaternion.c;</span>
<span class="fc" id="L304">        d = quaternion.d;</span>
<span class="fc" id="L305">        normalized = quaternion.normalized;</span>
<span class="fc" id="L306">    }</span>

    /**
     * Returns a new quaternion instance containing the same data as this
     * instance.
     *
     * @return a copy of this quaternion instance.
     * @throws CloneNotSupportedException if clone fails.
     */
    @Override
    public Quaternion clone() throws CloneNotSupportedException {
<span class="fc" id="L317">        final var result = (Quaternion) super.clone();</span>
<span class="fc" id="L318">        copyTo(result);</span>
<span class="fc" id="L319">        return result;</span>
    }

    /**
     * Copies this instance data into provided quaternion instance.
     *
     * @param output destination instance where data is copied to.
     */
    public void copyTo(final Quaternion output) {
<span class="fc" id="L328">        output.a = a;</span>
<span class="fc" id="L329">        output.b = b;</span>
<span class="fc" id="L330">        output.c = c;</span>
<span class="fc" id="L331">        output.d = d;</span>
<span class="fc" id="L332">        output.normalized = normalized;</span>
<span class="fc" id="L333">    }</span>

    /**
     * Sets quaternion parameters from axis and rotation values.
     *
     * @param axisX x coordinate of rotation axis.
     * @param axisY y coordinate of rotation axis.
     * @param axisZ z coordinate of rotation axis.
     * @param theta rotation angle expressed in radians.
     */
    public final void setFromAxisAndRotation(
            final double axisX, final double axisY, final double axisZ, final double theta) {
<span class="fc" id="L345">        setFromAxisAndRotation(axisX, axisY, axisZ, theta, null, null);</span>
<span class="fc" id="L346">    }</span>

    /**
     * Sets quaternion parameters from axis and rotation values.
     *
     * @param axisX           x coordinate of rotation axis.
     * @param axisY           y coordinate of rotation axis.
     * @param axisZ           z coordinate of rotation axis.
     * @param theta           rotation angle expressed in radians.
     * @param jacobianOfTheta if provided, matrix where jacobian of rotation
     *                        angle will be stored. Must be a 4x1 matrix.
     * @param jacobianOfAxis  if provided, matrix where jacobian of rotation axis
     *                        will be stored. Must be a 4x3 matrix.
     * @throws IllegalArgumentException if any of the provided jacobian matrices
     *                                  does not have proper size.
     * @see &lt;a href=&quot;https://github.com/joansola/slamtb&quot;&gt;au2q.m at https://github.com/joansola/slamtb&lt;/a&gt;
     */
    public void setFromAxisAndRotation(
            final double axisX, final double axisY, final double axisZ, final double theta,
            final Matrix jacobianOfTheta, final Matrix jacobianOfAxis) {

        // validations
<span class="pc bpc" id="L368" title="1 of 6 branches missed.">        if (jacobianOfTheta != null &amp;&amp; (jacobianOfTheta.getRows() != N_PARAMS || jacobianOfTheta.getColumns() != 1)) {</span>
<span class="fc" id="L369">            throw new IllegalArgumentException(&quot;jacobian of theta must be 4x1&quot;);</span>
        }

<span class="fc bfc" id="L372" title="All 4 branches covered.">        if (jacobianOfAxis != null &amp;&amp; (jacobianOfAxis.getRows() != N_PARAMS</span>
<span class="pc bpc" id="L373" title="1 of 2 branches missed.">                || jacobianOfAxis.getColumns() != N_ANGLES)) {</span>
<span class="fc" id="L374">            throw new IllegalArgumentException(&quot;jacobian of axis must be 4x3&quot;);</span>
        }


<span class="fc" id="L378">        final var halfTheta = theta / 2.0;</span>
<span class="fc" id="L379">        final var cosine = Math.cos(halfTheta);</span>
<span class="fc" id="L380">        final var sine = Math.sin(halfTheta);</span>

<span class="fc" id="L382">        a = cosine;</span>

<span class="fc" id="L384">        b = axisX * sine;</span>
<span class="fc" id="L385">        this.c = axisY * sine;</span>
<span class="fc" id="L386">        d = axisZ * sine;</span>
<span class="fc" id="L387">        normalized = false;</span>

<span class="fc bfc" id="L389" title="All 2 branches covered.">        if (jacobianOfTheta != null) {</span>
<span class="fc" id="L390">            final var halfC = cosine / 2.0;</span>
<span class="fc" id="L391">            final var halfS = sine / 2.0;</span>

<span class="fc" id="L393">            jacobianOfTheta.getBuffer()[0] = -halfS;</span>
<span class="fc" id="L394">            jacobianOfTheta.getBuffer()[1] = axisX * halfC;</span>
<span class="fc" id="L395">            jacobianOfTheta.getBuffer()[2] = axisY * halfC;</span>
<span class="fc" id="L396">            jacobianOfTheta.getBuffer()[3] = axisZ * halfC;</span>
        }

<span class="fc bfc" id="L399" title="All 2 branches covered.">        if (jacobianOfAxis != null) {</span>
<span class="fc" id="L400">            jacobianOfAxis.initialize(0.0);</span>
<span class="fc" id="L401">            jacobianOfAxis.setElementAt(1, 0, sine);</span>
<span class="fc" id="L402">            jacobianOfAxis.setElementAt(2, 1, sine);</span>
<span class="fc" id="L403">            jacobianOfAxis.setElementAt(3, 2, sine);</span>
        }
<span class="fc" id="L405">    }</span>

    /**
     * Sets quaternion parameters from axis and rotation values.
     *
     * @param axis  axis values.
     * @param theta rotation angle expressed in radians.
     * @throws IllegalArgumentException if provided axis array does not have
     *                                  length 3.
     */
    public final void setFromAxisAndRotation(final double[] axis, final double theta) {
<span class="fc" id="L416">        setFromAxisAndRotation(axis, theta, null, null);</span>
<span class="fc" id="L417">    }</span>

    /**
     * Sets quaternion parameters from axis and rotation values.
     *
     * @param axis            axis values.
     * @param theta           rotation angle expressed in radians.
     * @param jacobianOfTheta if provided, matrix where jacobian of rotation
     *                        angle will be stored. Must be a 4x1 matrix.
     * @param jacobianOfAxis  if provided, matrix where jacobian of rotation axis
     *                        will be stored. Must be a 4x4 matrix.
     * @throws IllegalArgumentException if provided axis array does not have
     *                                  length 3, or if any of the provided jacobian matrices
     *                                  does not have proper size.
     */
    public void setFromAxisAndRotation(
            final double[] axis, final double theta, final Matrix jacobianOfTheta, final Matrix jacobianOfAxis) {
<span class="fc bfc" id="L434" title="All 2 branches covered.">        if (axis.length != AxisRotation3D.AXIS_PARAMS) {</span>
<span class="fc" id="L435">            throw new IllegalArgumentException(&quot;axis length must be 3&quot;);</span>
        }

<span class="fc" id="L438">        setFromAxisAndRotation(axis[0], axis[1], axis[2], theta, jacobianOfTheta, jacobianOfAxis);</span>
<span class="fc" id="L439">    }</span>

    /**
     * Sets quaternion parameters from an axis 3D rotation.
     *
     * @param axisRotation an axis 3D rotation.
     */
    public final void setFromAxisAndRotation(final AxisRotation3D axisRotation) {
<span class="fc" id="L447">        setFromAxisAndRotation(axisRotation, null, null);</span>
<span class="fc" id="L448">    }</span>

    /**
     * Sets quaternion parameters from an axis 3D rotation.
     *
     * @param axisRotation    an axis 3D rotation.
     * @param jacobianOfTheta if provided, matrix where jacobian of rotation
     *                        angle will be stored. Must be a 4x1 matrix.
     * @param jacobianOfAxis  if provided, matrix where jacobian of rotation axis
     *                        will be stored. Must be a 4x4 matrix.
     * @throws IllegalArgumentException if any of the provided jacobian matrices
     *                                  does not have proper size.
     */
    public void setFromAxisAndRotation(
            final AxisRotation3D axisRotation, final Matrix jacobianOfTheta, final Matrix jacobianOfAxis) {

<span class="fc" id="L464">        final var theta = axisRotation.getRotationAngle();</span>

<span class="fc" id="L466">        setFromAxisAndRotation(axisRotation.getAxisX(), axisRotation.getAxisY(), axisRotation.getAxisZ(), theta,</span>
                jacobianOfTheta, jacobianOfAxis);
<span class="fc" id="L468">    }</span>

    /**
     * Multiplies this quaternion with provided one and stores the result in
     * this instance.
     *
     * @param q quaternion to multiply with.
     */
    public void multiply(final Quaternion q) {
<span class="fc" id="L477">        multiply(q, this);</span>
<span class="fc" id="L478">    }</span>

    /**
     * Multiplies this quaternion with provided one and returns the result as a
     * new quaternion instance.
     *
     * @param q quaternion to multiply with.
     * @return obtained result.
     */
    public Quaternion multiplyAndReturnNew(final Quaternion q) {
<span class="fc" id="L488">        final var result = new Quaternion(0.0, 0.0, 0.0, 0.0);</span>
<span class="fc" id="L489">        multiply(q, result);</span>
<span class="fc" id="L490">        return result;</span>
    }

    /**
     * Multiplies this quaternion with provided one and stores the result into
     * provided instance.
     *
     * @param q      quaternion to multiply with.
     * @param result instance where result is stored.
     */
    public void multiply(final Quaternion q, final Quaternion result) {
<span class="fc" id="L501">        product(this, q, result);</span>
<span class="fc" id="L502">    }</span>

    /**
     * Multiplies quaternion q1 with quaternion q2 and stores the result into
     * provided instance.
     *
     * @param q1     1st product operator of quaternions.
     * @param q2     2nd product operator of quaternions.
     * @param result instance where result of product is stored.
     */
    public static void product(final Quaternion q1, final Quaternion q2, final Quaternion result) {
<span class="fc" id="L513">        product(q1, q2, result, null, null);</span>
<span class="fc" id="L514">    }</span>

    /**
     * Multiplies quaternion q1 with quaternion q2 and stores the result into
     * provided instance. This method also computes the Jacobians wrt of Q1 and
     * Q2 if provided.
     *
     * @param q1         1st product operator of quaternions.
     * @param q2         2nd product operator of quaternions.
     * @param result     instance where result of product is stored.
     * @param jacobianQ1 instance where jacobian of q1 is stored.
     * @param jacobianQ2 instance where jacobian of q2 is stored.
     * @throws IllegalArgumentException if any of the provided jacobian matrices
     *                                  is not 4x4.
     * @see &lt;a href=&quot;https://github.com/joansola/slamtb&quot;&gt;qProd.m at https://github.com/joansola/slamtb&lt;/a&gt;
     */
    public static void product(
            final Quaternion q1, final Quaternion q2, final Quaternion result, final Matrix jacobianQ1,
            final Matrix jacobianQ2) {

<span class="fc bfc" id="L534" title="All 4 branches covered.">        if (jacobianQ1 != null &amp;&amp; (jacobianQ1.getRows() != Quaternion.N_PARAMS</span>
<span class="pc bpc" id="L535" title="1 of 2 branches missed.">                || jacobianQ1.getColumns() != Quaternion.N_PARAMS)) {</span>
<span class="fc" id="L536">            throw new IllegalArgumentException(&quot;jacobian of q1 must be 4x4&quot;);</span>
        }
<span class="fc bfc" id="L538" title="All 4 branches covered.">        if (jacobianQ2 != null &amp;&amp; (jacobianQ2.getRows() != Quaternion.N_PARAMS</span>
<span class="pc bpc" id="L539" title="1 of 2 branches missed.">                || jacobianQ2.getColumns() != Quaternion.N_PARAMS)) {</span>
<span class="fc" id="L540">            throw new IllegalArgumentException(&quot;jacobian of q2 must be 4x4&quot;);</span>
        }

<span class="fc" id="L543">        final var q1A = q1.a;</span>
<span class="fc" id="L544">        final var q1B = q1.b;</span>
<span class="fc" id="L545">        final var q1C = q1.c;</span>
<span class="fc" id="L546">        final var q1D = q1.d;</span>
<span class="fc" id="L547">        final var q2A = q2.a;</span>
<span class="fc" id="L548">        final var q2B = q2.b;</span>
<span class="fc" id="L549">        final var q2C = q2.c;</span>
<span class="fc" id="L550">        final var q2D = q2.d;</span>

<span class="fc" id="L552">        result.a = q1A * q2A - q1B * q2B - q1C * q2C - q1D * q2D;</span>
<span class="fc" id="L553">        result.b = q1A * q2B + q1B * q2A + q1C * q2D - q1D * q2C;</span>
<span class="fc" id="L554">        result.c = q1A * q2C - q1B * q2D + q1C * q2A + q1D * q2B;</span>
<span class="fc" id="L555">        result.d = q1A * q2D + q1B * q2C - q1C * q2B + q1D * q2A;</span>
<span class="fc" id="L556">        result.normalized = false;</span>

<span class="fc bfc" id="L558" title="All 2 branches covered.">        if (jacobianQ1 != null) {</span>
<span class="fc" id="L559">            jacobianQ1.setElementAt(0, 0, q2A);</span>
<span class="fc" id="L560">            jacobianQ1.setElementAt(1, 0, q2B);</span>
<span class="fc" id="L561">            jacobianQ1.setElementAt(2, 0, q2C);</span>
<span class="fc" id="L562">            jacobianQ1.setElementAt(3, 0, q2D);</span>

<span class="fc" id="L564">            jacobianQ1.setElementAt(0, 1, -q2B);</span>
<span class="fc" id="L565">            jacobianQ1.setElementAt(1, 1, q2A);</span>
<span class="fc" id="L566">            jacobianQ1.setElementAt(2, 1, -q2D);</span>
<span class="fc" id="L567">            jacobianQ1.setElementAt(3, 1, q2C);</span>

<span class="fc" id="L569">            jacobianQ1.setElementAt(0, 2, -q2C);</span>
<span class="fc" id="L570">            jacobianQ1.setElementAt(1, 2, q2D);</span>
<span class="fc" id="L571">            jacobianQ1.setElementAt(2, 2, q2A);</span>
<span class="fc" id="L572">            jacobianQ1.setElementAt(3, 2, -q2B);</span>

<span class="fc" id="L574">            jacobianQ1.setElementAt(0, 3, -q2D);</span>
<span class="fc" id="L575">            jacobianQ1.setElementAt(1, 3, -q2C);</span>
<span class="fc" id="L576">            jacobianQ1.setElementAt(2, 3, q2B);</span>
<span class="fc" id="L577">            jacobianQ1.setElementAt(3, 3, q2A);</span>
        }

<span class="fc bfc" id="L580" title="All 2 branches covered.">        if (jacobianQ2 != null) {</span>
<span class="fc" id="L581">            jacobianQ2.setElementAt(0, 0, q1A);</span>
<span class="fc" id="L582">            jacobianQ2.setElementAt(1, 0, q1B);</span>
<span class="fc" id="L583">            jacobianQ2.setElementAt(2, 0, q1C);</span>
<span class="fc" id="L584">            jacobianQ2.setElementAt(3, 0, q1D);</span>

<span class="fc" id="L586">            jacobianQ2.setElementAt(0, 1, -q1B);</span>
<span class="fc" id="L587">            jacobianQ2.setElementAt(1, 1, q1A);</span>
<span class="fc" id="L588">            jacobianQ2.setElementAt(2, 1, q1D);</span>
<span class="fc" id="L589">            jacobianQ2.setElementAt(3, 1, -q1C);</span>

<span class="fc" id="L591">            jacobianQ2.setElementAt(0, 2, -q1C);</span>
<span class="fc" id="L592">            jacobianQ2.setElementAt(1, 2, -q1D);</span>
<span class="fc" id="L593">            jacobianQ2.setElementAt(2, 2, q1A);</span>
<span class="fc" id="L594">            jacobianQ2.setElementAt(3, 2, q1B);</span>

<span class="fc" id="L596">            jacobianQ2.setElementAt(0, 3, -q1D);</span>
<span class="fc" id="L597">            jacobianQ2.setElementAt(1, 3, q1C);</span>
<span class="fc" id="L598">            jacobianQ2.setElementAt(2, 3, -q1B);</span>
<span class="fc" id="L599">            jacobianQ2.setElementAt(3, 3, q1A);</span>
        }
<span class="fc" id="L601">    }</span>

    /**
     * Sets quaternion from euler angles (roll, pitch and yaw).
     *
     * @param roll     roll angle expressed in radians. Rotation around x-axis.
     * @param pitch    pitch angle expressed in radians. Rotation around y-axis.
     * @param yaw      yaw angle expressed in radians. Rotation around z-axis.
     * @param jacobian matrix where jacobian will be stored if provided.
     * @throws IllegalArgumentException if provided jacobian matrix does not
     *                                  have size 4x3
     * @see &lt;a href=&quot;https://github.com/joansola/slamtb&quot;&gt;e2q.m at https://github.com/joansola/slamtb&lt;/a&gt;
     */
    public void setFromEulerAngles(
            final double roll, final double pitch, final double yaw, final Matrix jacobian) {

<span class="pc bpc" id="L617" title="1 of 6 branches missed.">        if (jacobian != null &amp;&amp; (jacobian.getRows() != N_PARAMS || jacobian.getColumns() != N_ANGLES)) {</span>
<span class="fc" id="L618">            throw new IllegalArgumentException(&quot;jacobian must be 4x3&quot;);</span>
        }

        // roll rotation on X axis
<span class="fc" id="L622">        final var qx = new Quaternion(new double[]{1.0, 0.0, 0.0}, roll);</span>
        // pitch rotation on Y axis
<span class="fc" id="L624">        final var qy = new Quaternion(new double[]{0.0, 1.0, 0.0}, pitch);</span>
        // yaw rotation on Z axis (qProd(qProd(qz, qy), qx)
<span class="fc" id="L626">        final var qz = new Quaternion(new double[]{0.0, 0.0, 1.0}, yaw);</span>

<span class="fc" id="L628">        product(qz, qy, this);</span>
<span class="fc" id="L629">        product(this, qx, this);</span>
<span class="fc" id="L630">        normalize();</span>

<span class="fc bfc" id="L632" title="All 2 branches covered.">        if (jacobian != null) {</span>
<span class="fc" id="L633">            final var halfRoll = roll / 2.0;</span>
<span class="fc" id="L634">            final var halfPitch = pitch / 2.0;</span>
<span class="fc" id="L635">            final var halfYaw = yaw / 2.0;</span>

<span class="fc" id="L637">            final var sr = Math.sin(halfRoll);</span>
<span class="fc" id="L638">            final var sp = Math.sin(halfPitch);</span>
<span class="fc" id="L639">            final var sy = Math.sin(halfYaw);</span>

<span class="fc" id="L641">            final var cr = Math.cos(halfRoll);</span>
<span class="fc" id="L642">            final var cp = Math.cos(halfPitch);</span>
<span class="fc" id="L643">            final var cy = Math.cos(halfYaw);</span>

<span class="fc" id="L645">            jacobian.setElementAt(0, 0, 0.5 * (-cy * cp * sr + sy * sp * cr));</span>
<span class="fc" id="L646">            jacobian.setElementAt(1, 0, 0.5 * (cy * cp * cr + sy * sp * sr));</span>
<span class="fc" id="L647">            jacobian.setElementAt(2, 0, 0.5 * (-cy * sp * sr + sy * cp * cr));</span>
<span class="fc" id="L648">            jacobian.setElementAt(3, 0, 0.5 * (-sy * cp * sr - cy * sp * cr));</span>

<span class="fc" id="L650">            jacobian.setElementAt(0, 1, 0.5 * (-cy * sp * cr + sy * cp * sr));</span>
<span class="fc" id="L651">            jacobian.setElementAt(1, 1, 0.5 * (-cy * sp * sr - sy * cp * cr));</span>
<span class="fc" id="L652">            jacobian.setElementAt(2, 1, 0.5 * (cy * cp * cr - sy * sp * sr));</span>
<span class="fc" id="L653">            jacobian.setElementAt(3, 1, 0.5 * (-cy * cp * sr - sy * sp * cr));</span>

<span class="fc" id="L655">            jacobian.setElementAt(0, 2, 0.5 * (-sy * cp * cr + cy * sp * sr));</span>
<span class="fc" id="L656">            jacobian.setElementAt(1, 2, jacobian.getElementAt(3, 0));</span>
<span class="fc" id="L657">            jacobian.setElementAt(2, 2, 0.5 * (-sy * sp * cr + cy * cp * sr));</span>
<span class="fc" id="L658">            jacobian.setElementAt(3, 2, jacobian.getElementAt(1, 0));</span>
        }
<span class="fc" id="L660">    }</span>

    /**
     * Sets quaternion from euler angles (roll, pitch and yaw).
     *
     * @param roll  roll angle expressed in radians. Rotation around x-axis.
     * @param pitch pitch angle expressed in radians. Rotation around y-axis.
     * @param yaw   yaw angle expressed in radians. Rotation around z-axis.
     * @see &lt;a href=&quot;https://github.com/joansola/slamtb&quot;&gt;e2q.m at https://github.com/joansola/slamtb&lt;/a&gt;
     */
    public final void setFromEulerAngles(final double roll, final double pitch, final double yaw) {
<span class="fc" id="L671">        setFromEulerAngles(roll, pitch, yaw, null);</span>
<span class="fc" id="L672">    }</span>

    /**
     * Sets quaternion from euler angles.
     *
     * @param angles   euler angles expressed in radians in the following order:
     *                 roll, pitch and yaw.
     * @param jacobian matrix where jacobian will be stored if provided.
     * @throws IllegalArgumentException if provided array does not have length
     *                                  3.
     */
    public void setFromEulerAngles(final double[] angles, final Matrix jacobian) {
<span class="fc bfc" id="L684" title="All 2 branches covered.">        if (angles.length != N_ANGLES) {</span>
<span class="fc" id="L685">            throw new IllegalArgumentException(&quot;angles length must be 3&quot;);</span>
        }

<span class="fc" id="L688">        setFromEulerAngles(angles[0], angles[1], angles[2], jacobian);</span>
<span class="fc" id="L689">    }</span>

    /**
     * Sets quaternion from euler angles (roll, pitch and yaw).
     *
     * @param angles euler angles expressed in radians in the following order:
     *               roll, pitch and yaw.
     * @throws IllegalArgumentException if provided array does not have length
     *                                  3.
     */
    public void setFromEulerAngles(final double[] angles) {
<span class="fc" id="L700">        setFromEulerAngles(angles, null);</span>
<span class="fc" id="L701">    }</span>

    /**
     * Computes the rotation matrix body-to-world corresponding to the body
     * orientation given by the Euler angles (roll, pitch, yaw).
     *
     * @param roll     roll angle expressed in radians. Rotation around x-axis.
     * @param pitch    pitch angle expressed in radians. Rotation around y-axis.
     * @param yaw      yaw angle expressed in radians. Rotation around z-axis.
     * @param result   instance where computed rotation will be stored.
     * @param jacobian jacobian of computed rotation (optional).
     * @throws IllegalArgumentException if provided jacobian is not 9x3.
     * @see &lt;a href=&quot;https://github.com/joansola/slamtb&quot;&gt;e2R.m at https://github.com/joansola/slamtb&lt;/a&gt;
     */
    public static void eulerToMatrixRotation(
            final double roll, final double pitch, final double yaw, final MatrixRotation3D result,
            final Matrix jacobian) {

<span class="pc bpc" id="L719" title="1 of 6 branches missed.">        if (jacobian != null &amp;&amp; (jacobian.getRows() != 3 * N_ANGLES || jacobian.getColumns() != N_ANGLES)) {</span>
<span class="fc" id="L720">            throw new IllegalArgumentException(&quot;jacobian must be 9x3&quot;);</span>
        }

<span class="fc" id="L723">        result.setRollPitchYaw(roll, pitch, yaw);</span>

<span class="fc bfc" id="L725" title="All 2 branches covered.">        if (jacobian != null) {</span>
<span class="fc" id="L726">            final var sr = Math.sin(roll);</span>
<span class="fc" id="L727">            final var cr = Math.cos(roll);</span>
<span class="fc" id="L728">            final var sp = Math.sin(pitch);</span>
<span class="fc" id="L729">            final var cp = Math.cos(pitch);</span>
<span class="fc" id="L730">            final var sy = Math.sin(yaw);</span>
<span class="fc" id="L731">            final var cy = Math.cos(yaw);</span>

<span class="fc" id="L733">            final var tmp1 = sr * sy + cr * sp * cy;</span>
<span class="fc" id="L734">            final var tmp2 = -cr * cy - sr * sp * sy;</span>
<span class="fc" id="L735">            jacobian.setElementAt(0, 0, 0.0);</span>
<span class="fc" id="L736">            jacobian.setElementAt(1, 0, 0.0);</span>
<span class="fc" id="L737">            jacobian.setElementAt(2, 0, 0.0);</span>
<span class="fc" id="L738">            jacobian.setElementAt(3, 0, tmp1);</span>
<span class="fc" id="L739">            jacobian.setElementAt(4, 0, -sr * cy + cr * sp * sy);</span>
<span class="fc" id="L740">            jacobian.setElementAt(5, 0, cr * cp);</span>
<span class="fc" id="L741">            jacobian.setElementAt(6, 0, cr * sy - sr * sp * cy);</span>
<span class="fc" id="L742">            jacobian.setElementAt(7, 0, tmp2);</span>
<span class="fc" id="L743">            jacobian.setElementAt(8, 0, -sr * cp);</span>

<span class="fc" id="L745">            jacobian.setElementAt(0, 1, -sp * cy);</span>
<span class="fc" id="L746">            jacobian.setElementAt(1, 1, -sp * sy);</span>
<span class="fc" id="L747">            jacobian.setElementAt(2, 1, -cp);</span>
<span class="fc" id="L748">            jacobian.setElementAt(3, 1, sr * cp * cy);</span>
<span class="fc" id="L749">            jacobian.setElementAt(4, 1, sr * cp * sy);</span>
<span class="fc" id="L750">            jacobian.setElementAt(5, 1, -sr * sp);</span>
<span class="fc" id="L751">            jacobian.setElementAt(6, 1, cr * cp * cy);</span>
<span class="fc" id="L752">            jacobian.setElementAt(7, 1, cr * cp * sy);</span>
<span class="fc" id="L753">            jacobian.setElementAt(8, 1, -cr * sp);</span>

<span class="fc" id="L755">            jacobian.setElementAt(0, 2, -cp * sy);</span>
<span class="fc" id="L756">            jacobian.setElementAt(1, 2, cp * cy);</span>
<span class="fc" id="L757">            jacobian.setElementAt(2, 2, 0.0);</span>
<span class="fc" id="L758">            jacobian.setElementAt(3, 2, tmp2);</span>
<span class="fc" id="L759">            jacobian.setElementAt(4, 2, -cr * sy + sr * sp * cy);</span>
<span class="fc" id="L760">            jacobian.setElementAt(5, 2, 0.0);</span>
<span class="fc" id="L761">            jacobian.setElementAt(6, 2, sr * cy - cr * sp * sy);</span>
<span class="fc" id="L762">            jacobian.setElementAt(7, 2, tmp1);</span>
<span class="fc" id="L763">            jacobian.setElementAt(8, 2, 0.0);</span>
        }
<span class="fc" id="L765">    }</span>

    /**
     * Computes the rotation matrix body-to-world corresponding to the body
     * orientation given by the Euler angles (roll, pitch, yaw).
     *
     * @param roll   roll angle expressed in radians. Rotation around x-axis.
     * @param pitch  pitch angle expressed in radians. Rotation around y-axis.
     * @param yaw    yaw angle expressed in radians. Rotation around z-axis.
     * @param result instance where computed rotation will be stored.
     * @see &lt;a href=&quot;https://github.com/joansola/slamtb&quot;&gt;e2R.m at https://github.com/joansola/slamtb&lt;/a&gt;
     */
    public static void eulerToMatrixRotation(
            final double roll, final double pitch, final double yaw, final MatrixRotation3D result) {
<span class="fc" id="L779">        eulerToMatrixRotation(roll, pitch, yaw, result, null);</span>
<span class="fc" id="L780">    }</span>

    /**
     * Computes the rotation matrix body-to-world corresponding to the body
     * orientation given by the Euler angles (roll, pitch, yaw).
     *
     * @param angles   array containing roll, pitch and yaw angles.
     * @param result   instance where computed rotation will be stored.
     * @param jacobian jacobian of computed rotation (optional).
     * @throws IllegalArgumentException if provided angles length is not 3, or
     *                                  if provided jacobian is not 9x3.
     * @see &lt;a href=&quot;https://github.com/joansola/slamtb&quot;&gt;e2R.m at https://github.com/joansola/slamtb&lt;/a&gt;
     */
    public static void eulerToMatrixRotation(
            final double[] angles, final MatrixRotation3D result, final Matrix jacobian) {
<span class="fc bfc" id="L795" title="All 2 branches covered.">        if (angles.length != N_ANGLES) {</span>
<span class="fc" id="L796">            throw new IllegalArgumentException(&quot;angles must have length 3&quot;);</span>
        }

<span class="fc" id="L799">        eulerToMatrixRotation(angles[0], angles[1], angles[2], result, jacobian);</span>
<span class="fc" id="L800">    }</span>

    /**
     * Computes the rotation matrix body-to-world corresponding to the body
     * orientation given by the Euler angles (roll, pitch, yaw).
     *
     * @param angles array containing roll, pitch and yaw angles.
     * @param result instance where computed rotation will be stored.
     * @throws IllegalArgumentException if provided angles length is not 3.
     * @see &lt;a href=&quot;https://github.com/joansola/slamtb&quot;&gt;e2R.m at https://github.com/joansola/slamtb&lt;/a&gt;
     */
    public static void eulerToMatrixRotation(final double[] angles, final MatrixRotation3D result) {
<span class="fc" id="L812">        eulerToMatrixRotation(angles, result, null);</span>
<span class="fc" id="L813">    }</span>

    /**
     * Computes rotation angle and axis of this instance.
     *
     * @param axis          array where normalized rotation axis will be stored.
     * @param jacobianAngle matrix where jacobian of angle will be stored, if
     *                      provided. Must be 1x4.
     * @param jacobianAxis  matrix where jacobian of axis will be stored, if
     *                      provided. Must be 3x4.
     * @return rotation angle expressed in radians.
     * @throws IllegalArgumentException if length of axis or size of provided
     *                                  jacobians is not correct.
     * @see &lt;a href=&quot;https://github.com/joansola/slamtb&quot;&gt;q2au.m at https://github.com/joansola/slamtb&lt;/a&gt;
     */
    public double toAxisAndRotationAngle(
            final double[] axis, final Matrix jacobianAngle, final Matrix jacobianAxis) {
<span class="pc bpc" id="L830" title="1 of 2 branches missed.">        if (axis.length != AxisRotation3D.AXIS_PARAMS) {</span>
<span class="nc" id="L831">            throw new IllegalArgumentException(&quot;axis length must be 3&quot;);</span>
        }
<span class="pc bpc" id="L833" title="2 of 6 branches missed.">        if (jacobianAngle != null &amp;&amp; (jacobianAngle.getRows() != 1 || jacobianAngle.getColumns() != N_PARAMS)) {</span>
<span class="nc" id="L834">            throw new IllegalArgumentException(&quot;jacobian of angle must be 1x4&quot;);</span>
        }
<span class="pc bpc" id="L836" title="1 of 4 branches missed.">        if (jacobianAxis != null &amp;&amp; (jacobianAxis.getRows() != AxisRotation3D.AXIS_PARAMS</span>
<span class="pc bpc" id="L837" title="1 of 2 branches missed.">                || jacobianAxis.getColumns() != N_PARAMS)) {</span>
<span class="nc" id="L838">            throw new IllegalArgumentException(&quot;jacobian of axis must be 3x4&quot;);</span>
        }

        // non-normalized rotation axis
<span class="fc" id="L842">        final var v = new double[]{b, c, d};</span>

        // norm of rotation axis
<span class="fc" id="L845">        final var n = com.irurueta.algebra.Utils.normF(v);</span>

        // normalized rotation axis
<span class="fc bfc" id="L848" title="All 2 branches covered.">        if (n &gt; 0.0) {</span>
<span class="fc" id="L849">            ArrayUtils.multiplyByScalar(v, 1.0 / n, axis);</span>
        } else {
<span class="fc" id="L851">            axis[0] = axis[1] = 0.0;</span>
<span class="fc" id="L852">            axis[2] = 1.0;</span>
        }

        // scalar part
<span class="fc" id="L856">        final var s = a;</span>
<span class="fc" id="L857">        final var aValue = 2.0 * Math.atan2(n, s);</span>

<span class="fc bfc" id="L859" title="All 2 branches covered.">        if (jacobianAngle != null) {</span>
<span class="pc bpc" id="L860" title="1 of 2 branches missed.">            if (n &gt; AXIS_NORM_THRESHOLD) {</span>
<span class="fc" id="L861">                final var denom = n * n + s * s;</span>
<span class="fc" id="L862">                final var aN = 2.0 * s / denom;</span>
<span class="fc" id="L863">                final var aS = -2.0 * n / denom;</span>
<span class="fc" id="L864">                final var aV = ArrayUtils.multiplyByScalarAndReturnNew(axis, aN);</span>

<span class="fc" id="L866">                jacobianAngle.setElementAtIndex(0, aS);</span>
<span class="fc" id="L867">                jacobianAngle.setElementAtIndex(1, aV[0]);</span>
<span class="fc" id="L868">                jacobianAngle.setElementAtIndex(2, aV[1]);</span>
<span class="fc" id="L869">                jacobianAngle.setElementAtIndex(3, aV[2]);</span>
<span class="fc" id="L870">            } else {</span>
<span class="nc" id="L871">                jacobianAngle.initialize(0.0);</span>
            }
        }

<span class="fc bfc" id="L875" title="All 2 branches covered.">        if (jacobianAxis != null) {</span>
<span class="fc" id="L876">            jacobianAxis.initialize(0.0);</span>

            try {
<span class="pc bpc" id="L879" title="1 of 2 branches missed.">                if (n &gt; AXIS_NORM_THRESHOLD) {</span>
                    // uV = (eye(3)*n - v * axis') / n^2
<span class="fc" id="L881">                    final var uV = Matrix.identity(AxisRotation3D.AXIS_PARAMS, AxisRotation3D.AXIS_PARAMS);</span>
<span class="fc" id="L882">                    uV.multiplyByScalar(n);</span>
<span class="fc" id="L883">                    uV.subtract(Matrix.newFromArray(v, true).multiplyAndReturnNew(</span>
<span class="fc" id="L884">                            Matrix.newFromArray(axis, false)));</span>
<span class="fc" id="L885">                    uV.multiplyByScalar(1.0 / (n * n));</span>
                    // uQ = [zeros(3, 1) uV]
<span class="fc" id="L887">                    jacobianAxis.setSubmatrix(0, 1, 2, 3, uV);</span>
<span class="fc" id="L888">                } else {</span>
                    // 2*eye(3)
<span class="nc" id="L890">                    final var m = Matrix.identity(AxisRotation3D.AXIS_PARAMS, AxisRotation3D.AXIS_PARAMS);</span>
<span class="nc" id="L891">                    m.multiplyByScalar(2.0);</span>
                    // uQ = [zeros(3,1) 2*eye(3)]
<span class="nc" id="L893">                    jacobianAxis.setSubmatrix(0, 1, 2, 3, m);</span>
                }
<span class="nc" id="L895">            } catch (final WrongSizeException ignore) {</span>
                // never thrown
<span class="fc" id="L897">            }</span>
        }

<span class="fc" id="L900">        return aValue;</span>
    }

    /**
     * Computes rotation angle and axis.
     *
     * @param axis normalized rotation axis.
     * @return rotation angle expressed in radians.
     * @throws IllegalArgumentException if length of axis is not 3.
     */
    public double toAxisAndRotationAngle(final double[] axis) {
<span class="fc" id="L911">        return toAxisAndRotationAngle(axis, null, null);</span>
    }

    /**
     * Converts this quaternion into an axis 3D rotation and stores the result
     * into provided rotation instance.
     *
     * @param result rotation instance where result will be stored.
     */
    @Override
    public void toAxisRotation(final AxisRotation3D result) {
<span class="fc" id="L922">        final var axis = new double[AxisRotation3D.AXIS_PARAMS];</span>
<span class="fc" id="L923">        final var theta = toAxisAndRotationAngle(axis, null, null);</span>
<span class="fc" id="L924">        result.setAxisAndRotation(axis, theta);</span>
<span class="fc" id="L925">    }</span>

    /**
     * Converts this quaternion into an axis 3D rotation.
     *
     * @return a new axis 3D rotation equivalent to this quaternion.
     */
    @Override
    public AxisRotation3D toAxisRotation() {
<span class="fc" id="L934">        final var result = new AxisRotation3D();</span>
<span class="fc" id="L935">        toAxisRotation(result);</span>
<span class="fc" id="L936">        return result;</span>
    }

    /**
     * Computes rotation vector, which is equivalent to the rotation axis but
     * having a norm equal to the rotation angle.
     *
     * @param result   array where rotation vector is stored.
     * @param jacobian matrix where jacobian of vector will be stored, if
     *                 provided.
     * @throws IllegalArgumentException if length of result is not 3 or size of
     *                                  provided jacobian is not 3x4.
     * @see &lt;a href=&quot;https://github.com/joansola/slamtb&quot;&gt;q2v.m at https://github.com/joansola/slamtb&lt;/a&gt;
     */
    public void toRotationVector(final double[] result, final Matrix jacobian) {
<span class="fc bfc" id="L951" title="All 2 branches covered.">        if (result.length != AxisRotation3D.AXIS_PARAMS) {</span>
<span class="fc" id="L952">            throw new IllegalArgumentException(&quot;result length must be 3&quot;);</span>
        }
<span class="fc bfc" id="L954" title="All 4 branches covered.">        if (jacobian != null &amp;&amp; (jacobian.getRows() != AxisRotation3D.AXIS_PARAMS</span>
<span class="pc bpc" id="L955" title="1 of 2 branches missed.">                || jacobian.getColumns() != N_PARAMS)) {</span>
<span class="fc" id="L956">            throw new IllegalArgumentException(&quot;jacobian must be 3x4&quot;);</span>
        }

<span class="fc bfc" id="L959" title="All 2 branches covered.">        if (jacobian == null) {</span>
<span class="fc" id="L960">            final var theta = toAxisAndRotationAngle(result, null, null);</span>
<span class="fc" id="L961">            ArrayUtils.multiplyByScalar(result, theta, result);</span>
<span class="fc" id="L962">        } else {</span>
            try {
<span class="fc" id="L964">                final var jacobianAngle = new Matrix(1, N_PARAMS);</span>
<span class="fc" id="L965">                final var jacobianAxis = new Matrix(AxisRotation3D.AXIS_PARAMS, N_PARAMS);</span>
<span class="fc" id="L966">                final var axis = new double[AxisRotation3D.AXIS_PARAMS];</span>
<span class="fc" id="L967">                final var theta = toAxisAndRotationAngle(axis, jacobianAngle, jacobianAxis);</span>
<span class="fc" id="L968">                ArrayUtils.multiplyByScalar(axis, theta, result);</span>

<span class="fc" id="L970">                final var vA = Matrix.newFromArray(axis, true);</span>
<span class="fc" id="L971">                final var vU = Matrix.diagonal(new double[]{theta, theta, theta});</span>

<span class="pc bpc" id="L973" title="1 of 2 branches missed.">                if (theta &gt; AXIS_NORM_THRESHOLD) {</span>
                    // vA * jacobianAngle + vU * jacobianAxis //3x1 * 1x4 + 3x3 * 3x4

                    // vA * jacobianAngle
<span class="fc" id="L977">                    vA.multiply(jacobianAngle);</span>
                    // vU * jacobianAxis
<span class="fc" id="L979">                    vU.multiply(jacobianAxis);</span>
                    // vA * jacobianAngle + vU * jacobianAxis
<span class="fc" id="L981">                    vA.add(vU);</span>

<span class="fc" id="L983">                    jacobian.copyFrom(vA);</span>
                } else {
                    // 2*eye(3)
<span class="nc" id="L986">                    final var m = Matrix.identity(AxisRotation3D.AXIS_PARAMS,</span>
                            AxisRotation3D.AXIS_PARAMS);
<span class="nc" id="L988">                    m.multiplyByScalar(2.0);</span>
                    // uQ = [zeros(3,1) 2*eye(3)]
<span class="nc" id="L990">                    jacobian.setSubmatrix(0, 1, 2, 3, m);</span>
                }
<span class="nc" id="L992">            } catch (final WrongSizeException ignore) {</span>
                // never thrown
<span class="fc" id="L994">            }</span>
        }
<span class="fc" id="L996">    }</span>

    /**
     * Computes rotation vector, which is equivalent to the rotation axis but
     * having a norm equal to the rotation angle.
     *
     * @param result array where rotation vector is stored.
     * @throws IllegalArgumentException if length of result is not 3.
     */
    public void toRotationVector(final double[] result) {
<span class="fc" id="L1006">        toRotationVector(result, null);</span>
<span class="fc" id="L1007">    }</span>

    /**
     * Computes the euler angles (roll, pitch, yaw) equivalent to this
     * quaternion rotation and stores the result into provided array.
     * If provided, this method also computes the jacobian matrix.
     *
     * @param angles   euler angles (roll, pitch, yaw).
     * @param jacobian matrix where jacobian is stored, if provided.
     * @throws IllegalArgumentException if provided angles array length is not 3
     *                                  or if provided jacobian matrix is not 3x4.
     * @see &lt;a href=&quot;https://github.com/joansola/slamtb&quot;&gt;q2e.m at https://github.com/joansola/slamtb&lt;/a&gt;
     */
    public void toEulerAngles(final double[] angles, final Matrix jacobian) {
<span class="pc bpc" id="L1021" title="1 of 2 branches missed.">        if (angles.length != N_ANGLES) {</span>
<span class="nc" id="L1022">            throw new IllegalArgumentException(&quot;angles length must be 3&quot;);</span>
        }
<span class="pc bpc" id="L1024" title="2 of 6 branches missed.">        if (jacobian != null &amp;&amp; (jacobian.getRows() != N_ANGLES || jacobian.getColumns() != N_PARAMS)) {</span>
<span class="nc" id="L1025">            throw new IllegalArgumentException(&quot;jacobian must be 3x4&quot;);</span>
        }

<span class="fc" id="L1028">        final var y1 = 2.0 * c * d + 2.0 * a * b;</span>
<span class="fc" id="L1029">        final var x1 = a * a - b * b - c * c + d * d;</span>
<span class="fc" id="L1030">        final var z2 = -2.0 * b * d + 2.0 * a * c;</span>
<span class="fc" id="L1031">        final var y3 = 2.0 * b * c + 2.0 * a * d;</span>
<span class="fc" id="L1032">        final var x3 = a * a + b * b - c * c - d * d;</span>

        // roll
<span class="fc" id="L1035">        angles[0] = Math.atan2(y1, x1);</span>

        // pitch
<span class="fc" id="L1038">        angles[1] = Math.asin(z2);</span>

        // yaw
<span class="fc" id="L1041">        angles[2] = Math.atan2(y3, x3);</span>

<span class="fc bfc" id="L1043" title="All 2 branches covered.">        if (jacobian != null) {</span>
<span class="fc" id="L1044">            final var dx1dq = new double[]{2 * a, -2 * b, -2 * c, 2 * d};</span>
<span class="fc" id="L1045">            final var dy1dq = new double[]{2 * b, 2 * a, 2 * d, 2 * c};</span>
<span class="fc" id="L1046">            final var dz2dq = new double[]{2 * c, -2 * d, 2 * a, -2 * b};</span>
<span class="fc" id="L1047">            final var dx3dq = new double[]{2 * a, 2 * b, -2 * c, -2 * d};</span>
<span class="fc" id="L1048">            final var dy3dq = new double[]{2 * d, 2 * c, 2 * b, 2 * a};</span>

<span class="fc" id="L1050">            final var de1dx1 = -y1 / (x1 * x1 + y1 * y1);</span>
<span class="fc" id="L1051">            final var de1dy1 = x1 / (x1 * x1 + y1 * y1);</span>
<span class="fc" id="L1052">            final var de2dz2 = 1 / Math.sqrt(1 - z2 * z2);</span>
<span class="fc" id="L1053">            final var de3dx3 = -y3 / (x3 * x3 + y3 * y3);</span>
<span class="fc" id="L1054">            final var de3dy3 = x3 / (x3 * x3 + y3 * y3);</span>

            // de1dq = de1dx1 * dx1dq + de1dy * dy1dq
<span class="fc" id="L1057">            ArrayUtils.multiplyByScalar(dx1dq, de1dx1, dx1dq);</span>
<span class="fc" id="L1058">            ArrayUtils.multiplyByScalar(dy1dq, de1dy1, dy1dq);</span>
<span class="fc" id="L1059">            final var de1dq = ArrayUtils.sumAndReturnNew(dx1dq, dy1dq);</span>

            // de2dq = de2dz2 * dz2dq
<span class="fc" id="L1062">            final var de2dq = ArrayUtils.multiplyByScalarAndReturnNew(dz2dq, de2dz2);</span>

            // de3dq = de3dx3 * dx3dq + de3dy3 * dy3dq
<span class="fc" id="L1065">            ArrayUtils.multiplyByScalar(dx3dq, de3dx3, dx3dq);</span>
<span class="fc" id="L1066">            ArrayUtils.multiplyByScalar(dy3dq, de3dy3, dy3dq);</span>
<span class="fc" id="L1067">            final var de3dq = ArrayUtils.sumAndReturnNew(dx3dq, dy3dq);</span>

<span class="fc" id="L1069">            jacobian.setSubmatrix(0, 0, 0, N_PARAMS - 1, de1dq);</span>
<span class="fc" id="L1070">            jacobian.setSubmatrix(1, 0, 1, N_PARAMS - 1, de2dq);</span>
<span class="fc" id="L1071">            jacobian.setSubmatrix(2, 0, 2, N_PARAMS - 1, de3dq);</span>
        }
<span class="fc" id="L1073">    }</span>

    /**
     * Computes the euler angles (roll, pitch, yaw) equivalent to this
     * quaternion rotation and stores the result into provided array.
     *
     * @param angles euler angles (roll, pitch, yaw).
     * @throws IllegalArgumentException if provided angles array length is not
     *                                  3.
     */
    public void toEulerAngles(final double[] angles) {
<span class="fc" id="L1084">        toEulerAngles(angles, null);</span>
<span class="fc" id="L1085">    }</span>

    /**
     * Computes the euler angles (roll, pitch, yaw) resulting in an equivalent
     * rotation to this quaternion.
     *
     * @return euler angles (roll, pitch, yaw)
     */
    public double[] toEulerAngles() {
<span class="fc" id="L1094">        final var result = new double[N_ANGLES];</span>
<span class="fc" id="L1095">        toEulerAngles(result, null);</span>
<span class="fc" id="L1096">        return result;</span>
    }

    /**
     * Converts this quaternion into a quaternion matrix so that the quaternion
     * product q1 x q2 is equivalent to the matrix product:
     * q1.toQuaternionMatrix().multiplyAndReturnNew(q2.toQuaternionMatrix())
     *
     * @param result matrix where result will be stored.
     * @throws IllegalArgumentException if provided matrix is not 4x4.
     * @see &lt;a href=&quot;https://github.com/joansola/slamtb&quot;&gt;q2Q.m at https://github.com/joansola/slamtb&lt;/a&gt;
     */
    public void quaternionMatrix(final Matrix result) {
<span class="pc bpc" id="L1109" title="2 of 4 branches missed.">        if (result.getRows() != N_PARAMS || result.getColumns() != N_PARAMS) {</span>
<span class="nc" id="L1110">            throw new IllegalArgumentException(&quot;matrix must be 4x4&quot;);</span>
        }

<span class="fc" id="L1113">        result.setElementAt(0, 0, a);</span>
<span class="fc" id="L1114">        result.setElementAt(1, 0, b);</span>
<span class="fc" id="L1115">        result.setElementAt(2, 0, c);</span>
<span class="fc" id="L1116">        result.setElementAt(3, 0, d);</span>

<span class="fc" id="L1118">        result.setElementAt(0, 1, -b);</span>
<span class="fc" id="L1119">        result.setElementAt(1, 1, a);</span>
<span class="fc" id="L1120">        result.setElementAt(2, 1, d);</span>
<span class="fc" id="L1121">        result.setElementAt(3, 1, -c);</span>

<span class="fc" id="L1123">        result.setElementAt(0, 2, -c);</span>
<span class="fc" id="L1124">        result.setElementAt(1, 2, -d);</span>
<span class="fc" id="L1125">        result.setElementAt(2, 2, a);</span>
<span class="fc" id="L1126">        result.setElementAt(3, 2, b);</span>

<span class="fc" id="L1128">        result.setElementAt(0, 3, -d);</span>
<span class="fc" id="L1129">        result.setElementAt(1, 3, c);</span>
<span class="fc" id="L1130">        result.setElementAt(2, 3, -b);</span>
<span class="fc" id="L1131">        result.setElementAt(3, 3, a);</span>
<span class="fc" id="L1132">    }</span>

    /**
     * Converts this quaternion into a quaternion matrix so that quaternion
     * product q1 x q2 is equivalent to the matrix product:
     * q1.toQuaternionMatrix().multiplyAndReturnNew(q2.toQuaternionMatrix())
     *
     * @return the quaternion matrix.
     * @see &lt;a href=&quot;https://github.com/joansola/slamtb&quot;&gt;q2Q.m at https://github.com/joansola/slamtb&lt;/a&gt;
     */
    public Matrix toQuaternionMatrix() {
<span class="fc" id="L1143">        Matrix result = null;</span>
        try {
<span class="fc" id="L1145">            result = new Matrix(N_PARAMS, N_PARAMS);</span>
<span class="fc" id="L1146">            quaternionMatrix(result);</span>
<span class="nc" id="L1147">        } catch (final WrongSizeException ignore) {</span>
            // never thrown
<span class="fc" id="L1149">        }</span>
<span class="fc" id="L1150">        return result;</span>
    }

    /**
     * Computes the conjugate of this quaternion and stores the result into
     * provided instance.
     *
     * @param result   instance where result is stored.
     * @param jacobian matrix where jacobian is stored.
     * @throws IllegalArgumentException if provided jacobian matrix is not 4x4.
     * @see &lt;a href=&quot;https://github.com/joansola/slamtb&quot;&gt;q2qc.m at https://github.com/joansola/slamtb&lt;/a&gt;
     */
    public void conjugate(final Quaternion result, final Matrix jacobian) {
<span class="pc bpc" id="L1163" title="1 of 6 branches missed.">        if (jacobian != null &amp;&amp; (jacobian.getRows() != N_PARAMS || jacobian.getColumns() != N_PARAMS)) {</span>
<span class="fc" id="L1164">            throw new IllegalArgumentException(&quot;jacobian must be 4x4&quot;);</span>
        }

<span class="fc" id="L1167">        result.a = a;</span>
<span class="fc" id="L1168">        result.b = -b;</span>
<span class="fc" id="L1169">        result.c = -c;</span>
<span class="fc" id="L1170">        result.d = -d;</span>
<span class="fc" id="L1171">        result.normalized = normalized;</span>

<span class="fc bfc" id="L1173" title="All 2 branches covered.">        if (jacobian != null) {</span>
<span class="fc" id="L1174">            jacobian.initialize(0.0);</span>
<span class="fc" id="L1175">            jacobian.setElementAt(0, 0, 1.0);</span>
<span class="fc bfc" id="L1176" title="All 2 branches covered.">            for (int i = 1; i &lt; N_PARAMS; i++) {</span>
<span class="fc" id="L1177">                jacobian.setElementAt(i, i, -1.0);</span>
            }
        }
<span class="fc" id="L1180">    }</span>

    /**
     * Computes the conjugate of this quaternion and stores the result into
     * provided instance.
     *
     * @param result instance where result is stored.
     * @see &lt;a href=&quot;https://github.com/joansola/slamtb&quot;&gt;q2qc.m at https://github.com/joansola/slamtb&lt;/a&gt;
     */
    public void conjugate(final Quaternion result) {
<span class="fc" id="L1190">        conjugate(result, null);</span>
<span class="fc" id="L1191">    }</span>

    /**
     * Computes the conjugate of this quaternion.
     *
     * @return conjugate of this quaternion.
     * @see &lt;a href=&quot;https://github.com/joansola/slamtb&quot;&gt;q2qc.m at https://github.com/joansola/slamtb&lt;/a&gt;
     */
    public Quaternion conjugateAndReturnNew() {
<span class="fc" id="L1200">        final var q = new Quaternion();</span>
<span class="fc" id="L1201">        conjugate(q);</span>
<span class="fc" id="L1202">        return q;</span>
    }

    /**
     * Converts this quaternion into a quaternion matrix so that the quaternion
     * product q1 x q2 is equivalent to the matrix product:
     * q2.toQuaternionMatrixN().multiplyAndReturnNew(q1.toQuaternionMatrixN()).
     * Notice that matrix order in the product is the opposite as the order used
     * when multiplying matrices obtained by method #toQuaternionMatrix().
     *
     * @param result matrix where result will be stored.
     * @throws IllegalArgumentException if provided matrix is not 4x4.
     * @see &lt;a href=&quot;https://github.com/joansola/slamtb&quot;&gt;q2Qn.m at https://github.com/joansola/slamtb&lt;/a&gt;
     */
    public void quaternionMatrixN(final Matrix result) {
<span class="pc bpc" id="L1217" title="2 of 4 branches missed.">        if (result.getRows() != N_PARAMS || result.getColumns() != N_PARAMS) {</span>
<span class="nc" id="L1218">            throw new IllegalArgumentException(&quot;matrix must be 4x4&quot;);</span>
        }

<span class="fc" id="L1221">        result.setElementAt(0, 0, a);</span>
<span class="fc" id="L1222">        result.setElementAt(1, 0, b);</span>
<span class="fc" id="L1223">        result.setElementAt(2, 0, c);</span>
<span class="fc" id="L1224">        result.setElementAt(3, 0, d);</span>

<span class="fc" id="L1226">        result.setElementAt(0, 1, -b);</span>
<span class="fc" id="L1227">        result.setElementAt(1, 1, a);</span>
<span class="fc" id="L1228">        result.setElementAt(2, 1, -d);</span>
<span class="fc" id="L1229">        result.setElementAt(3, 1, c);</span>

<span class="fc" id="L1231">        result.setElementAt(0, 2, -c);</span>
<span class="fc" id="L1232">        result.setElementAt(1, 2, d);</span>
<span class="fc" id="L1233">        result.setElementAt(2, 2, a);</span>
<span class="fc" id="L1234">        result.setElementAt(3, 2, -b);</span>

<span class="fc" id="L1236">        result.setElementAt(0, 3, -d);</span>
<span class="fc" id="L1237">        result.setElementAt(1, 3, -c);</span>
<span class="fc" id="L1238">        result.setElementAt(2, 3, b);</span>
<span class="fc" id="L1239">        result.setElementAt(3, 3, a);</span>
<span class="fc" id="L1240">    }</span>

    /**
     * Converts this quaternion into a quaternion matrix so that quaternion
     * product q1 x q2 is equivalent to the matrix product:
     * q2.toQuaternionMatrixN().multiplyAndReturnNew(q1.toQuaternionMatrixN()).
     * Notice that matrix order in the product is the opposite as the order used
     * when multiplying matrices obtained by method #toQuaternionMatrix().
     *
     * @return the quaternion matrix.
     * @see &lt;a href=&quot;https://github.com/joansola/slamtb&quot;&gt;q2Qn.m at https://github.com/joansola/slamtb&lt;/a&gt;
     */
    public Matrix toQuaternionMatrixN() {
<span class="fc" id="L1253">        Matrix result = null;</span>
        try {
<span class="fc" id="L1255">            result = new Matrix(N_PARAMS, N_PARAMS);</span>
<span class="fc" id="L1256">            quaternionMatrixN(result);</span>
<span class="nc" id="L1257">        } catch (final WrongSizeException ignore) {</span>
            // never thrown
<span class="fc" id="L1259">        }</span>
<span class="fc" id="L1260">        return result;</span>
    }

    /**
     * Computes the matrix representing this quaternion rotation.
     *
     * @param result   matrix where rotation data will be stored.
     * @param jacobian jacobian wrt of this quaternion.
     * @throws IllegalArgumentException if provided result matrix is not 3x3 o
     *                                  jacobian matrix is not 9x4.
     * @see &lt;a href=&quot;https://github.com/joansola/slamtb&quot;&gt;q2R.m at https://github.com/joansola/slamtb&lt;/a&gt;
     */
    public void toMatrixRotation(final Matrix result, final Matrix jacobian) {
<span class="fc bfc" id="L1273" title="All 2 branches covered.">        if (result.getRows() != MatrixRotation3D.ROTATION3D_INHOM_MATRIX_ROWS</span>
<span class="pc bpc" id="L1274" title="1 of 2 branches missed.">                || result.getColumns() != MatrixRotation3D.ROTATION3D_INHOM_MATRIX_COLS) {</span>
<span class="fc" id="L1275">            throw new IllegalArgumentException(&quot;result matrix is not 3x3&quot;);</span>
        }
<span class="pc bpc" id="L1277" title="1 of 6 branches missed.">        if (jacobian != null &amp;&amp; (jacobian.getRows() != 9 || jacobian.getColumns() != 4)) {</span>
<span class="fc" id="L1278">            throw new IllegalArgumentException(&quot;jacobian matrix is not 9x4&quot;);</span>
        }

<span class="fc" id="L1281">        final var aa = a * a;</span>
<span class="fc" id="L1282">        final var ab = 2.0 * a * b;</span>
<span class="fc" id="L1283">        final var ac = 2.0 * a * c;</span>
<span class="fc" id="L1284">        final var ad = 2.0 * a * d;</span>
<span class="fc" id="L1285">        final var bb = b * b;</span>
<span class="fc" id="L1286">        final var bc = 2.0 * b * c;</span>
<span class="fc" id="L1287">        final var bd = 2.0 * b * d;</span>
<span class="fc" id="L1288">        final var cc = c * c;</span>
<span class="fc" id="L1289">        final var cd = 2.0 * c * d;</span>
<span class="fc" id="L1290">        final var dd = d * d;</span>

<span class="fc" id="L1292">        result.setElementAt(0, 0, aa + bb - cc - dd);</span>
<span class="fc" id="L1293">        result.setElementAt(1, 0, bc + ad);</span>
<span class="fc" id="L1294">        result.setElementAt(2, 0, bd - ac);</span>

<span class="fc" id="L1296">        result.setElementAt(0, 1, bc - ad);</span>
<span class="fc" id="L1297">        result.setElementAt(1, 1, aa - bb + cc - dd);</span>
<span class="fc" id="L1298">        result.setElementAt(2, 1, cd + ab);</span>

<span class="fc" id="L1300">        result.setElementAt(0, 2, bd + ac);</span>
<span class="fc" id="L1301">        result.setElementAt(1, 2, cd - ab);</span>
<span class="fc" id="L1302">        result.setElementAt(2, 2, aa - bb - cc + dd);</span>

<span class="fc bfc" id="L1304" title="All 2 branches covered.">        if (jacobian != null) {</span>
<span class="fc" id="L1305">            final var a2 = 2.0 * a;</span>
<span class="fc" id="L1306">            final var b2 = 2.0 * b;</span>
<span class="fc" id="L1307">            final var c2 = 2.0 * c;</span>
<span class="fc" id="L1308">            final var d2 = 2.0 * d;</span>

<span class="fc" id="L1310">            jacobian.setElementAt(0, 0, a2);</span>
<span class="fc" id="L1311">            jacobian.setElementAt(1, 0, d2);</span>
<span class="fc" id="L1312">            jacobian.setElementAt(2, 0, -c2);</span>
<span class="fc" id="L1313">            jacobian.setElementAt(3, 0, -d2);</span>
<span class="fc" id="L1314">            jacobian.setElementAt(4, 0, a2);</span>
<span class="fc" id="L1315">            jacobian.setElementAt(5, 0, b2);</span>
<span class="fc" id="L1316">            jacobian.setElementAt(6, 0, c2);</span>
<span class="fc" id="L1317">            jacobian.setElementAt(7, 0, -b2);</span>
<span class="fc" id="L1318">            jacobian.setElementAt(8, 0, a2);</span>

<span class="fc" id="L1320">            jacobian.setElementAt(0, 1, b2);</span>
<span class="fc" id="L1321">            jacobian.setElementAt(1, 1, c2);</span>
<span class="fc" id="L1322">            jacobian.setElementAt(2, 1, d2);</span>
<span class="fc" id="L1323">            jacobian.setElementAt(3, 1, c2);</span>
<span class="fc" id="L1324">            jacobian.setElementAt(4, 1, -b2);</span>
<span class="fc" id="L1325">            jacobian.setElementAt(5, 1, a2);</span>
<span class="fc" id="L1326">            jacobian.setElementAt(6, 1, d2);</span>
<span class="fc" id="L1327">            jacobian.setElementAt(7, 1, -a2);</span>
<span class="fc" id="L1328">            jacobian.setElementAt(8, 1, -b2);</span>

<span class="fc" id="L1330">            jacobian.setElementAt(0, 2, -c2);</span>
<span class="fc" id="L1331">            jacobian.setElementAt(1, 2, b2);</span>
<span class="fc" id="L1332">            jacobian.setElementAt(2, 2, -a2);</span>
<span class="fc" id="L1333">            jacobian.setElementAt(3, 2, b2);</span>
<span class="fc" id="L1334">            jacobian.setElementAt(4, 2, c2);</span>
<span class="fc" id="L1335">            jacobian.setElementAt(5, 2, d2);</span>
<span class="fc" id="L1336">            jacobian.setElementAt(6, 2, a2);</span>
<span class="fc" id="L1337">            jacobian.setElementAt(7, 2, d2);</span>
<span class="fc" id="L1338">            jacobian.setElementAt(8, 2, -c2);</span>

<span class="fc" id="L1340">            jacobian.setElementAt(0, 3, -d2);</span>
<span class="fc" id="L1341">            jacobian.setElementAt(1, 3, a2);</span>
<span class="fc" id="L1342">            jacobian.setElementAt(2, 3, b2);</span>
<span class="fc" id="L1343">            jacobian.setElementAt(3, 3, -a2);</span>
<span class="fc" id="L1344">            jacobian.setElementAt(4, 3, -d2);</span>
<span class="fc" id="L1345">            jacobian.setElementAt(5, 3, c2);</span>
<span class="fc" id="L1346">            jacobian.setElementAt(6, 3, b2);</span>
<span class="fc" id="L1347">            jacobian.setElementAt(7, 3, c2);</span>
<span class="fc" id="L1348">            jacobian.setElementAt(8, 3, d2);</span>
        }
<span class="fc" id="L1350">    }</span>

    /**
     * Computes the matrix representing this quaternion rotation.
     *
     * @param result matrix where rotation data will be stored.
     * @throws IllegalArgumentException if provided result matrix is not 3x3.
     * @see &lt;a href=&quot;https://github.com/joansola/slamtb&quot;&gt;q2R.m at https://github.com/joansola/slamtb&lt;/a&gt;
     */
    public void toMatrixRotation(final Matrix result) {
<span class="fc" id="L1360">        toMatrixRotation(result, null);</span>
<span class="fc" id="L1361">    }</span>

    /**
     * Converts this quaternion into a 3D matrix rotation.
     *
     * @param result matrix rotation instance where result will be stored.
     * @see &lt;a href=&quot;https://github.com/joansola/slamtb&quot;&gt;q2R.m at https://github.com/joansola/slamtb&lt;/a&gt;
     */
    @Override
    public void toMatrixRotation(final MatrixRotation3D result) {
<span class="fc" id="L1371">        toMatrixRotation(result.internalMatrix);</span>
<span class="fc" id="L1372">    }</span>

    /**
     * Converts this quaternion into a 3D matrix rotation.
     *
     * @return a 3D matrix rotation.
     * @see &lt;a href=&quot;https://github.com/joansola/slamtb&quot;&gt;q2R.m at https://github.com/joansola/slamtb&lt;/a&gt;
     */
    @Override
    public MatrixRotation3D toMatrixRotation() {
<span class="fc" id="L1382">        final var rotation = new MatrixRotation3D();</span>
<span class="fc" id="L1383">        toMatrixRotation(rotation);</span>
<span class="fc" id="L1384">        return rotation;</span>
    }

    /**
     * Rotates a 3D point using the origin of coordinates as the axis of
     * rotation.
     * Point will be rotated by the amount of rotation contained in provided
     * quaternion.
     *
     * @param q                  a quaternion.
     * @param inputPoint         input point to be rotated.
     * @param resultPoint        rotated point.
     * @param jacobianPoint      jacobian wrt of point.
     * @param jacobianQuaternion jacobian wrt of quaternion.
     * @throws IllegalArgumentException if jacobian of point is not 3x3 or
     *                                  jacobian of quaternion is not 3x4.
     * @see &lt;a href=&quot;https://github.com/joansola/slamtb&quot;&gt;qRot.m at https://github.com/joansola/slamtb&lt;/a&gt;
     */
    public static void rotate(final Quaternion q, final Point3D inputPoint, final Point3D resultPoint,
                              final Matrix jacobianPoint, final Matrix jacobianQuaternion) {
<span class="pc bpc" id="L1404" title="2 of 6 branches missed.">        if (jacobianPoint != null &amp;&amp; (jacobianPoint.getRows() != N_ANGLES || jacobianPoint.getColumns() != N_ANGLES)) {</span>
<span class="nc" id="L1405">            throw new IllegalArgumentException(&quot;jacobian of point must be 3x3&quot;);</span>
        }
<span class="pc bpc" id="L1407" title="1 of 4 branches missed.">        if (jacobianQuaternion != null &amp;&amp; (jacobianQuaternion.getRows() != N_ANGLES</span>
<span class="pc bpc" id="L1408" title="1 of 2 branches missed.">                || jacobianQuaternion.getColumns() != N_PARAMS)) {</span>
<span class="nc" id="L1409">            throw new IllegalArgumentException(&quot;jacobian of quaternion must be 3x4&quot;);</span>
        }

<span class="fc" id="L1412">        final var v0 = new Quaternion(0.0, inputPoint.getInhomX(), inputPoint.getInhomY(), inputPoint.getInhomZ());</span>

<span class="fc" id="L1414">        final var tmp = q.multiplyAndReturnNew(v0).multiplyAndReturnNew(q.conjugateAndReturnNew());</span>

<span class="fc" id="L1416">        resultPoint.setInhomogeneousCoordinates(tmp.getB(), tmp.getC(), tmp.getD());</span>

<span class="fc bfc" id="L1418" title="All 2 branches covered.">        if (jacobianPoint != null) {</span>
<span class="fc" id="L1419">            q.toMatrixRotation(jacobianPoint);</span>
        }

<span class="fc bfc" id="L1422" title="All 2 branches covered.">        if (jacobianQuaternion != null) {</span>
<span class="fc" id="L1423">            final var a = q.a;</span>
<span class="fc" id="L1424">            final var b = q.b;</span>
<span class="fc" id="L1425">            final var c = q.c;</span>
<span class="fc" id="L1426">            final var d = q.d;</span>

<span class="fc" id="L1428">            final var x = inputPoint.getInhomX();</span>
<span class="fc" id="L1429">            final var y = inputPoint.getInhomY();</span>
<span class="fc" id="L1430">            final var z = inputPoint.getInhomZ();</span>

<span class="fc" id="L1432">            final var axdycz = 2.0 * (a * x - d * y + c * z);</span>
<span class="fc" id="L1433">            final var bxcydz = 2.0 * (b * x + c * y + d * z);</span>
<span class="fc" id="L1434">            final var cxbyaz = 2.0 * (c * x - b * y - a * z);</span>
<span class="fc" id="L1435">            final var dxaybz = 2.0 * (d * x + a * y - b * z);</span>

<span class="fc" id="L1437">            jacobianQuaternion.setElementAt(0, 0, axdycz);</span>
<span class="fc" id="L1438">            jacobianQuaternion.setElementAt(1, 0, dxaybz);</span>
<span class="fc" id="L1439">            jacobianQuaternion.setElementAt(2, 0, -cxbyaz);</span>

<span class="fc" id="L1441">            jacobianQuaternion.setElementAt(0, 1, bxcydz);</span>
<span class="fc" id="L1442">            jacobianQuaternion.setElementAt(1, 1, cxbyaz);</span>
<span class="fc" id="L1443">            jacobianQuaternion.setElementAt(2, 1, dxaybz);</span>

<span class="fc" id="L1445">            jacobianQuaternion.setElementAt(0, 2, -cxbyaz);</span>
<span class="fc" id="L1446">            jacobianQuaternion.setElementAt(1, 2, bxcydz);</span>
<span class="fc" id="L1447">            jacobianQuaternion.setElementAt(2, 2, -axdycz);</span>

<span class="fc" id="L1449">            jacobianQuaternion.setElementAt(0, 3, -dxaybz);</span>
<span class="fc" id="L1450">            jacobianQuaternion.setElementAt(1, 3, axdycz);</span>
<span class="fc" id="L1451">            jacobianQuaternion.setElementAt(2, 3, bxcydz);</span>
        }
<span class="fc" id="L1453">    }</span>

    /**
     * Rotates a 3D point using the origin of coordinates as the axis of
     * rotation.
     * Point will be rotated by the amount of rotation contained in this
     * quaternion instance.
     *
     * @param inputPoint         input point to be rotated.
     * @param resultPoint        rotated point.
     * @param jacobianPoint      jacobian wrt of point.
     * @param jacobianQuaternion jacobian wrt of quaternion.
     * @throws IllegalArgumentException if jacobian of point is not 3x3 or
     *                                  jacobian of quaternion is no 3x4.
     * @see &lt;a href=&quot;https://github.com/joansola/slamtb&quot;&gt;qRot.m at https://github.com/joansola/slamtb&lt;/a&gt;
     */
    public void rotate(final Point3D inputPoint, final Point3D resultPoint, final Matrix jacobianPoint,
                       final Matrix jacobianQuaternion) {

<span class="fc" id="L1472">        rotate(this, inputPoint, resultPoint, jacobianPoint, jacobianQuaternion);</span>
<span class="fc" id="L1473">    }</span>


    /**
     * Rotates a 3D point using the origin of coordinates as the axis of
     * rotation.
     * Point will be rotated by the amount of rotation contained in this
     * quaternion instance.
     *
     * @param inputPoint  Input point to be rotated.
     * @param resultPoint Rotated point.
     * @see &lt;a href=&quot;https://github.com/joansola/slamtb&quot;&gt;qRot.m at https://github.com/joansola/slamtb&lt;/a&gt;
     */
    @Override
    public void rotate(final Point3D inputPoint, final Point3D resultPoint) {
<span class="fc" id="L1488">        rotate(inputPoint, resultPoint, null, null);</span>
<span class="fc" id="L1489">    }</span>

    /**
     * Returns a 3D point containing a rotated version of provided point.
     * Point will be rotated using the origin of the coordinates as the axis of
     * rotation.
     * Point will be rotated by the amount of rotation contained in this
     * quaternion instance.
     *
     * @param point Point to be rotated.
     * @return Rotated point.
     * @see &lt;a href=&quot;https://github.com/joansola/slamtb&quot;&gt;qRot.m at https://github.com/joansola/slamtb&lt;/a&gt;
     */
    @Override
    public Point3D rotate(final Point3D point) {
<span class="fc" id="L1504">        final var result = new HomogeneousPoint3D();</span>
<span class="fc" id="L1505">        rotate(point, result);</span>
<span class="fc" id="L1506">        return result;</span>
    }

    /**
     * Converts rotation matrix into a quaternion.
     *
     * @param r      a rotation matrix to be converted from.
     * @param result quaternion where result is stored.
     * @throws IllegalArgumentException if provided matrix is not 3x3
     * @see &lt;a href=&quot;https://github.com/joansola/slamtb&quot;&gt;R2q.m at https://github.com/joansola/slamtb&lt;/a&gt;
     */
    public static void matrixRotationToQuaternion(final Matrix r, final Quaternion result) {
<span class="fc bfc" id="L1518" title="All 2 branches covered.">        if (r.getRows() != MatrixRotation3D.ROTATION3D_INHOM_MATRIX_ROWS</span>
<span class="pc bpc" id="L1519" title="1 of 2 branches missed.">                || r.getColumns() != MatrixRotation3D.ROTATION3D_INHOM_MATRIX_COLS) {</span>
<span class="fc" id="L1520">            throw new IllegalArgumentException(&quot;rotation matrix must be 3x3&quot;);</span>
        }

<span class="fc" id="L1523">        final var trace = com.irurueta.algebra.Utils.trace(r) + 1.0;</span>
        double s;
        double a;
        double b;
        double c;
        double d;

<span class="fc bfc" id="L1530" title="All 2 branches covered.">        if (trace &gt; TRACE_THRESHOLD) {</span>
            // to avoid large distortions
<span class="fc" id="L1532">            s = 2.0 * Math.sqrt(trace);</span>
<span class="fc" id="L1533">            a = 0.25 * s;</span>
<span class="fc" id="L1534">            b = (r.getElementAt(1, 2) - r.getElementAt(2, 1)) / s;</span>
<span class="fc" id="L1535">            c = (r.getElementAt(2, 0) - r.getElementAt(0, 2)) / s;</span>
<span class="fc" id="L1536">            d = (r.getElementAt(0, 1) - r.getElementAt(1, 0)) / s;</span>
        } else {
<span class="fc bfc" id="L1538" title="All 2 branches covered.">            if (r.getElementAt(0, 0) &gt; r.getElementAt(1, 1)</span>
<span class="fc bfc" id="L1539" title="All 2 branches covered.">                    &amp;&amp; r.getElementAt(0, 0) &gt; r.getElementAt(2, 2)) {</span>
                // column 1:
                // tested with R2 = diag([1 -1 -1])

<span class="fc" id="L1543">                s = 2.0 * Math.sqrt(1.0 + r.getElementAt(0, 0) - r.getElementAt(1, 1)</span>
<span class="fc" id="L1544">                        - r.getElementAt(2, 2));</span>
<span class="fc" id="L1545">                a = (r.getElementAt(1, 2) - r.getElementAt(2, 1)) / s;</span>
<span class="fc" id="L1546">                b = 0.25 * s;</span>
<span class="fc" id="L1547">                c = (r.getElementAt(0, 1) + r.getElementAt(1, 0)) / s;</span>
<span class="fc" id="L1548">                d = (r.getElementAt(2, 0) + r.getElementAt(0, 2)) / s;</span>
<span class="fc bfc" id="L1549" title="All 2 branches covered.">            } else if (r.getElementAt(1, 1) &gt; r.getElementAt(2, 2)) {</span>
                // column 2:
                // tested with R3 = [0 1 0; 1 0 0; 0 0 -1]

<span class="fc" id="L1553">                s = 2.0 * Math.sqrt(1.0 + r.getElementAt(1, 1) - r.getElementAt(0, 0)</span>
<span class="fc" id="L1554">                        - r.getElementAt(2, 2));</span>
<span class="fc" id="L1555">                a = (r.getElementAt(2, 0) - r.getElementAt(0, 2)) / s;</span>
<span class="fc" id="L1556">                b = (r.getElementAt(0, 1) + r.getElementAt(1, 0)) / s;</span>
<span class="fc" id="L1557">                c = 0.25 * s;</span>
<span class="fc" id="L1558">                d = (r.getElementAt(1, 2) + r.getElementAt(2, 1)) / s;</span>
            } else {
                // column 3:
                // tested with R4 = [-1 0 0; 0 0 1; 0 1 0]

<span class="fc" id="L1563">                s = 2.0 * Math.sqrt(1.0 + r.getElementAt(2, 2)</span>
<span class="fc" id="L1564">                        - r.getElementAt(0, 0) - r.getElementAt(1, 1));</span>
<span class="fc" id="L1565">                a = (r.getElementAt(0, 1) - r.getElementAt(1, 0)) / s;</span>
<span class="fc" id="L1566">                b = (r.getElementAt(2, 0) + r.getElementAt(0, 2)) / s;</span>
<span class="fc" id="L1567">                c = (r.getElementAt(1, 2) + r.getElementAt(2, 1)) / s;</span>
<span class="fc" id="L1568">                d = 0.25 * s;</span>
            }
        }

<span class="fc" id="L1572">        result.a = a;</span>
<span class="fc" id="L1573">        result.b = -b;</span>
<span class="fc" id="L1574">        result.c = -c;</span>
<span class="fc" id="L1575">        result.d = -d;</span>
<span class="fc" id="L1576">        result.normalized = false;</span>
<span class="fc" id="L1577">    }</span>

    /**
     * Converts 3D matrix rotation into a quaternion.
     *
     * @param rotation a 3D matrix rotation to be converted from.
     * @param result   quaternion where result is stored.
     * @see &lt;a href=&quot;https://github.com/joansola/slamtb&quot;&gt;R2q.m at https://github.com/joansola/slamtb&lt;/a&gt;
     */
    public static void matrixRotationToQuaternion(final MatrixRotation3D rotation, final Quaternion result) {
<span class="fc" id="L1587">        matrixRotationToQuaternion(rotation.internalMatrix, result);</span>
<span class="fc" id="L1588">    }</span>

    /**
     * Sets quaternion values associated to provided rotation.
     *
     * @param matrix a rotation matrix.
     * @throws IllegalArgumentException if provided matrix is not 3x3.
     * @see &lt;a href=&quot;https://github.com/joansola/slamtb&quot;&gt;R2q.m at https://github.com/joansola/slamtb&lt;/a&gt;
     */
    public void setFromMatrixRotation(final Matrix matrix) {
<span class="fc" id="L1598">        matrixRotationToQuaternion(matrix, this);</span>
<span class="fc" id="L1599">    }</span>

    /**
     * Sets quaternion values associated to provided rotation.
     *
     * @param rotation a rotation to be converted into a quaternion.
     * @see &lt;a href=&quot;https://github.com/joansola/slamtb&quot;&gt;R2q.m at https://github.com/joansola/slamtb&lt;/a&gt;
     */
    public final void setFromMatrixRotation(final MatrixRotation3D rotation) {
<span class="fc" id="L1608">        matrixRotationToQuaternion(rotation, this);</span>
<span class="fc" id="L1609">    }</span>

    /**
     * Converts a rotation vector (rotation axis having a norm equal to the
     * rotation angle) into a normalized rotation axis and its corresponding
     * rotation angle.
     *
     * @param rotationVector         input rotation vector to be converted.
     * @param axis                   obtained normalized rotation axis.
     * @param jacobianAlpha          jacobian wrt of angle.
     * @param jacobianRotationVector jacobian wrt of rotation vector.
     * @return rotation angle.
     * @throws IllegalArgumentException if provided rotation vector length is
     *                                  not 3, jacobian of angle is not 1x3 or jacobian of rotation vector is
     *                                  not 3x3.
     * @see &lt;a href=&quot;https://github.com/joansola/slamtb&quot;&gt;v2au.m at https://github.com/joansola/slamtb&lt;/a&gt;
     */
    public static double rotationVectorToRotationAxisAndAngle(
            final double[] rotationVector, final double[] axis, final Matrix jacobianAlpha,
            final Matrix jacobianRotationVector) {
<span class="fc bfc" id="L1629" title="All 2 branches covered.">        if (rotationVector.length != AxisRotation3D.AXIS_PARAMS) {</span>
<span class="fc" id="L1630">            throw new IllegalArgumentException(&quot;rotation vector length must be 3&quot;);</span>
        }

<span class="pc bpc" id="L1633" title="1 of 6 branches missed.">        if (jacobianAlpha != null &amp;&amp; (jacobianAlpha.getRows() != 1 || jacobianAlpha.getColumns() != N_ANGLES)) {</span>
<span class="fc" id="L1634">            throw new IllegalArgumentException(&quot;jacobian alpha must be 1x3&quot;);</span>
        }

<span class="fc bfc" id="L1637" title="All 4 branches covered.">        if (jacobianRotationVector != null &amp;&amp; (jacobianRotationVector.getRows() != N_ANGLES</span>
<span class="pc bpc" id="L1638" title="1 of 2 branches missed.">                || jacobianRotationVector.getColumns() != N_ANGLES)) {</span>
<span class="fc" id="L1639">            throw new IllegalArgumentException(&quot;jacobian rotation vector must be 3x3&quot;);</span>
        }

<span class="fc" id="L1642">        var alpha = com.irurueta.algebra.Utils.normF(rotationVector);</span>

<span class="pc bpc" id="L1644" title="1 of 2 branches missed.">        if (alpha &gt; AXIS_NORM_THRESHOLD) {</span>
<span class="fc" id="L1645">            ArrayUtils.multiplyByScalar(rotationVector, 1.0 / alpha, axis);</span>

<span class="fc bfc" id="L1647" title="All 2 branches covered.">            if (jacobianAlpha != null) {</span>
<span class="fc" id="L1648">                jacobianAlpha.setSubmatrix(0, 0, 0,</span>
                        axis.length - 1, axis);
            }

<span class="fc bfc" id="L1652" title="All 2 branches covered.">            if (jacobianRotationVector != null) {</span>
<span class="fc" id="L1653">                jacobianRotationVector.setElementAt(0, 0, 1.0 / alpha - axis[0] * axis[0] / alpha);</span>
<span class="fc" id="L1654">                jacobianRotationVector.setElementAt(1, 0, -axis[0] / alpha * axis[1]);</span>
<span class="fc" id="L1655">                jacobianRotationVector.setElementAt(2, 0, -axis[0] / alpha * axis[2]);</span>

<span class="fc" id="L1657">                jacobianRotationVector.setElementAt(0, 1, -axis[0] / alpha * axis[1]);</span>
<span class="fc" id="L1658">                jacobianRotationVector.setElementAt(1, 1, 1.0 / alpha - axis[1] * axis[1] / alpha);</span>
<span class="fc" id="L1659">                jacobianRotationVector.setElementAt(2, 1, -axis[1] / alpha * axis[2]);</span>

<span class="fc" id="L1661">                jacobianRotationVector.setElementAt(0, 2, -axis[0] / alpha * axis[2]);</span>
<span class="fc" id="L1662">                jacobianRotationVector.setElementAt(1, 2, -axis[1] / alpha * axis[2]);</span>
<span class="fc" id="L1663">                jacobianRotationVector.setElementAt(2, 2, 1.0 / alpha - axis[2] * axis[2] / alpha);</span>
            }

        } else {
<span class="nc" id="L1667">            alpha = 0.0;</span>
<span class="nc" id="L1668">            Arrays.fill(axis, 0.0);</span>

<span class="nc bnc" id="L1670" title="All 2 branches missed.">            if (jacobianAlpha != null) {</span>
<span class="nc" id="L1671">                jacobianAlpha.initialize(0.0);</span>
            }

<span class="nc bnc" id="L1674" title="All 2 branches missed.">            if (jacobianRotationVector != null) {</span>
<span class="nc" id="L1675">                jacobianRotationVector.initialize(0.0);</span>
            }
        }

<span class="fc" id="L1679">        return alpha;</span>
    }

    /**
     * Converts a rotation vector (rotation axis having a norm equal to the
     * rotation angle) into a normalized rotation axis and its corresponding
     * rotation angle.
     *
     * @param rotationVector input rotation vector to be converted.
     * @param axis           obtained normalized rotation axis.
     * @return rotation angle.
     * @throws IllegalArgumentException if provided rotation vector length is
     *                                  not 3.
     * @see &lt;a href=&quot;https://github.com/joansola/slamtb&quot;&gt;v2au.m at https://github.com/joansola/slamtb&lt;/a&gt;
     */
    public static double rotationVectorToRotationAxisAndAngle(final double[] rotationVector, final double[] axis) {
<span class="fc" id="L1695">        return rotationVectorToRotationAxisAndAngle(rotationVector, axis, null, null);</span>
    }

    /**
     * Converts a rotation vector (rotation axis having a norm equal to the
     * rotation angle) into a quaternion, and stores the corresponding jacobian
     * of the quaternion respect to the vector if provided.
     *
     * @param rotationVector input rotation vector to be converted.
     * @param result         quaternion where result will be stored.
     * @param jacobian       if provided, matrix where jacobian of the quaternion
     *                       respect to the vector will be stored. Must be 4x3.
     * @throws IllegalArgumentException if provided rotation vector is not
     *                                  length 3 or if provided jacobian matrix is not 4x3.
     * @see &lt;a href=&quot;https://github.com/joansola/slamtb&quot;&gt;v2q.m at https://github.com/joansola/slamtb&lt;/a&gt;
     */
    public static void rotationVectorToQuaternion(
            final double[] rotationVector, final Quaternion result, final Matrix jacobian) {
<span class="fc bfc" id="L1713" title="All 2 branches covered.">        if (rotationVector.length != AxisRotation3D.AXIS_PARAMS) {</span>
<span class="fc" id="L1714">            throw new IllegalArgumentException(&quot;rotation vector length must be 3&quot;);</span>
        }
<span class="pc bpc" id="L1716" title="1 of 6 branches missed.">        if (jacobian != null &amp;&amp; (jacobian.getRows() != N_PARAMS || jacobian.getColumns() != N_ANGLES)) {</span>
<span class="fc" id="L1717">            throw new IllegalArgumentException(&quot;jacobian must be 4x3&quot;);</span>
        }

<span class="fc" id="L1720">        final var axis = new double[AxisRotation3D.AXIS_PARAMS];</span>
<span class="fc bfc" id="L1721" title="All 2 branches covered.">        if (jacobian == null) {</span>
<span class="fc" id="L1722">            final var alpha = rotationVectorToRotationAxisAndAngle(rotationVector, axis);</span>
<span class="fc" id="L1723">            result.setFromAxisAndRotation(axis, alpha);</span>
<span class="fc" id="L1724">        } else {</span>
<span class="fc" id="L1725">            var alpha = com.irurueta.algebra.Utils.normF(rotationVector);</span>

<span class="pc bpc" id="L1727" title="1 of 2 branches missed.">            if (alpha &lt; LARGE_AXIS_NORM_THRESHOLD) {</span>
                // use small signal approximation
<span class="nc" id="L1729">                result.a = 1 - alpha * alpha / 8.0;</span>
<span class="nc" id="L1730">                result.b = rotationVector[0] / 2.0;</span>
<span class="nc" id="L1731">                result.c = rotationVector[1] / 2.0;</span>
<span class="nc" id="L1732">                result.d = rotationVector[2] / 2.0;</span>
<span class="nc" id="L1733">                result.normalized = false;</span>

<span class="nc" id="L1735">                jacobian.setElementAt(0, 0, -0.25 * rotationVector[0]);</span>
<span class="nc" id="L1736">                jacobian.setElementAt(0, 1, -0.25 * rotationVector[1]);</span>
<span class="nc" id="L1737">                jacobian.setElementAt(0, 2, -0.25 * rotationVector[2]);</span>

<span class="nc" id="L1739">                jacobian.setElementAt(1, 0, 0.5);</span>
<span class="nc" id="L1740">                jacobian.setElementAt(1, 1, 0.0);</span>
<span class="nc" id="L1741">                jacobian.setElementAt(1, 2, 0.0);</span>

<span class="nc" id="L1743">                jacobian.setElementAt(2, 0, 0.0);</span>
<span class="nc" id="L1744">                jacobian.setElementAt(2, 1, 0.5);</span>
<span class="nc" id="L1745">                jacobian.setElementAt(2, 2, 0.0);</span>

<span class="nc" id="L1747">                jacobian.setElementAt(3, 0, 0.0);</span>
<span class="nc" id="L1748">                jacobian.setElementAt(3, 1, 0.0);</span>
<span class="nc" id="L1749">                jacobian.setElementAt(3, 2, 0.5);</span>
            } else {
                try {
                    // Av
<span class="fc" id="L1753">                    final var jacobianAlpha = new Matrix(1, N_ANGLES);</span>
                    // Uv
<span class="fc" id="L1755">                    final var jacobianRotationVector = new Matrix(N_ANGLES, N_ANGLES);</span>
<span class="fc" id="L1756">                    alpha = rotationVectorToRotationAxisAndAngle(rotationVector, axis, jacobianAlpha,</span>
                            jacobianRotationVector);

                    // Qa
<span class="fc" id="L1760">                    final var jacobianOfTheta = new Matrix(N_PARAMS, 1);</span>
                    // Qu
<span class="fc" id="L1762">                    final var jacobianOfAxis = new Matrix(N_PARAMS, N_ANGLES);</span>
<span class="fc" id="L1763">                    result.setFromAxisAndRotation(axis, alpha, jacobianOfTheta, jacobianOfAxis);</span>

                    // Qv = Qa * Av + Qu * Uv
                    // Qa * Av
<span class="fc" id="L1767">                    jacobianOfTheta.multiply(jacobianAlpha);</span>
                    // Qu * Uv
<span class="fc" id="L1769">                    jacobianOfAxis.multiply(jacobianRotationVector);</span>

<span class="fc" id="L1771">                    jacobian.copyFrom(jacobianOfTheta);</span>
<span class="fc" id="L1772">                    jacobian.add(jacobianOfAxis);</span>

<span class="nc" id="L1774">                } catch (final WrongSizeException e) {</span>
<span class="nc" id="L1775">                    throw new IllegalArgumentException(e);</span>
<span class="fc" id="L1776">                }</span>
            }
        }
<span class="fc" id="L1779">    }</span>

    /**
     * Converts a rotation vector (rotation axis having a norm equal to the
     * rotation angle) into a quaternion.
     *
     * @param rotationVector input rotation vector to be converted.
     * @param result         quaternion where result will be stored.
     * @throws IllegalArgumentException if provided rotation vector is not
     *                                  length 3.
     * @see &lt;a href=&quot;https://github.com/joansola/slamtb&quot;&gt;v2q.m at https://github.com/joansola/slamtb&lt;/a&gt;
     */
    public static void rotationVectorToQuaternion(final double[] rotationVector, final Quaternion result) {
<span class="fc" id="L1792">        rotationVectorToQuaternion(rotationVector, result, null);</span>
<span class="fc" id="L1793">    }</span>

    /**
     * Sets values of this quaternion from provided rotation vector.
     * A rotation vector is a rotation axis having a norm equal to the rotation
     * angle.
     *
     * @param rotationVector input rotation vector to obtain quaternion values
     *                       from.
     * @throws IllegalArgumentException if provided rotation vector does not
     *                                  have length 3.
     * @see &lt;a href=&quot;https://github.com/joansola/slamtb&quot;&gt;v2q.m at https://github.com/joansola/slamtb&lt;/a&gt;
     */
    public void setFromRotationVector(final double[] rotationVector) {
<span class="fc" id="L1807">        rotationVectorToQuaternion(rotationVector, this);</span>
<span class="fc" id="L1808">    }</span>

    /**
     * Converts a rotation vector into a rotation matrix.
     * A rotation vector is a rotation axis having a norm equal to the rotation
     * angle.
     *
     * @param rotationVector a rotation vector to be converted into a 3D matrix
     *                       rotation.
     * @param result         matrix where result is stored.
     * @throws IllegalArgumentException if provided rotation vector does not
     *                                  have length 3.
     * @see &lt;a href=&quot;https://github.com/joansola/slamtb&quot;&gt;v2R.m at https://github.com/joansola/slamtb&lt;/a&gt;
     */
    public static void rotationVectorToMatrixRotation(final double[] rotationVector, final Matrix result) {
<span class="fc" id="L1823">        final var axis = new double[AxisRotation3D.AXIS_PARAMS];</span>
<span class="fc" id="L1824">        final var alpha = rotationVectorToRotationAxisAndAngle(rotationVector, axis);</span>
<span class="fc" id="L1825">        final var r = new AxisRotation3D(axis, alpha);</span>
<span class="fc" id="L1826">        r.asInhomogeneousMatrix(result);</span>
<span class="fc" id="L1827">    }</span>

    /**
     * Converts a rotation vector into a rotation matrix.
     * A rotation vector is a rotation axis having a norm equal to the rotation
     * angle.
     *
     * @param rotationVector a rotation vector to be converted into a 3D matrix
     *                       rotation.
     * @param result         3D matrix rotation where result is stored.
     * @throws IllegalArgumentException if provided rotation vector does not
     *                                  have length 3.
     * @see &lt;a href=&quot;https://github.com/joansola/slamtb&quot;&gt;v2R.m at https://github.com/joansola/slamtb&lt;/a&gt;
     */
    public static void rotationVectorToMatrixRotation(final double[] rotationVector, final MatrixRotation3D result) {
<span class="fc" id="L1842">        rotationVectorToMatrixRotation(rotationVector, result.internalMatrix);</span>
<span class="fc" id="L1843">    }</span>

    /**
     * Returns type of this rotation.
     *
     * @return Type of this rotation.
     */
    @Override
    public Rotation3DType getType() {
<span class="fc" id="L1852">        return Rotation3DType.QUATERNION;</span>
    }

    /**
     * Sets the axis and rotation of this instance.
     * Once set, points will rotate around provided axis an amount equal to
     * provided rotation angle in radians.
     * Note: to avoid numerical instabilities and improve accuracy, axis
     * coordinates should be normalized (e.g. norm equal to 1).
     *
     * @param axisX X coordinate of rotation axis.
     * @param axisY Y coordinate of rotation axis.
     * @param axisZ Z coordinate of rotation axis.
     * @param theta Amount of rotation in radians.
     */
    @Override
    public void setAxisAndRotation(
            final double axisX, final double axisY, final double axisZ, final double theta) {
<span class="fc" id="L1870">        setFromAxisAndRotation(axisX, axisY, axisZ, theta);</span>
<span class="fc" id="L1871">    }</span>

    /**
     * Returns rotation axis corresponding to this instance.
     * Result is stored in provided axis array, which must have length 3.
     *
     * @param axis Array where axis coordinates will be stored.
     * @throws IllegalArgumentException Raised if provided array does not have
     *                                  length 3.
     */
    @Override
    public void rotationAxis(final double[] axis) {
<span class="fc" id="L1883">        toAxisAndRotationAngle(axis);</span>
<span class="fc" id="L1884">    }</span>

    /**
     * Returns rotation amount or angle in radians around the rotation axis
     * associated to this instance.
     *
     * @return Rotation angle in radians.
     */
    @Override
    public double getRotationAngle() {
        // norm of rotation axis
<span class="fc" id="L1895">        final var n = Math.sqrt(b * b + c * c + d * d);</span>
<span class="fc" id="L1896">        return 2.0 * Math.atan2(n, a);</span>
    }

    /**
     * Returns this 3D rotation instance expressed as a 3x3 inhomogeneous
     * matrix.
     * This is equivalent to call getInternalMatrix().
     *
     * @return Rotation matrix expressed in inhomogeneous coordinates.
     */
    @Override
    public Matrix asInhomogeneousMatrix() {
<span class="fc" id="L1908">        Matrix m = null;</span>
        try {
<span class="fc" id="L1910">            m = new Matrix(MatrixRotation3D.ROTATION3D_INHOM_MATRIX_ROWS,</span>
                    MatrixRotation3D.ROTATION3D_INHOM_MATRIX_COLS);
<span class="fc" id="L1912">            toMatrixRotation(m);</span>
<span class="nc" id="L1913">        } catch (final WrongSizeException ignore) {</span>
            // never thrown
<span class="fc" id="L1915">        }</span>
<span class="fc" id="L1916">        return m;</span>
    }

    /**
     * Sets into provided Matrix instance this 3D rotation expressed as a
     * 3x3 inhomogeneous matrix.
     *
     * @param result Matrix where rotation will be set.
     * @throws IllegalArgumentException Raised if provided instance does not
     *                                  have size 3x3.
     */
    @Override
    public void asInhomogeneousMatrix(final Matrix result) {
<span class="fc" id="L1929">        toMatrixRotation(result);</span>
<span class="fc" id="L1930">    }</span>

    /**
     * Returns this 3D rotation instance expressed as a 4x4 homogeneous matrix.
     *
     * @return Rotation matrix expressed in homogeneous coordinates.
     */
    @Override
    public Matrix asHomogeneousMatrix() {
<span class="fc" id="L1939">        Matrix m = null;</span>
        try {
<span class="fc" id="L1941">            m = new Matrix(HOM_COORDS, HOM_COORDS);</span>
<span class="fc" id="L1942">            asHomogeneousMatrix(m);</span>
<span class="nc" id="L1943">        } catch (final WrongSizeException ignore) {</span>
            // never thrown
<span class="fc" id="L1945">        }</span>
<span class="fc" id="L1946">        return m;</span>
    }

    /**
     * Sets into provided Matrix instance this 3D rotation expressed as a
     * 4x4 homogeneous matrix.
     *
     * @param result Matrix where rotation will be set.
     * @throws IllegalArgumentException Raised if provided instance does not
     *                                  have size 4x4.
     */
    @Override
    public void asHomogeneousMatrix(final Matrix result) {
<span class="fc" id="L1959">        result.initialize(0.0);</span>
<span class="fc" id="L1960">        result.setElementAt(HOM_COORDS - 1, HOM_COORDS - 1, 1.0);</span>
<span class="fc" id="L1961">        result.setSubmatrix(0, 0, INHOM_COORDS - 1,</span>
<span class="fc" id="L1962">                INHOM_COORDS - 1, asInhomogeneousMatrix());</span>
<span class="fc" id="L1963">    }</span>

    /**
     * Sets amount of rotation from provided inhomogeneous rotation matrix.
     * Provided matrix must be orthogonal (i.e. squared, non-singular, it's
     * transpose must be its inverse) and must have determinant equal to 1.
     * Provided matrix must also have size 3x3.
     *
     * @param m         Provided rotation matrix.
     * @param threshold Threshold to determine whether matrix is orthonormal.
     * @throws IllegalArgumentException Raised if provided threshold is
     *                                  negative.
     *                                  {@link #isValidRotationMatrix(Matrix)}
     */
    @Override
    public void fromInhomogeneousMatrix(final Matrix m, final double threshold) {
<span class="fc" id="L1979">        setFromMatrixRotation(m);</span>
<span class="fc" id="L1980">    }</span>

    /**
     * Sets amount of rotation from provided homogeneous rotation matrix.
     * Provided matrix must be orthogonal (i.e. squared, non-singular, it's
     * transpose must be its inverse) and must have determinant equal to 1.
     * Provided matrix must also have size 4x4, and its last row and column must
     * be zero, except for element in last row and column which must be 1.
     *
     * @param m         Provided rotation matrix.
     * @param threshold Threshold to determine whether matrix is orthonormal.
     * @throws IllegalArgumentException Raised if provided threshold is
     *                                  negative.
     *                                  {@link #isValidRotationMatrix(Matrix)}
     */
    @Override
    public void fromHomogeneousMatrix(final Matrix m, final double threshold) {
<span class="fc" id="L1997">        setFromMatrixRotation(m.getSubmatrix(0, 0, INHOM_COORDS - 1,</span>
                INHOM_COORDS - 1));
<span class="fc" id="L1999">    }</span>

    /**
     * Inverts a quaternion so that q * q^-1 = 1.
     *
     * @param q      quaternion to be inverted.
     * @param result quaternion instance where the result will be stored.
     */
    public static void inverse(final Quaternion q, final Quaternion result) {
        // the inverse is the conjugate divided by the quaternion square norm
<span class="fc" id="L2009">        final var sqrNorm = q.a * q.a + q.b * q.b + q.c * q.c + q.d * q.d;</span>
<span class="fc" id="L2010">        q.conjugate(result);</span>
<span class="fc" id="L2011">        result.a /= sqrNorm;</span>
<span class="fc" id="L2012">        result.b /= sqrNorm;</span>
<span class="fc" id="L2013">        result.c /= sqrNorm;</span>
<span class="fc" id="L2014">        result.d /= sqrNorm;</span>
<span class="fc" id="L2015">        result.normalized = false;</span>
<span class="fc" id="L2016">    }</span>

    /**
     * Inverts a quaternion so that q * q^-1 = 1.
     *
     * @param q quaternion to be inverted.
     * @return a new quaternion containing the inverse.
     */
    public static Quaternion inverseAndReturnNew(final Quaternion q) {
<span class="fc" id="L2025">        final var result = new Quaternion();</span>
<span class="fc" id="L2026">        inverse(q, result);</span>
<span class="fc" id="L2027">        return result;</span>
    }

    /**
     * Inverts this quaternion instance so that q * q^-1 = 1.
     *
     * @param result instance where quaternion inverse is stored.
     */
    public void inverse(final Quaternion result) {
<span class="fc" id="L2036">        inverse(this, result);</span>
<span class="fc" id="L2037">    }</span>

    /**
     * Inverts this quaternion instance so that q * q^-1 = 1.
     *
     * @return a new quaternion containing the inverse of this quaternion.
     */
    public Quaternion inverseAndReturnNew() {
<span class="fc" id="L2045">        final var result = new Quaternion();</span>
<span class="fc" id="L2046">        inverse(result);</span>
<span class="fc" id="L2047">        return result;</span>
    }

    /**
     * Inverts this quaternion.
     */
    public void inverse() {
<span class="fc" id="L2054">        inverse(this);</span>
<span class="fc" id="L2055">    }</span>

    /**
     * Returns a 3D rotation which is inverse to this instance.
     * In other words, the combination of this rotation with its inverse
     * produces no change.
     *
     * @return Inverse 3D rotation.
     */
    @Override
    public Rotation3D inverseRotationAndReturnNew() {
<span class="fc" id="L2066">        final var q = new Quaternion();</span>
<span class="fc" id="L2067">        inverseRotation(q);</span>
<span class="fc" id="L2068">        return q;</span>
    }

    /**
     * Inverts this quaternion instance so that q * q^-1 = 1.
     *
     * @param result instance where quaternion inverse is stored.
     */
    public void inverseRotation(final Quaternion result) {
<span class="fc" id="L2077">        inverse(result);</span>
<span class="fc" id="L2078">    }</span>

    /**
     * Sets into provided Rotation3D instance a rotation inverse to this
     * instance.
     * The combination of this rotation with its inverse produces no change.
     *
     * @param result Instance where inverse rotation will be set.
     */
    @Override
    public void inverseRotation(final Rotation3D result) {
<span class="fc" id="L2089">        final var inverse = inverseAndReturnNew();</span>
<span class="fc" id="L2090">        result.fromRotation(inverse);</span>
<span class="fc" id="L2091">    }</span>

    /**
     * Reverses the rotation of this instance.
     */
    @Override
    public void inverseRotation() {
<span class="fc" id="L2098">        inverse();</span>
<span class="fc" id="L2099">    }</span>

    /**
     * Combines provided quaternions q1 and q2 to produce a resulting quaternion
     * equivalent to the combined rotation of both quaternions.
     *
     * @param q1     1st quaternion.
     * @param q2     2nd quaternion.
     * @param result combined quaternion where result is stored.
     */
    public static void combine(final Quaternion q1, final Quaternion q2, final Quaternion result) {
<span class="fc" id="L2110">        product(q1, q2, result);</span>
<span class="fc" id="L2111">    }</span>

    /**
     * Combines provided quaternion with this quaternion and returns the result
     * as a new quaternion instance.
     *
     * @param q input quaternion to be combined.
     * @return combined quaternion, which is equal to the multiplication of
     * quaternions.
     */
    public Quaternion combineAndReturnNew(final Quaternion q) {
<span class="fc" id="L2122">        final var result = new Quaternion();</span>
<span class="fc" id="L2123">        combine(this, q, result);</span>
<span class="fc" id="L2124">        return result;</span>
    }

    /**
     * Combines provided quaternion into this quaternion, resulting in the
     * multiplication of both quaternion representations.
     *
     * @param q input quaternion to be combined.
     */
    public void combine(final Quaternion q) {
<span class="fc" id="L2134">        combine(this, q, this);</span>
<span class="fc" id="L2135">    }</span>

    /**
     * Combines provided rotation with this quaternion and returns the result as
     * a new quaternion instance.
     *
     * @param rotation input rotation to be combined.
     * @return combined rotation, which is equal to the multiplication of the
     * internal quaternion representations.
     */
    @Override
    public Rotation3D combineAndReturnNew(final Rotation3D rotation) {
<span class="fc" id="L2147">        return combineAndReturnNew(rotation.toQuaternion());</span>
    }

    /**
     * Combines provided rotation into this quaternion, resulting in the
     * multiplication of both quaternion representations.
     *
     * @param rotation input rotation to be combined.
     */
    @Override
    public void combine(final Rotation3D rotation) {
<span class="fc" id="L2158">        combine(rotation.toQuaternion());</span>
<span class="fc" id="L2159">    }</span>

    /**
     * Sets values of this rotation from a 3D matrix rotation.
     *
     * @param rot 3D matrix rotation to set values from.
     */
    @Override
    public void fromRotation(final MatrixRotation3D rot) {
<span class="fc" id="L2168">        setFromMatrixRotation(rot);</span>
<span class="fc" id="L2169">    }</span>

    /**
     * Sets values of this rotation from a 3D axis rotation.
     *
     * @param rot an axis rotation to set values from.
     */
    @Override
    public void fromRotation(final AxisRotation3D rot) {
<span class="fc" id="L2178">        setFromAxisAndRotation(rot);</span>
<span class="fc" id="L2179">    }</span>

    /**
     * Sets values of this rotation from a quaternion.
     *
     * @param q a quaternion to set values from.
     */
    @Override
    public void fromRotation(final Quaternion q) {
<span class="fc" id="L2188">        a = q.a;</span>
<span class="fc" id="L2189">        b = q.b;</span>
<span class="fc" id="L2190">        c = q.c;</span>
<span class="fc" id="L2191">        d = q.d;</span>
<span class="fc" id="L2192">        normalized = q.normalized;</span>
<span class="fc" id="L2193">    }</span>

    /**
     * Converts this 3D rotation into a quaternion storing the result into
     * provided instance.
     *
     * @param result instance where result will be stored.
     */
    @Override
    public void toQuaternion(final Quaternion result) {
<span class="fc" id="L2203">        result.fromQuaternion(this);</span>
<span class="fc" id="L2204">    }</span>

    /**
     * Indicates whether quaternion is already normalized or not.
     *
     * @return true if quaternion is normalized, false otherwise.
     */
    public boolean isNormalized() {
<span class="fc" id="L2212">        return normalized;</span>
    }

    /**
     * Normalizes this quaternion if not already normalized.
     */
    public void normalize() {
<span class="fc bfc" id="L2219" title="All 2 branches covered.">        if (!normalized) {</span>
<span class="fc" id="L2220">            final var norm = Math.sqrt(a * a + b * b + c * c + d * d);</span>
<span class="fc" id="L2221">            internalNormalize(norm);</span>
        }
<span class="fc" id="L2223">    }</span>

    /**
     * Normalizes this quaternion if not already normalized and stores the
     * corresponding jacobian into provided matrix (if provided).
     *
     * @param jacobian matrix where jacobian will be stored (if provided). Must
     *                 be 4x4.
     * @throws IllegalArgumentException if provided jacobian is not 4x4.
     */
    public void normalize(final Matrix jacobian) {
<span class="pc bpc" id="L2234" title="2 of 6 branches missed.">        if (jacobian != null &amp;&amp; (jacobian.getRows() != N_PARAMS || jacobian.getColumns() != N_PARAMS)) {</span>
<span class="fc" id="L2235">            throw new IllegalArgumentException(&quot;jacobian must be 4x4&quot;);</span>
        }

<span class="fc" id="L2238">        final var aValue = this.a;</span>
<span class="fc" id="L2239">        final var bValue = this.b;</span>
<span class="fc" id="L2240">        final var cValue = this.c;</span>
<span class="fc" id="L2241">        final var dValue = this.d;</span>
<span class="fc" id="L2242">        final var norm = Math.sqrt(aValue * aValue + bValue * bValue + cValue * cValue + dValue * dValue);</span>

<span class="fc" id="L2244">        internalNormalize(norm);</span>

<span class="pc bpc" id="L2246" title="1 of 2 branches missed.">        if (jacobian != null) {</span>
<span class="fc" id="L2247">            final var norm3 = norm * norm * norm;</span>

<span class="fc" id="L2249">            jacobian.setElementAt(0, 0, (bValue * bValue + cValue * cValue + dValue * dValue)</span>
                    / norm3);
<span class="fc" id="L2251">            jacobian.setElementAt(1, 0, -aValue / norm3 * bValue);</span>
<span class="fc" id="L2252">            jacobian.setElementAt(2, 0, -aValue / norm3 * cValue);</span>
<span class="fc" id="L2253">            jacobian.setElementAt(3, 0, -aValue / norm3 * dValue);</span>

<span class="fc" id="L2255">            jacobian.setElementAt(0, 1, -aValue / norm3 * bValue);</span>
<span class="fc" id="L2256">            jacobian.setElementAt(1, 1, (aValue * aValue + cValue * cValue + dValue * dValue)</span>
                    / norm3);
<span class="fc" id="L2258">            jacobian.setElementAt(2, 1, -bValue / norm3 * cValue);</span>
<span class="fc" id="L2259">            jacobian.setElementAt(3, 1, -bValue / norm3 * dValue);</span>

<span class="fc" id="L2261">            jacobian.setElementAt(0, 2, -aValue / norm3 * cValue);</span>
<span class="fc" id="L2262">            jacobian.setElementAt(1, 2, -bValue / norm3 * cValue);</span>
<span class="fc" id="L2263">            jacobian.setElementAt(2, 2, (aValue * aValue + bValue * bValue + dValue * dValue)</span>
                    / norm3);
<span class="fc" id="L2265">            jacobian.setElementAt(3, 2, -cValue / norm3 * dValue);</span>

<span class="fc" id="L2267">            jacobian.setElementAt(0, 3, -aValue / norm3 * dValue);</span>
<span class="fc" id="L2268">            jacobian.setElementAt(1, 3, -bValue / norm3 * dValue);</span>
<span class="fc" id="L2269">            jacobian.setElementAt(2, 3, -cValue / norm3 * dValue);</span>
<span class="fc" id="L2270">            jacobian.setElementAt(3, 3, (aValue * aValue + bValue * bValue + cValue * cValue)</span>
                    / norm3);
        }
<span class="fc" id="L2273">    }</span>

    /**
     * Computes a linear interpolation between this quaternion and provided quaternion using
     * provided value as the interpolation ratio.
     *
     * @param q quaternion to interpolate.
     * @param t interpolation ratio. Must be a value between 0.0 and 1.0, both
     *          included. The closer the value is to 0.0, the more similar result will
     *          be to this instance. Conversely, the closer the value is to 1.0, the
     *          more similar result will be to q.
     * @return a new interpolated quaternion instance.
     * @throws IllegalArgumentException if provided interpolation ratio is not between 0.0
     *                                  and 1.0, both included.
     */
    public Quaternion slerpAndReturnNew(final Quaternion q, final double t) {
<span class="fc" id="L2289">        final var result = new Quaternion();</span>
<span class="fc" id="L2290">        slerp(q, t, result);</span>
<span class="fc" id="L2291">        return result;</span>
    }

    /**
     * Computes a linear interpolation between this quaternion and provided quaternion using
     * provided value as the interpolation ratio and stores the result into provided result
     * quaternion.
     *
     * @param q      quaternion to interpolate.
     * @param t      interpolation ratio. Must be a value between 0.0 and 1.0, both
     *               included. The closer the value is to 0.0, the more similar result will
     *               be to this instance. Conversely, the closer the value is to 1.0, the
     *               more similar result will be to q.
     * @param result instance where interpolated quaternion will be stored.
     * @throws IllegalArgumentException if provided interpolation ratio is not between 0.0
     *                                  and 1.0, both included.
     */
    public void slerp(final Quaternion q, final double t, final Quaternion result) {
<span class="fc" id="L2309">        slerp(this, q, t, result);</span>
<span class="fc" id="L2310">    }</span>

    /**
     * Computes a linear interpolation between provided quaternions using provided value
     * as the interpolation ratio.
     *
     * @param q1 1st quaternion to interpolate.
     * @param q2 2nd quaternion to interpolate.
     * @param t  interpolation ratio. Must be a value between 0.0 and 1.0, both
     *           included. The closer the value is to 0.0, the more similar result will
     *           be to q1. Conversely, the closer the value is to 1.0, the more similar
     *           result will be to q2.
     * @return a new interpolated quaternion instance.
     * @throws IllegalArgumentException if provided interpolation ratio is not between 0.0
     *                                  and 1.0, both included.
     */
    public static Quaternion slerpAndReturnNew(final Quaternion q1, final Quaternion q2, final double t) {
<span class="fc" id="L2327">        final var result = new Quaternion();</span>
<span class="fc" id="L2328">        slerp(q1, q2, t, result);</span>
<span class="fc" id="L2329">        return result;</span>
    }

    /**
     * Computes a linear interpolation between provided quaternions using provided value
     * as the interpolation ratio, and stores the result into provided result quaternion.
     *
     * @param q1     1st quaternion to interpolate.
     * @param q2     2nd quaternion to interpolate.
     * @param t      interpolation ratio. Must be a value between 0.0 and 1.0, both
     *               included. The closer the value is to 0.0, the more similar result will
     *               be to q1. Conversely, the closer the value is to 1.0, the more similar
     *               result will be to q2.
     * @param result instance where interpolated quaternion will be stored.
     * @throws IllegalArgumentException if provided interpolation ratio is not between 0.0
     *                                  and 1.0, both included.
     */
    public static void slerp(final Quaternion q1, final Quaternion q2, final double t, final Quaternion result) {
<span class="fc bfc" id="L2347" title="All 4 branches covered.">        if (t &lt; 0.0 || t &gt; 1.0) {</span>
<span class="fc" id="L2348">            throw new IllegalArgumentException();</span>
        }

        // only unit quaternions are valid rotations.
        // normalize to avoid undefined behavior.
<span class="fc" id="L2353">        q1.normalize();</span>
<span class="fc" id="L2354">        q2.normalize();</span>

        // calculate angle between input quaternions
<span class="fc" id="L2357">        var dot = q1.a * q2.a + q1.b * q2.b + q1.c * q2.c + q1.d * q2.d;</span>

        // if q1 = q2 or q1 = -q2 (both quaternions are equal), then the angle
        // between input quaternions is theta0 = 0.
        // To avoid singularity caused by sinTheta0, we return q1
<span class="fc bfc" id="L2362" title="All 2 branches covered.">        if (Math.abs(dot) &gt;= 1.0) {</span>
<span class="fc" id="L2363">            result.a = q1.a;</span>
<span class="fc" id="L2364">            result.b = q1.b;</span>
<span class="fc" id="L2365">            result.c = q1.c;</span>
<span class="fc" id="L2366">            result.d = q1.d;</span>
<span class="fc" id="L2367">            return;</span>
        }

        // if the dot product is negative, slerp won't take the shorter path.
        // note that q2 and -q2 are equivalent when the negation is applied to all four
        // components. Fix by reversing one quaternion.
        Quaternion q2b;
<span class="pc bpc" id="L2374" title="1 of 2 branches missed.">        if (dot &lt; 0.0) {</span>
<span class="nc" id="L2375">            q2b = new Quaternion(-q2.a, -q2.b, -q2.c, -q2.d);</span>
<span class="nc" id="L2376">            dot = -dot;</span>
        } else {
<span class="fc" id="L2378">            q2b = q2;</span>
        }

<span class="fc" id="L2381">        final var theta0 = Math.acos(dot);</span>
<span class="fc" id="L2382">        final var theta = theta0 * t;</span>
<span class="fc" id="L2383">        final var sinTheta = Math.sin(theta);</span>
<span class="fc" id="L2384">        final var sinTheta0 = Math.sin(theta0);</span>

<span class="fc" id="L2386">        final var s2 = sinTheta / sinTheta0;</span>
        // line below is equal to sin(theta0 - theta) / sinTheta0
<span class="fc" id="L2388">        final var s1 = Math.cos(theta) - dot * s2;</span>

<span class="fc" id="L2390">        result.a = s1 * q1.a + s2 * q2b.a;</span>
<span class="fc" id="L2391">        result.b = s1 * q1.b + s2 * q2b.b;</span>
<span class="fc" id="L2392">        result.c = s1 * q1.c + s2 * q2b.c;</span>
<span class="fc" id="L2393">        result.d = s1 * q1.d + s2 * q2b.d;</span>
<span class="fc" id="L2394">    }</span>

    /**
     * Normalizes this quaternion if not already normalized.
     *
     * @param norm norm to normalize this quaternion with.
     */
    private void internalNormalize(final double norm) {
<span class="pc bpc" id="L2402" title="1 of 2 branches missed.">        if (!normalized) {</span>
<span class="fc" id="L2403">            a /= norm;</span>
<span class="fc" id="L2404">            b /= norm;</span>
<span class="fc" id="L2405">            c /= norm;</span>
<span class="fc" id="L2406">            d /= norm;</span>
<span class="fc" id="L2407">            normalized = true;</span>
        }
<span class="fc" id="L2409">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>