<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Rotation2D.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-geometry</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.geometry</a> &gt; <span class="el_source">Rotation2D.java</span></div><h1>Rotation2D.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2012 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.geometry;

import com.irurueta.algebra.AlgebraException;
import com.irurueta.algebra.Matrix;
import com.irurueta.algebra.Utils;
import com.irurueta.algebra.WrongSizeException;

import java.io.Serializable;
import java.util.Objects;

/**
 * This class defines the amount of rotation for 2D points or lines.
 */
@SuppressWarnings(&quot;DuplicatedCode&quot;)
public class Rotation2D implements Serializable {

    /**
     * Constant defining the number of rows on a 2D rotation matrix expressed
     * in inhomogeneous coordinates.
     */
    public static final int ROTATION2D_INHOM_MATRIX_ROWS = 2;

    /**
     * Constant defining the number of columns on a 2D rotation matrix expressed
     * in inhomogeneous coordinates.
     */
    public static final int ROTATION2D_INHOM_MATRIX_COLS = 2;

    /**
     * Constant defining the number of rows on a 2D rotation matrix expressed
     * in homogeneous coordinates.
     */
    public static final int ROTATION2D_HOM_MATRIX_ROWS = 3;

    /**
     * Constant defining the number of columns on a 2D rotation matrix expressed
     * in homogeneous coordinates.
     */
    public static final int ROTATION2D_HOM_MATRIX_COLS = 3;

    /**
     * Constant defining threshold to determine whether a matrix is orthogonal
     * or not and has determinant equal to 1. Rotation matrices must fulfill
     * those requirements.
     */
    public static final double MATRIX_VALID_THRESHOLD = 1e-9;

    /**
     * Constant defining minimum allowed threshold.
     */
    public static final double MIN_THRESHOLD = 0.0;

    /**
     * Default threshold to determine if two instances are equal.
     */
    public static final double DEFAULT_COMPARISON_THRESHOLD = 1e-9;

    /**
     * Constant defining minimum allowed comparison threshold.
     */
    public static final double MIN_COMPARISON_THRESHOLD = 0.0;

    /**
     * Private member containing amount of rotation expressed in radians.
     */
    private double theta;

    /**
     * Empty Constructor.
     * Initializes rotation to zero radians.
     */
<span class="fc" id="L87">    public Rotation2D() {</span>
<span class="fc" id="L88">        theta = 0.0;</span>
<span class="fc" id="L89">    }</span>

    /**
     * Copy constructor.
     * Copies provided rotation into this instance.
     *
     * @param rotation Instance to be copied.
     */
<span class="fc" id="L97">    public Rotation2D(final Rotation2D rotation) {</span>
<span class="fc" id="L98">        theta = rotation.theta;</span>
<span class="fc" id="L99">    }</span>

    /**
     * Constructor.
     * Creates a 2D rotation using provided matrix.
     * Provided matrix can be expressed in either homogeneous or inhomogeneous
     * coordinates, and it must also be orthogonal and having determinant equal
     * to 1.
     * The threshold to determine whether provided matrix is orthonormal will
     * be MATRIX_VALID_THRESHOLD.
     *
     * @param m Matrix to create rotation from.
     * @throws InvalidRotationMatrixException Raised if provided matrix is not
     *                                        valid (its size is wrong, or it is not orthonormal).
     * @see #isValidRotationMatrix(Matrix)
     */
<span class="fc" id="L115">    public Rotation2D(final Matrix m) throws InvalidRotationMatrixException {</span>
<span class="fc" id="L116">        fromMatrix(m);</span>
<span class="fc" id="L117">    }</span>

    /**
     * Constructor.
     * Creates a 2D rotation using provided matrix.
     * Provided matrix can be expressed in either homogeneous or inhomogeneous
     * coordinates, and it must also be orthogonal up to provided threshold, and
     * must have determinant equal to 1.
     *
     * @param m         Matrix to create rotation from.
     * @param threshold Threshold to determine whether matrix is orthonormal.
     * @throws InvalidRotationMatrixException Raised if provided matrix is not
     *                                        valid (its size is wrong, or it is not orthonormal).
     * @throws IllegalArgumentException       Raised if provided threshold is negative
     * @see #isValidRotationMatrix(Matrix)
     */
<span class="fc" id="L133">    public Rotation2D(final Matrix m, final double threshold) throws InvalidRotationMatrixException {</span>
<span class="fc" id="L134">        fromMatrix(m, threshold);</span>
<span class="fc" id="L135">    }</span>

    /**
     * Constructor.
     * Creates a 2D rotation using provided rotation value expressed in radians
     *
     * @param theta Rotation amount expressed in radians.
     */
<span class="fc" id="L143">    public Rotation2D(final double theta) {</span>
<span class="fc" id="L144">        this.theta = theta;</span>
<span class="fc" id="L145">    }</span>

    /**
     * Returns rotation amount expressed in radians.
     *
     * @return Rotation amount expressed in radians.
     */
    public double getTheta() {
<span class="fc" id="L153">        return theta;</span>
    }

    /**
     * Sets rotation amount expressed in radians.
     *
     * @param theta rotation angle.
     */
    public void setTheta(final double theta) {
<span class="fc" id="L162">        this.theta = theta;</span>
<span class="fc" id="L163">    }</span>

    /**
     * Returns a 2D rotation which is inverse to this instance.
     * In other words, the combination of this rotation with its inverse
     * produces no change.
     *
     * @return Inverse 2D rotation.
     */
    public Rotation2D inverseRotation() {
<span class="fc" id="L173">        final var result = new Rotation2D();</span>
<span class="fc" id="L174">        inverseRotation(result);</span>
<span class="fc" id="L175">        return result;</span>
    }

    /**
     * Sets into provided Rotation2D instance a rotation inverse to this
     * instance.
     * The combination of this rotation with its inverse produces no change.
     *
     * @param result Instance where inverse rotation will be set.
     */
    public void inverseRotation(final Rotation2D result) {
<span class="fc" id="L186">        result.setTheta(-theta);</span>
<span class="fc" id="L187">    }</span>

    /**
     * Returns this 2D rotation instance expressed as a 2x2 inhomogeneous matrix.
     *
     * @return Rotation matrix expressed in inhomogeneous coordinates.
     */
    public Matrix asInhomogeneousMatrix() {
<span class="fc" id="L195">        Matrix result = null;</span>
        try {
<span class="fc" id="L197">            result = new Matrix(ROTATION2D_INHOM_MATRIX_ROWS, ROTATION2D_INHOM_MATRIX_COLS);</span>
<span class="fc" id="L198">            asInhomogeneousMatrix(result);</span>
<span class="nc" id="L199">        } catch (final WrongSizeException ignore) {</span>
            // never happens
<span class="fc" id="L201">        }</span>
<span class="fc" id="L202">        return result;</span>
    }

    /**
     * Sets into provided Matrix instance this 2D rotation expressed as a
     * 2x2 inhomogeneous matrix.
     *
     * @param result Matrix where rotation will be set.
     * @throws IllegalArgumentException Raised if provided instance does not
     *                                  have size 2x2.
     */
    public void asInhomogeneousMatrix(final Matrix result) {
<span class="pc bpc" id="L214" title="1 of 4 branches missed.">        if (result.getRows() != ROTATION2D_INHOM_MATRIX_ROWS || result.getColumns() != ROTATION2D_INHOM_MATRIX_COLS) {</span>
<span class="fc" id="L215">            throw new IllegalArgumentException();</span>
        }

        // set result
<span class="fc" id="L219">        final var sinTheta = Math.sin(theta);</span>
<span class="fc" id="L220">        final var cosTheta = Math.cos(theta);</span>
<span class="fc" id="L221">        result.setElementAt(0, 0, cosTheta);</span>
<span class="fc" id="L222">        result.setElementAt(1, 0, sinTheta);</span>
<span class="fc" id="L223">        result.setElementAt(0, 1, -sinTheta);</span>
<span class="fc" id="L224">        result.setElementAt(1, 1, cosTheta);</span>
<span class="fc" id="L225">    }</span>

    /**
     * Returns this 2D rotation instance expressed as a 3x3 homogeneous matrix.
     *
     * @return Rotation matrix expressed in homogeneous coordinates.
     */
    public Matrix asHomogeneousMatrix() {
<span class="fc" id="L233">        Matrix result = null;</span>
        try {
<span class="fc" id="L235">            result = new Matrix(ROTATION2D_HOM_MATRIX_ROWS, ROTATION2D_HOM_MATRIX_COLS);</span>
<span class="fc" id="L236">            asHomogeneousMatrix(result);</span>
<span class="nc" id="L237">        } catch (final WrongSizeException ignore) {</span>
            // never happens
<span class="fc" id="L239">        }</span>
<span class="fc" id="L240">        return result;</span>
    }

    /**
     * Sets into provided Matrix instance this 2D rotation expressed as a
     * 3x3 homogeneous matrix.
     *
     * @param result Matrix where rotation will be set.
     * @throws IllegalArgumentException Raised if provided instance does not
     *                                  have size 3x3.
     */
    public void asHomogeneousMatrix(final Matrix result) {
<span class="pc bpc" id="L252" title="1 of 4 branches missed.">        if (result.getRows() != ROTATION2D_HOM_MATRIX_ROWS || result.getColumns() != ROTATION2D_HOM_MATRIX_COLS) {</span>
<span class="fc" id="L253">            throw new IllegalArgumentException();</span>
        }

        // set result
<span class="fc" id="L257">        final var sinTheta = Math.sin(theta);</span>
<span class="fc" id="L258">        final var cosTheta = Math.cos(theta);</span>
<span class="fc" id="L259">        result.setElementAt(0, 0, cosTheta);</span>
<span class="fc" id="L260">        result.setElementAt(1, 0, sinTheta);</span>
<span class="fc" id="L261">        result.setElementAt(2, 0, 0.0);</span>
<span class="fc" id="L262">        result.setElementAt(0, 1, -sinTheta);</span>
<span class="fc" id="L263">        result.setElementAt(1, 1, cosTheta);</span>
<span class="fc" id="L264">        result.setElementAt(2, 1, 0.0);</span>
<span class="fc" id="L265">        result.setElementAt(0, 2, 0.0);</span>
<span class="fc" id="L266">        result.setElementAt(1, 2, 0.0);</span>
<span class="fc" id="L267">        result.setElementAt(2, 2, 1.0);</span>
<span class="fc" id="L268">    }</span>

    /**
     * Sets amount of rotation from provided rotation matrix.
     * Provided matrix must be orthogonal (i.e. squared, non-singular, it's
     * transpose must be its inverse) and must have determinant equal to 1.
     * Provided matrix can be expressed in either inhomogeneous (2x2) or
     * homogeneous (3x3) coordinates.
     *
     * @param m         Provided rotation matrix.
     * @param threshold Threshold to determine whether matrix is orthonormal.
     * @throws InvalidRotationMatrixException Raised if provided matrix is not
     *                                        valid (has wrong size, or it is not orthonormal).
     * @throws IllegalArgumentException       Raised if provided threshold is negative
     * @see #isValidRotationMatrix(Matrix)
     */
    public final void fromMatrix(final Matrix m, final double threshold) throws InvalidRotationMatrixException {
<span class="fc bfc" id="L285" title="All 4 branches covered.">        if (m.getRows() == ROTATION2D_INHOM_MATRIX_ROWS &amp;&amp; m.getColumns() == ROTATION2D_INHOM_MATRIX_COLS) {</span>
            // inhomogeneous matrix
<span class="fc" id="L287">            fromInhomogeneousMatrix(m, threshold);</span>
<span class="pc bpc" id="L288" title="1 of 4 branches missed.">        } else if (m.getRows() == ROTATION2D_HOM_MATRIX_ROWS &amp;&amp; m.getColumns() == ROTATION2D_HOM_MATRIX_COLS) {</span>
            // homogeneous matrix
<span class="fc" id="L290">            fromHomogeneousMatrix(m, threshold);</span>
        } else {
<span class="fc" id="L292">            throw new InvalidRotationMatrixException();</span>
        }
<span class="fc" id="L294">    }</span>

    /**
     * Sets amount of rotation from provided rotation matrix.
     * Provided matrix must be orthogonal (i.e. squared, non-singular, it's
     * transpose must be its inverse) and must have determinant equal to 1.
     * Provided matrix can be expressed in either inhomogeneous (2x2) or
     * homogeneous (3x3) coordinates.
     * Because threshold is not provided it is used MATRIX_VALID_THRESHOLD
     * instead.
     *
     * @param m Provided rotation matrix.
     * @throws InvalidRotationMatrixException Raised if provided matrix is not
     *                                        valid (has wrong size, or it is not orthonormal).
     * @see #isValidRotationMatrix(Matrix)
     */
    public final void fromMatrix(final Matrix m) throws InvalidRotationMatrixException {
<span class="fc" id="L311">        fromMatrix(m, MATRIX_VALID_THRESHOLD);</span>
<span class="fc" id="L312">    }</span>

    /**
     * Sets amount of rotation from provided inhomogeneous rotation matrix.
     * Provided matrix must be orthogonal (i.e. squared, non-singular, it's
     * transpose must be its inverse) and must have determinant equal to 1.
     * Provided matrix must also have size 2x2.
     *
     * @param m         Provided rotation matrix.
     * @param threshold Threshold to determine whether matrix is orthonormal.
     * @throws InvalidRotationMatrixException Raised if provided matrix is not
     *                                        valid (has wrong size, or it is not orthonormal).
     * @throws IllegalArgumentException       Raised if provided threshold is negative.
     * @see #isValidRotationMatrix(Matrix)
     */
    public void fromInhomogeneousMatrix(final Matrix m, final double threshold) throws InvalidRotationMatrixException {
<span class="pc bpc" id="L328" title="1 of 4 branches missed.">        if (m.getRows() != ROTATION2D_INHOM_MATRIX_ROWS || m.getColumns() != ROTATION2D_INHOM_MATRIX_COLS) {</span>
<span class="fc" id="L329">            throw new InvalidRotationMatrixException();</span>
        }
<span class="fc bfc" id="L331" title="All 2 branches covered.">        if (!isValidRotationMatrix(m, threshold)) {</span>
<span class="fc" id="L332">            throw new InvalidRotationMatrixException();</span>
        }

<span class="fc" id="L335">        final var cosTheta = m.getElementAt(0, 0);</span>
<span class="fc" id="L336">        final var sinTheta = m.getElementAt(1, 0);</span>

        // estimated theta will be in the range -pi, pi.
<span class="fc" id="L339">        theta = Math.atan2(sinTheta, cosTheta);</span>
<span class="fc" id="L340">    }</span>

    /**
     * Sets amount of rotation from provided inhomogeneous rotation matrix.
     * Provided matrix must be orthogonal (i.e. squared, non-singular, it's
     * transpose must be its inverse) and must have determinant equal to 1.
     * Provided matrix must also have size 2x2.
     * Because threshold is not provided it is used MATRIX_VALID_THRESHOLD
     * instead.
     *
     * @param m Provided rotation matrix.
     * @throws InvalidRotationMatrixException Raised if provided matrix is not
     *                                        valid (has wrong size, or it is not orthonormal).
     * @see #isValidRotationMatrix(Matrix)
     */
    public void fromInhomogeneousMatrix(final Matrix m) throws InvalidRotationMatrixException {
<span class="fc" id="L356">        fromInhomogeneousMatrix(m, MATRIX_VALID_THRESHOLD);</span>
<span class="fc" id="L357">    }</span>

    /**
     * Sets amount of rotation from provided homogeneous rotation matrix.
     * Provided matrix must be orthogonal (i.e. squared, non-singular, it's
     * transpose must be its inverse) and must have determinant equal to 1.
     * Provided matrix must also have size 3x3, and its last row and column must
     * be zero, except for element in last row and column which must be 1.
     *
     * @param m         Provided rotation matrix.
     * @param threshold Threshold to determine whether matrix is orthonormal.
     * @throws InvalidRotationMatrixException Raised if provided matrix is not
     *                                        valid (has wrong size, or it is not orthonormal).
     * @throws IllegalArgumentException       Raised if provided threshold is negative.
     * @see #isValidRotationMatrix(Matrix)
     */
    public void fromHomogeneousMatrix(final Matrix m, final double threshold) throws InvalidRotationMatrixException {
<span class="pc bpc" id="L374" title="1 of 4 branches missed.">        if (m.getRows() != ROTATION2D_HOM_MATRIX_ROWS || m.getColumns() != ROTATION2D_HOM_MATRIX_COLS) {</span>
<span class="fc" id="L375">            throw new InvalidRotationMatrixException();</span>
        }
<span class="fc bfc" id="L377" title="All 2 branches covered.">        if (!isValidRotationMatrix(m, threshold)) {</span>
<span class="fc" id="L378">            throw new InvalidRotationMatrixException();</span>
        }
<span class="pc bpc" id="L380" title="1 of 2 branches missed.">        if (Math.abs(m.getElementAt(2, 0)) &gt; threshold</span>
<span class="pc bpc" id="L381" title="1 of 2 branches missed.">                || Math.abs(m.getElementAt(2, 1)) &gt; threshold</span>
<span class="pc bpc" id="L382" title="1 of 2 branches missed.">                || Math.abs(m.getElementAt(0, 2)) &gt; threshold</span>
<span class="pc bpc" id="L383" title="1 of 2 branches missed.">                || Math.abs(m.getElementAt(1, 2)) &gt; threshold</span>
<span class="pc bpc" id="L384" title="1 of 2 branches missed.">                || Math.abs(m.getElementAt(2, 2) - 1.0) &gt; threshold) {</span>
<span class="nc" id="L385">            throw new InvalidRotationMatrixException();</span>
        }

<span class="fc" id="L388">        final var cosTheta = m.getElementAt(0, 0);</span>
<span class="fc" id="L389">        final var sinTheta = m.getElementAt(1, 0);</span>

        // estimated theta will be in the range -pi, pi.
<span class="fc" id="L392">        theta = Math.atan2(sinTheta, cosTheta);</span>
<span class="fc" id="L393">    }</span>

    /**
     * Sets amount of rotation from provided homogeneous rotation matrix.
     * Provided matrix must be orthogonal (i.e. squared, non-singular), its
     * transpose must be its inverse and must have determinant equal to 1.
     * Provided matrix must also have size 3x3, and its last row and column must
     * be zero, except for element in last row and column which must be 1
     * Because threshold is not provided it is used MATRIX_VALID_THRESHOLD
     * instead.
     *
     * @param m Provided rotation matrix.
     * @throws InvalidRotationMatrixException Raised if provided matrix is not
     *                                        valid (has wrong size, or it is not orthonormal).
     * @see #isValidRotationMatrix(Matrix)
     */
    public void fromHomogeneousMatrix(final Matrix m) throws InvalidRotationMatrixException {
<span class="fc" id="L410">        fromHomogeneousMatrix(m, MATRIX_VALID_THRESHOLD);</span>
<span class="fc" id="L411">    }</span>

    /**
     * Rotates a 2D point using the origin of coordinates as the axis of
     * rotation.
     * Point will be rotated by the amount of rotation contained in this
     * instance.
     *
     * @param inputPoint  Input point to be rotated.
     * @param resultPoint Rotated point.
     */
    public void rotate(final Point2D inputPoint, final Point2D resultPoint) {
        try {
<span class="fc" id="L424">            final var r = asHomogeneousMatrix();</span>
<span class="fc" id="L425">            final var p = new Matrix(Point2D.POINT2D_HOMOGENEOUS_COORDINATES_LENGTH, 1);</span>

            // to increase accuracy
<span class="fc" id="L428">            inputPoint.normalize();</span>
<span class="fc" id="L429">            p.setElementAt(0, 0, inputPoint.getHomX());</span>
<span class="fc" id="L430">            p.setElementAt(1, 0, inputPoint.getHomY());</span>
<span class="fc" id="L431">            p.setElementAt(2, 0, inputPoint.getHomW());</span>

            // Rotated point below is R * p
<span class="fc" id="L434">            r.multiply(p);</span>

<span class="fc" id="L436">            resultPoint.setHomogeneousCoordinates(r.getElementAt(0, 0), r.getElementAt(1, 0),</span>
<span class="fc" id="L437">                    r.getElementAt(2, 0));</span>
<span class="nc" id="L438">        } catch (final WrongSizeException ignore) {</span>
            // never happens
<span class="fc" id="L440">        }</span>
<span class="fc" id="L441">    }</span>

    /**
     * Returns a 2D point containing a rotated version of provided point.
     * Point will be rotated using the origin of the coordinates as the axis of
     * rotation.
     * Point will be rotated by the amount of rotation contained in this
     * instance.
     *
     * @param point Point to be rotated.
     * @return Rotated point.
     */
    public Point2D rotate(final Point2D point) {
<span class="fc" id="L454">        final var result = new HomogeneousPoint2D();</span>
<span class="fc" id="L455">        rotate(point, result);</span>
<span class="fc" id="L456">        return result;</span>
    }

    /**
     * Rotates a line using the origin of coordinates as the axis of rotation.
     * Line2D will be rotated by the amount of rotation contained in this
     * instance.
     *
     * @param inputLine  Input line to be rotated.
     * @param resultLine Rotated line.
     */
    public void rotate(final Line2D inputLine, final Line2D resultLine) {
        try {
<span class="fc" id="L469">            final var r = asHomogeneousMatrix();</span>
            // because of the duality theorem:
            // l'*m = 0 --&gt; l*R^-1*R*m = 0 --&gt; l2' = l'*R^-1 and m2 = R*m
            // where l2 and m2 are rotated line and point, however rotated
            // line uses the inverse rotation, which is the transposed matrix
            // Hence l2' = l' * R', and by undoing the transposition
            // l2 = (l' * R')' = R'' * l'' = R * l

<span class="fc" id="L477">            final var l = new Matrix(Line2D.LINE_NUMBER_PARAMS, 1);</span>

            // to increase accuracy
<span class="fc" id="L480">            inputLine.normalize();</span>
<span class="fc" id="L481">            l.setElementAt(0, 0, inputLine.getA());</span>
<span class="fc" id="L482">            l.setElementAt(1, 0, inputLine.getB());</span>
<span class="fc" id="L483">            l.setElementAt(2, 0, inputLine.getC());</span>

            // Rotated line below is R * l
<span class="fc" id="L486">            r.multiply(l);</span>

<span class="fc" id="L488">            resultLine.setParameters(r.getElementAt(0, 0), r.getElementAt(1, 0),</span>
<span class="fc" id="L489">                    r.getElementAt(2, 0));</span>
<span class="nc" id="L490">        } catch (final WrongSizeException ignore) {</span>
            // never happens
<span class="fc" id="L492">        }</span>
<span class="fc" id="L493">    }</span>

    /**
     * Returns a line containing a rotated version of provided line.
     * Line2D will be rotated using the origin of the coordinates as the axis of
     * rotation.
     * Line2D will be rotated by the amount of rotation contained in this
     * instance.
     *
     * @param line Line2D to be rotated.
     * @return Rotated line.
     */
    public Line2D rotate(final Line2D line) {
<span class="fc" id="L506">        final var result = new Line2D();</span>
<span class="fc" id="L507">        rotate(line, result);</span>
<span class="fc" id="L508">        return result;</span>
    }

    /**
     * Returns boolean indicating whether provided matrix is a valid matrix for
     * a rotation.
     * Rotation matrices must be orthogonal and must have determinant equal to 1.
     *
     * @param m         Input matrix to be checked.
     * @param threshold Threshold to determine whether matrix is orthogonal and
     *                  whether determinant is one.
     * @return True if matrix is valid, false otherwise.
     * @throws IllegalArgumentException Raised if provided threshold is negative.
     */
    public static boolean isValidRotationMatrix(final Matrix m, final double threshold) {
<span class="fc bfc" id="L523" title="All 2 branches covered.">        if (threshold &lt; MIN_THRESHOLD) {</span>
<span class="fc" id="L524">            throw new IllegalArgumentException();</span>
        }

        try {
<span class="fc bfc" id="L528" title="All 4 branches covered.">            return Utils.isOrthogonal(m, threshold) &amp;&amp; (Math.abs(Utils.det(m)) - 1.0) &lt; threshold;</span>
<span class="nc" id="L529">        } catch (final AlgebraException e) {</span>
<span class="nc" id="L530">            return false;</span>
        }
    }

    /**
     * Returns boolean indicating whether provided matrix is a valid matrix for
     * a rotation.
     * Rotation matrices must be orthogonal and must have determinant equal to 1
     * Because threshold is not provided, it is used MATRIX_VALID_THRESHOLD
     * instead.
     *
     * @param m Input matrix to be checked.
     * @return True if matrix is valid, false otherwise.
     * @throws IllegalArgumentException Raised if provided threshold is negative.
     */
    public static boolean isValidRotationMatrix(final Matrix m) {
<span class="fc" id="L546">        return isValidRotationMatrix(m, MATRIX_VALID_THRESHOLD);</span>
    }

    /**
     * Combines provided rotation with this rotation and returns the result as
     * a new Rotation2D instance.
     *
     * @param rotation Input rotation to be combined.
     * @return Combined rotation, which is equal to the sum of provided rotation
     * with this rotation.
     */
    public Rotation2D combineAndReturnNew(final Rotation2D rotation) {
<span class="fc" id="L558">        final var result = new Rotation2D();</span>
<span class="fc" id="L559">        combine(this, rotation, result);</span>
<span class="fc" id="L560">        return result;</span>
    }

    /**
     * Combines provided rotation into this rotation resulting in the sum of
     * both rotations.
     *
     * @param rotation Input rotation to be combined.
     */
    public void combine(final Rotation2D rotation) {
<span class="fc" id="L570">        combine(this, rotation, this);</span>
<span class="fc" id="L571">    }</span>

    /**
     * Combines the rotation of instances rot1 and rot1 into provided result
     * instance.
     *
     * @param rot1   1st input rotation.
     * @param rot2   2nd input rotation.
     * @param result Combined rotation, which is equal to the sum of provided
     *               input rotations.
     */
    public static void combine(final Rotation2D rot1, final Rotation2D rot2, final Rotation2D result) {
<span class="fc" id="L583">        result.theta = rot1.theta + rot2.theta;</span>
<span class="fc" id="L584">    }</span>

    /**
     * Determines if two Rotation2D instances are equal up to provided threshold
     * or not (i.e. have the same rotation).
     *
     * @param other     other rotation to compare.
     * @param threshold threshold to determine if they are equal.
     * @return true if they are equal, false otherwise.
     * @throws IllegalArgumentException if threshold is negative.
     */
    public boolean equals(final Rotation2D other, final double threshold) {
<span class="pc bpc" id="L596" title="1 of 2 branches missed.">        if (threshold &lt; MIN_COMPARISON_THRESHOLD) {</span>
<span class="nc" id="L597">            throw new IllegalArgumentException();</span>
        }

<span class="fc bfc" id="L600" title="All 2 branches covered.">        return Math.abs(other.theta - theta) &lt;= threshold;</span>
    }

    /**
     * Determines if two Rotation2D instances are equal or not (i.e. have the
     * same rotation).
     *
     * @param other other object to compare.
     * @return true if they are equal, false otherwise.
     */
    public boolean equals(final Rotation2D other) {
<span class="fc" id="L611">        return equals(other, DEFAULT_COMPARISON_THRESHOLD);</span>
    }

    /**
     * Determines if two Rotation2D instances are equal or not (i.e. have the
     * same rotation).
     *
     * @param obj other object to compare.
     * @return true if they are equal, false otherwise.
     */
    @Override
    public boolean equals(final Object obj) {
<span class="fc bfc" id="L623" title="All 2 branches covered.">        if (obj == this) {</span>
<span class="fc" id="L624">            return true;</span>
        }
<span class="pc bpc" id="L626" title="1 of 2 branches missed.">        if (!(obj instanceof Rotation2D)) {</span>
<span class="nc" id="L627">            return false;</span>
        }

<span class="fc" id="L630">        return equals((Rotation2D) obj);</span>
    }

    /**
     * Hash code to compare instances.
     *
     * @return hash code to compare instances.
     */
    @Override
    public int hashCode() {
<span class="fc" id="L640">        return Objects.hash(theta);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>