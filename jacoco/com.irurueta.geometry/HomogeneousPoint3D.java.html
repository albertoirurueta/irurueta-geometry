<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>HomogeneousPoint3D.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-geometry</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.geometry</a> &gt; <span class="el_source">HomogeneousPoint3D.java</span></div><h1>HomogeneousPoint3D.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2017 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.irurueta.geometry;

import java.io.Serializable;
import java.util.Objects;

/**
 * Subclass of Point3D defining an homogeneous 3D point.
 * An homogeneous 3D point is defined by four coordinates: (x,y,z,w), where
 * x, y and z are the horizontal, vertical and depth coordinates, respectively,
 * and w is a normalization (homogenization) factor. Homogeneous 3D points at
 * infinity are expressed using w=0 (x,y,z,0) where (x,y,z) describe the
 * direction of the 3D point towards infinity.
 * Inhomogeneous 3D points can be transformed into homogeneous 3D points by
 * setting the w coordinate to one (w=1, not at infinity) as follows:
 * Inhomogeneous 3D point (x,y,z) -&amp;lt; Homogeneous 3D point (x,y,z,1).
 */
public class HomogeneousPoint3D extends Point3D implements Serializable {

    /**
     * Default threshold to consider a point is located at infinity.
     */
    private static final double DEFAULT_INFINITY_THRESHOLD = 1e-10;

    /**
     * Machine precision.
     */
    private static final double PRECISION = 1e-12;

    /**
     * Defines the X coordinate of an homogeneous 2D point.
     */
    private double x;

    /**
     * Defines the Y coordinate of an homogeneous 2D point.
     */
    private double y;

    /**
     * Defines the Z coordinate of an homogeneous 2D point.
     */
    private double z;

    /**
     * Defines the W coordinate of an homogeneous 2D point.
     */
    private double w;

    /**
     * Determines whether this point is already normalized.
     */
    private boolean normalized;

    /**
     * Empty constructor.
     */
    public HomogeneousPoint3D() {
<span class="fc" id="L74">        super();</span>
<span class="fc" id="L75">        x = y = z = 0.0;</span>
<span class="fc" id="L76">        w = 1.0;</span>
<span class="fc" id="L77">        normalized = false;</span>
<span class="fc" id="L78">    }</span>

    /**
     * Constructor of this class. This constructor sets a new homogeneous
     * v array containing the coordinates X, Y, Z and W of the given point.
     *
     * @param v Array of length 4 containing the 3D coordinates of an
     *          homogeneous point.
     * @throws IllegalArgumentException Raised when the size of the array is
     *                                  different of 4.
     */
    public HomogeneousPoint3D(final double[] v) {
<span class="fc" id="L90">        super();</span>
<span class="fc" id="L91">        setCoordinates(v);</span>
<span class="fc" id="L92">    }</span>

    /**
     * Constructor of this class. This constructor sets a new homogeneous 3D
     * point using the coordinates X, Y, Z and W of the given point.
     *
     * @param x X coordinate of the given 3D point.
     * @param y Y coordinate of the given 3D point.
     * @param z Z coordinate of the given 3D point.
     * @param w W coordinate of the given 3D point.
     */
<span class="fc" id="L103">    public HomogeneousPoint3D(final double x, final double y, final double z, final double w) {</span>
<span class="fc" id="L104">        this.x = x;</span>
<span class="fc" id="L105">        this.y = y;</span>
<span class="fc" id="L106">        this.z = z;</span>
<span class="fc" id="L107">        this.w = w;</span>
<span class="fc" id="L108">        normalized = false;</span>
<span class="fc" id="L109">    }</span>

    /**
     * This constructor sets a new homogeneous 3D point using as initialization
     * provided Point3D instance.
     *
     * @param point Point to initialize new instance to
     */
<span class="fc" id="L117">    public HomogeneousPoint3D(final Point3D point) {</span>
<span class="fc" id="L118">        setCoordinates(point);</span>
<span class="fc" id="L119">    }</span>

    /**
     * Returns the X coordinate of the given homogeneous 3D point instance.
     *
     * @return X coordinate.
     */
    public double getX() {
<span class="fc" id="L127">        return x;</span>
    }

    /**
     * Sets the X coordinate of this homogeneous point.
     *
     * @param x X coordinate.
     */
    public void setX(final double x) {
<span class="fc" id="L136">        this.x = x;</span>
<span class="fc" id="L137">        normalized = false;</span>
<span class="fc" id="L138">    }</span>

    /**
     * Returns the Y coordinate of the given homogeneous 3D point instance.
     *
     * @return Y coordinate.
     */
    public double getY() {
<span class="fc" id="L146">        return y;</span>
    }

    /**
     * Sets the Y coordinate of this homogeneous point.
     *
     * @param y Y coordinate.
     */
    public void setY(final double y) {
<span class="fc" id="L155">        this.y = y;</span>
<span class="fc" id="L156">        normalized = false;</span>
<span class="fc" id="L157">    }</span>

    /**
     * Returns the Z coordinate of the given homogeneous 3D point instance.
     *
     * @return Z coordinate.
     */
    public double getZ() {
<span class="fc" id="L165">        return z;</span>
    }

    /**
     * Sets the Z coordinate of this homogeneous point.
     *
     * @param z Z coordinate.
     */
    public void setZ(final double z) {
<span class="fc" id="L174">        this.z = z;</span>
<span class="fc" id="L175">        normalized = false;</span>
<span class="fc" id="L176">    }</span>

    /**
     * Returns the W coordinate of the given homogeneous 3D point instance.
     *
     * @return W coordinate.
     */
    public double getW() {
<span class="fc" id="L184">        return w;</span>
    }

    /**
     * Sets the W coordinate of this homogeneous point.
     *
     * @param w W coordinate.
     */
    public void setW(final double w) {
<span class="fc" id="L193">        this.w = w;</span>
<span class="fc" id="L194">        normalized = false;</span>
<span class="fc" id="L195">    }</span>

    /**
     * Sets the coordinates of this homogeneous 3D point by using provided X,
     * Y, Z and W coordinates.
     *
     * @param x X coordinate.
     * @param y Y coordinate.
     * @param z Z coordinate.
     * @param w W coordinate.
     */
    public void setCoordinates(final double x, final double y, final double z, final double w) {
<span class="fc" id="L207">        this.x = x;</span>
<span class="fc" id="L208">        this.y = y;</span>
<span class="fc" id="L209">        this.z = z;</span>
<span class="fc" id="L210">        this.w = w;</span>
<span class="fc" id="L211">        normalized = false;</span>
<span class="fc" id="L212">    }</span>

    /**
     * Sets the coordinates of a 3D point using an array containing its
     * coordinates.
     *
     * @param v Array containing the coordinates of the point.
     * @throws IllegalArgumentException Raised if provided array does not have
     *                                  a valid size.
     */
    @Override
    public final void setCoordinates(final double[] v) {
<span class="fc bfc" id="L224" title="All 2 branches covered.">        if (v.length != POINT3D_HOMOGENEOUS_COORDINATES_LENGTH) {</span>
<span class="fc" id="L225">            throw new IllegalArgumentException();</span>
        } else {
<span class="fc" id="L227">            x = v[0];</span>
<span class="fc" id="L228">            y = v[1];</span>
<span class="fc" id="L229">            z = v[2];</span>
<span class="fc" id="L230">            w = v[3];</span>
<span class="fc" id="L231">            normalized = false;</span>
        }
<span class="fc" id="L233">    }</span>

    /**
     * Sets coordinates of this instance using the coordinates of provided 3D
     * point.
     *
     * @param point Input point.
     */
    @Override
    public final void setCoordinates(final Point3D point) {
<span class="fc bfc" id="L243" title="All 2 branches covered.">        switch (point.getType()) {</span>
            case INHOMOGENEOUS_COORDINATES:
<span class="fc" id="L245">                final var inhomPoint = (InhomogeneousPoint3D) point;</span>
<span class="fc" id="L246">                x = inhomPoint.getX();</span>
<span class="fc" id="L247">                y = inhomPoint.getY();</span>
<span class="fc" id="L248">                z = inhomPoint.getZ();</span>
<span class="fc" id="L249">                w = 1.0;</span>
<span class="fc" id="L250">                normalized = false;</span>
<span class="fc" id="L251">                break;</span>

            case HOMOGENEOUS_COORDINATES:
            default:
<span class="fc" id="L255">                final var homPoint = (HomogeneousPoint3D) point;</span>
<span class="fc" id="L256">                x = homPoint.getX();</span>
<span class="fc" id="L257">                y = homPoint.getY();</span>
<span class="fc" id="L258">                z = homPoint.getZ();</span>
<span class="fc" id="L259">                w = homPoint.getW();</span>
<span class="fc" id="L260">                normalized = false;</span>
                break;
        }
<span class="fc" id="L263">    }</span>

    /**
     * Returns X homogeneous coordinate of this 3D point.
     *
     * @return X homogeneous coordinate.
     */
    @Override
    public double getHomX() {
<span class="fc" id="L272">        return getX();</span>
    }

    /**
     * Returns Y homogeneous coordinate of this 3D point.
     *
     * @return Y homogeneous coordinate.
     */
    @Override
    public double getHomY() {
<span class="fc" id="L282">        return getY();</span>
    }

    /**
     * Returns Z homogeneous coordinate of this 3D point.
     *
     * @return Z homogeneous coordinate.
     */
    @Override
    public double getHomZ() {
<span class="fc" id="L292">        return getZ();</span>
    }

    /**
     * Returns W homogeneous coordinate of this 3D point.
     *
     * @return W homogeneous coordinate.
     */
    @Override
    public double getHomW() {
<span class="fc" id="L302">        return getW();</span>
    }

    /**
     * Sets coordinates of this 3D point instance using provided homogeneous
     * coordinates.
     *
     * @param homX x homogeneous coordinate.
     * @param homY y homogeneous coordinate.
     * @param homZ z homogeneous coordinate.
     * @param homW w homogeneous coordinate.
     */
    @Override
    public void setHomogeneousCoordinates(final double homX, final double homY, final double homZ, final double homW) {
<span class="fc" id="L316">        setCoordinates(homX, homY, homZ, homW);</span>
<span class="fc" id="L317">    }</span>

    /**
     * Returns X inhomogeneous coordinate of this 3D point.
     *
     * @return X inhomogeneous coordinate.
     */
    @Override
    public double getInhomX() {
<span class="fc" id="L326">        return (x / w);</span>
    }

    /**
     * Sets X inhomogeneous coordinate of this 3D point.
     *
     * @param inhomX inhomogeneous coordinate.
     */
    @Override
    public void setInhomX(final double inhomX) {
<span class="fc" id="L336">        x = inhomX * w;</span>
<span class="fc" id="L337">        normalized = false;</span>
<span class="fc" id="L338">    }</span>

    /**
     * Returns Y inhomogeneous coordinate of this 3D point.
     *
     * @return Y inhomogeneous coordinate.
     */
    @Override
    public double getInhomY() {
<span class="fc" id="L347">        return (y / w);</span>
    }

    /**
     * Sets Y inhomogeneous coordinate of this 3D point.
     *
     * @param inhomY Y inhomogeneous coordinate.
     */
    @Override
    public void setInhomY(final double inhomY) {
<span class="fc" id="L357">        y = inhomY * w;</span>
<span class="fc" id="L358">        normalized = false;</span>
<span class="fc" id="L359">    }</span>

    /**
     * Returns Z inhomogeneous coordinate of this 3D point.
     *
     * @return Z inhomogeneous coordinate.
     */
    @Override
    public double getInhomZ() {
<span class="fc" id="L368">        return (z / w);</span>
    }

    /**
     * Sets Z inhomogeneous coordinate of this 3D point.
     *
     * @param inhomZ Z inhomogeneous coordinate.
     */
    public void setInhomZ(final double inhomZ) {
<span class="fc" id="L377">        z = inhomZ * w;</span>
<span class="fc" id="L378">        normalized = false;</span>
<span class="fc" id="L379">    }</span>

    /**
     * Sets coordinates of this 3D point instance using provided inhomogeneous
     * coordinates.
     *
     * @param inhomX x inhomogeneous coordinate.
     * @param inhomY y inhomogeneous coordinate.
     * @param inhomZ z inhomogeneous coordinate.
     */
    @Override
    public void setInhomogeneousCoordinates(final double inhomX, final double inhomY, final double inhomZ) {
<span class="fc" id="L391">        x = inhomX;</span>
<span class="fc" id="L392">        y = inhomY;</span>
<span class="fc" id="L393">        z = inhomZ;</span>
<span class="fc" id="L394">        w = 1.0;</span>
<span class="fc" id="L395">        normalized = false;</span>
<span class="fc" id="L396">    }</span>

    /**
     * Checks if provided object equals current 2D point.
     *
     * @param obj Object to compare.
     * @return True if both objects are considered to be equal, false otherwise.
     */
    @Override
    public boolean equals(final Object obj) {
<span class="pc bpc" id="L406" title="1 of 2 branches missed.">        if (!(obj instanceof Point3D point)) {</span>
<span class="nc" id="L407">            return false;</span>
        }
<span class="pc bpc" id="L409" title="1 of 2 branches missed.">        if (obj == this) {</span>
<span class="nc" id="L410">            return true;</span>
        }

<span class="fc" id="L413">        return equals(point);</span>
    }

    /**
     * Returns hash code value.
     *
     * @return Hash code value.
     */
    @Override
    public int hashCode() {
<span class="fc" id="L423">        return Objects.hash(x, y, z, w);</span>
    }

    /**
     * Checks if the homogeneous 3D point described by this instance equals the
     * input Point3D (using a comparison threshold).
     *
     * @param point     Point that will be compared to.
     * @param threshold threshold grade of tolerance to determine whether the
     *                  points are equal or not. It is used because due to machine precision, the
     *                  values might not be exactly equal (if not provided
     *                  DEFAULT_COMPARISON_THRESHOLD is used).
     * @return True if current point and input point are the same, false
     * otherwise.
     * @throws IllegalArgumentException Raised if threshold is negative.
     */
    @Override
    public boolean equals(final Point3D point, final double threshold) {
<span class="fc bfc" id="L441" title="All 2 branches covered.">        if (point.getType() == CoordinatesType.INHOMOGENEOUS_COORDINATES) {</span>
<span class="fc" id="L442">            return equals((InhomogeneousPoint3D) point, threshold);</span>
        } else {
<span class="fc" id="L444">            return equals((HomogeneousPoint3D) point, threshold);</span>
        }
    }

    /**
     * Checks if the homogeneous 3D point described by this instance equals the
     * input HomogeneousPoint2d (using a comparison threshold).
     *
     * @param point     Point that will be compared to.
     * @param threshold threshold grade of tolerance to determine whether the
     *                  points are equal or not. It is used because due to machine precision, the
     *                  values might not be exactly equal (if not provided
     *                  DEFAULT_COMPARISON_THRESHOLD is used).
     * @return True if current point and input point are the same, false
     * otherwise.
     * @throws IllegalArgumentException Raised if threshold is negative.
     */
    public boolean equals(final HomogeneousPoint3D point, final double threshold) {
<span class="fc bfc" id="L462" title="All 2 branches covered.">        if (threshold &lt; MIN_THRESHOLD) {</span>
<span class="fc" id="L463">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L466">        normalize();</span>
<span class="fc" id="L467">        point.normalize();</span>

        // compute sign for the case when points have different sign
<span class="fc bfc" id="L470" title="All 2 branches covered.">        final var signThis = (w &gt; 0.0) ? 1.0 : -1.0;</span>
<span class="fc bfc" id="L471" title="All 2 branches covered.">        final var signPoint = (point.w &gt; 0.0) ? 1.0 : -1.0;</span>

<span class="fc" id="L473">        final var normThis = Math.sqrt(x * x + y * y + z * z + w * w) * signThis;</span>
<span class="fc" id="L474">        final var normPoint = Math.sqrt(point.x * point.x + point.y * point.y + point.z * point.z</span>
                + point.w * point.w) * signPoint;

<span class="fc bfc" id="L477" title="All 2 branches covered.">        final var validX = Math.abs(x / normThis - point.x / normPoint) &lt;= threshold;</span>
<span class="fc bfc" id="L478" title="All 2 branches covered.">        final var validY = Math.abs(y / normThis - point.y / normPoint) &lt;= threshold;</span>
<span class="fc bfc" id="L479" title="All 2 branches covered.">        final var validZ = Math.abs(z / normThis - point.z / normPoint) &lt;= threshold;</span>
<span class="fc bfc" id="L480" title="All 2 branches covered.">        final var validW = Math.abs(w / normThis - point.w / normPoint) &lt;= threshold;</span>

<span class="pc bpc" id="L482" title="3 of 8 branches missed.">        return (validX &amp;&amp; validY &amp;&amp; validZ &amp;&amp; validW);</span>
    }

    /**
     * Checks if the homogeneous 3D point described by this instance equals the
     * input HomogeneousPoint3D (using a comparison threshold).
     *
     * @param point Point that will be compared to.
     * @return True if current point and input point are the same, false
     * otherwise.
     */
    public boolean equals(final HomogeneousPoint3D point) {
<span class="fc" id="L494">        return equals(point, DEFAULT_COMPARISON_THRESHOLD);</span>
    }

    /**
     * Checks if the homogeneous 3D point described by this instance equals the
     * input InhomogeneousPoint3D (using a comparison threshold).
     *
     * @param point     Point that will be compared to.
     * @param threshold threshold grade of tolerance to determine whether the
     *                  points are equal or not. It is used because due to machine precision, the
     *                  values might not be exactly equal (if not provided
     *                  DEFAULT_COMPARISON_THRESHOLD is used).
     * @return True if current point and input point are the same, false
     * otherwise.
     * @throws IllegalArgumentException Raised if threshold is negative.
     */
    public boolean equals(final InhomogeneousPoint3D point, final double threshold) {
<span class="fc bfc" id="L511" title="All 2 branches covered.">        if (threshold &lt; MIN_THRESHOLD) {</span>
<span class="fc" id="L512">            throw new IllegalArgumentException();</span>
        }

<span class="fc bfc" id="L515" title="All 2 branches covered.">        final var dX = Math.abs(point.getX() - (x / w)) &lt;= threshold;</span>
<span class="fc bfc" id="L516" title="All 2 branches covered.">        final var dY = Math.abs(point.getY() - (y / w)) &lt;= threshold;</span>
<span class="fc bfc" id="L517" title="All 2 branches covered.">        final var dZ = Math.abs(point.getZ() - (z / w)) &lt;= threshold;</span>
<span class="pc bpc" id="L518" title="2 of 6 branches missed.">        return (dX &amp;&amp; dY &amp;&amp; dZ);</span>
    }

    /**
     * Checks if the homogeneous 3D point described by this instance equals the
     * input InhomogeneousPoint3D (using a comparison threshold).
     *
     * @param point Point that will be compared to.
     * @return True if current point and input point are the same, false
     * otherwise.
     */
    public boolean equals(final InhomogeneousPoint3D point) {
<span class="fc" id="L530">        return equals(point, DEFAULT_COMPARISON_THRESHOLD);</span>
    }

    /**
     * Checks whether this Point3D is at infinity or not.
     *
     * @return True if the point is at infinity. False otherwise.
     */
    @Override
    public boolean isAtInfinity() {
<span class="fc" id="L540">        return isAtInfinity(DEFAULT_INFINITY_THRESHOLD);</span>
    }

    /**
     * Checks whether this homogeneous 3D point is at infinity or not. An
     * homogeneous 3D point is at infinity when W coordinates are equal or close
     * to zero.
     *
     * @param threshold Grade of tolerance to determine whether the point is at
     *                  infinity or not. It is used because due to machine precision, the values
     *                  might not be exactly equal.
     * @return True if point is at infinity, false otherwise.
     * @throws IllegalArgumentException Raised if threshold is negative.
     */
    public boolean isAtInfinity(final double threshold) {
<span class="fc bfc" id="L555" title="All 2 branches covered.">        if (threshold &lt; MIN_THRESHOLD) {</span>
<span class="fc" id="L556">            throw new IllegalArgumentException();</span>
        }

<span class="fc bfc" id="L559" title="All 2 branches covered.">        return (Math.abs(w) &lt;= threshold);</span>
    }

    /**
     * Returns the type of coordinates used to represent a Point3D.
     *
     * @return Type of coordinates of this 3D point.
     */
    @Override
    public CoordinatesType getType() {
<span class="fc" id="L569">        return CoordinatesType.HOMOGENEOUS_COORDINATES;</span>
    }

    /**
     * Method to normalize a 3D point by dividing all homogeneous components by
     * its norm. This only applies to homogeneous 3D points, because they are
     * defined up to scale.
     */
    @Override
    public void normalize() {
<span class="fc bfc" id="L579" title="All 2 branches covered.">        if (!normalized) {</span>
<span class="fc" id="L580">            var norm = Math.sqrt(x * x + y * y + z * z + w * w);</span>
<span class="fc bfc" id="L581" title="All 2 branches covered.">            if (norm &gt; PRECISION) {</span>
<span class="fc" id="L582">                x /= norm;</span>
<span class="fc" id="L583">                y /= norm;</span>
<span class="fc" id="L584">                z /= norm;</span>
<span class="fc" id="L585">                w /= norm;</span>
<span class="fc" id="L586">                normalized = true;</span>
            }
        }
<span class="fc" id="L589">    }</span>

    /**
     * Returns boolean indicating whether this point has already been normalized.
     *
     * @return True if normalized, false otherwise.
     */
    @Override
    public boolean isNormalized() {
<span class="fc" id="L598">        return normalized;</span>
    }

    /**
     * Converts this instance into an inhomogeneous 3D point and returns the
     * result as a new inhomogeneous 3D point instance.
     *
     * @return Converts and returns this point as an inhomogeneous 3D point.
     */
    public InhomogeneousPoint3D toInhomogeneous() {
<span class="fc" id="L608">        return new InhomogeneousPoint3D(x / w, y / w, z / w);</span>
    }

    /**
     * Returns an array containing the coordinates of this Point2D.
     *
     * @return Array containing coordinates of this Point2D.
     */
    @Override
    public double[] asArray() {
<span class="fc" id="L618">        final var out = new double[POINT3D_HOMOGENEOUS_COORDINATES_LENGTH];</span>
<span class="fc" id="L619">        asArray(out);</span>
<span class="fc" id="L620">        return out;</span>
    }

    /**
     * Uses provided array to store the coordinates of this HomogeneousPoint2D.
     *
     * @param array Array where coordinates will be stored.
     * @throws IllegalArgumentException Raised if length of array is not 3.
     */
    @Override
    public void asArray(final double[] array) {
<span class="pc bpc" id="L631" title="1 of 2 branches missed.">        if (array.length != POINT3D_HOMOGENEOUS_COORDINATES_LENGTH) {</span>
<span class="nc" id="L632">            throw new IllegalArgumentException();</span>
        }
<span class="fc" id="L634">        array[0] = x;</span>
<span class="fc" id="L635">        array[1] = y;</span>
<span class="fc" id="L636">        array[2] = z;</span>
<span class="fc" id="L637">        array[3] = w;</span>
<span class="fc" id="L638">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>