<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Sphere.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-geometry</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.geometry</a> &gt; <span class="el_source">Sphere.java</span></div><h1>Sphere.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2012 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.geometry;

import com.irurueta.algebra.AlgebraException;
import com.irurueta.algebra.Matrix;

import java.io.Serializable;

/**
 * This class defines a sphere.
 */
@SuppressWarnings(&quot;WeakerAccess&quot;)
public class Sphere implements Serializable {

    /**
     * Constant defining minimum allowed radius.
     */
    public static final double MIN_RADIUS = 0.0;

    /**
     * Constant defining default threshold value used when none is provided.
     */
    public static final double DEFAULT_THRESHOLD = 1e-9;

    /**
     * Constant defining minimum allowed threshold.
     */
    public static final double MIN_THRESHOLD = 0.0;

    /**
     * Constant defining machine precision.
     */
    public static final double EPS = 1e-12;

    /**
     * Center of sphere.
     */
    private Point3D center;

    /**
     * Radius of sphere.
     */
    private double radius;

    /**
     * Empty constructor.
     * Creates sphere located at space origin (0,0) with radius 1.0.
     */
<span class="fc" id="L63">    public Sphere() {</span>
<span class="fc" id="L64">        center = Point3D.create();</span>
<span class="fc" id="L65">        radius = 1.0;</span>
<span class="fc" id="L66">    }</span>

    /**
     * Constructor.
     * Sets center and radius of sphere.
     *
     * @param center Center of sphere.
     * @param radius Radius of sphere.
     * @throws IllegalArgumentException Raised if provided radius is negative.
     */
<span class="fc" id="L76">    public Sphere(final Point3D center, final double radius) {</span>
<span class="fc" id="L77">        setCenterAndRadius(center, radius);</span>
<span class="fc" id="L78">    }</span>

    /**
     * Constructor.
     * Computes a sphere by using 4 points that must belong to its locus.
     *
     * @param point1 point 1.
     * @param point2 point 2.
     * @param point3 point 3.
     * @param point4 point 4.
     * @throws CoplanarPointsException if provided set of points are coincident
     *                                 or coplanar (form a single plane). In such cases a singularity occurs
     *                                 since a sphere having an infinite radius would be required to contain all
     *                                 four points in its locus.
     */
    public Sphere(final Point3D point1, final Point3D point2, final Point3D point3, final Point3D point4)
<span class="fc" id="L94">            throws CoplanarPointsException {</span>
<span class="fc" id="L95">        setParametersFromPoints(point1, point2, point3, point4);</span>
<span class="fc" id="L96">    }</span>

    /**
     * Constructor.
     * Computes a sphere from a valid quadric corresponding to a sphere
     *
     * @param quadric a quadric to create a sphere from.
     * @throws IllegalArgumentException if provided quadric is not a sphere.
     */
<span class="fc" id="L105">    public Sphere(final Quadric quadric) {</span>
<span class="fc" id="L106">        setFromQuadric(quadric);</span>
<span class="fc" id="L107">    }</span>

    /**
     * Returns center of sphere.
     *
     * @return Center of sphere.
     */
    public Point3D getCenter() {
<span class="fc" id="L115">        return center;</span>
    }

    /**
     * Sets center of sphere.
     *
     * @param center Center of sphere.
     * @throws NullPointerException Raised if provided center is null.
     */
    public void setCenter(final Point3D center) {
<span class="fc bfc" id="L125" title="All 2 branches covered.">        if (center == null) {</span>
<span class="fc" id="L126">            throw new NullPointerException();</span>
        }

<span class="fc" id="L129">        this.center = center;</span>
<span class="fc" id="L130">    }</span>

    /**
     * Returns radius of sphere.
     *
     * @return Radius of sphere.
     */
    public double getRadius() {
<span class="fc" id="L138">        return radius;</span>
    }

    /**
     * Sets radius of sphere.
     *
     * @param radius Radius of sphere.
     * @throws IllegalArgumentException Raised if provided radius is negative.
     */
    public void setRadius(final double radius) {
<span class="fc bfc" id="L148" title="All 2 branches covered.">        if (radius &lt; MIN_RADIUS) {</span>
<span class="fc" id="L149">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L152">        this.radius = radius;</span>
<span class="fc" id="L153">    }</span>

    /**
     * Sets center and radius of this sphere.
     *
     * @param center Center to be set.
     * @param radius Radius to be set.
     * @throws IllegalArgumentException Raised if provided radius is negative.
     * @throws NullPointerException     Raised if provided center is null.
     */
    public final void setCenterAndRadius(final Point3D center, final double radius) {
<span class="fc" id="L164">        setRadius(radius);</span>
<span class="fc" id="L165">        setCenter(center);</span>
<span class="fc" id="L166">    }</span>

    /**
     * Sets parameters of a sphere by using four points that must belong to its
     * locus.
     *
     * @param point1 point 1.
     * @param point2 point 2.
     * @param point3 point 3.
     * @param point4 point 4.
     * @throws CoplanarPointsException if provided set of points are coincident
     *                                 or coplanar (form a single plane). In such cases a singularity occurs
     *                                 since a sphere having an infinite radius would be required to contain all
     *                                 four points in its locus.
     */
    public final void setParametersFromPoints(
            final Point3D point1, final Point3D point2, final Point3D point3, final Point3D point4)
            throws CoplanarPointsException {

        // normalize points to increase accuracy
<span class="fc" id="L186">        point1.normalize();</span>
<span class="fc" id="L187">        point2.normalize();</span>
<span class="fc" id="L188">        point3.normalize();</span>
<span class="fc" id="L189">        point4.normalize();</span>

        try {
<span class="fc" id="L192">            final var m = new Matrix(4, 4);</span>
<span class="fc" id="L193">            final var b = new double[4];</span>

            // 1st point
<span class="fc" id="L196">            var x = point1.getHomX();</span>
<span class="fc" id="L197">            var y = point1.getHomY();</span>
<span class="fc" id="L198">            var z = point1.getHomZ();</span>
<span class="fc" id="L199">            var w = point1.getHomW();</span>
<span class="fc" id="L200">            m.setElementAt(0, 0, 2.0 * x * w);</span>
<span class="fc" id="L201">            m.setElementAt(0, 1, 2.0 * y * w);</span>
<span class="fc" id="L202">            m.setElementAt(0, 2, 2.0 * z * w);</span>
<span class="fc" id="L203">            m.setElementAt(0, 3, w * w);</span>
<span class="fc" id="L204">            b[0] = -x * x - y * y - z * z;</span>

            // 2nd point
<span class="fc" id="L207">            x = point2.getHomX();</span>
<span class="fc" id="L208">            y = point2.getHomY();</span>
<span class="fc" id="L209">            z = point2.getHomZ();</span>
<span class="fc" id="L210">            w = point2.getHomW();</span>
<span class="fc" id="L211">            m.setElementAt(1, 0, 2.0 * x * w);</span>
<span class="fc" id="L212">            m.setElementAt(1, 1, 2.0 * y * w);</span>
<span class="fc" id="L213">            m.setElementAt(1, 2, 2.0 * z * w);</span>
<span class="fc" id="L214">            m.setElementAt(1, 3, w * w);</span>
<span class="fc" id="L215">            b[1] = -x * x - y * y - z * z;</span>

            // 3rd point
<span class="fc" id="L218">            x = point3.getHomX();</span>
<span class="fc" id="L219">            y = point3.getHomY();</span>
<span class="fc" id="L220">            z = point3.getHomZ();</span>
<span class="fc" id="L221">            w = point3.getHomW();</span>
<span class="fc" id="L222">            m.setElementAt(2, 0, 2.0 * x * w);</span>
<span class="fc" id="L223">            m.setElementAt(2, 1, 2.0 * y * w);</span>
<span class="fc" id="L224">            m.setElementAt(2, 2, 2.0 * z * w);</span>
<span class="fc" id="L225">            m.setElementAt(2, 3, w * w);</span>
<span class="fc" id="L226">            b[2] = -x * x - y * y - z * z;</span>

            // 4th point
<span class="fc" id="L229">            x = point4.getHomX();</span>
<span class="fc" id="L230">            y = point4.getHomY();</span>
<span class="fc" id="L231">            z = point4.getHomZ();</span>
<span class="fc" id="L232">            w = point4.getHomW();</span>
<span class="fc" id="L233">            m.setElementAt(3, 0, 2.0 * x * w);</span>
<span class="fc" id="L234">            m.setElementAt(3, 1, 2.0 * y * w);</span>
<span class="fc" id="L235">            m.setElementAt(3, 2, 2.0 * z * w);</span>
<span class="fc" id="L236">            m.setElementAt(3, 3, w * w);</span>
<span class="fc" id="L237">            b[3] = -x * x - y * y - z * z;</span>

            // normalize each row to increase accuracy
<span class="fc" id="L240">            final var row = new double[4];</span>
            double rowNorm;

<span class="fc bfc" id="L243" title="All 2 branches covered.">            for (var j = 0; j &lt; 4; j++) {</span>
<span class="fc" id="L244">                m.getSubmatrixAsArray(j, 0, j, 3, row);</span>
<span class="fc" id="L245">                rowNorm = com.irurueta.algebra.Utils.normF(row);</span>
<span class="fc bfc" id="L246" title="All 2 branches covered.">                for (var i = 0; i &lt; 4; i++) {</span>
<span class="fc" id="L247">                    m.setElementAt(j, i, m.getElementAt(j, i) / rowNorm);</span>
                }
<span class="fc" id="L249">                b[j] /= rowNorm;</span>
            }

<span class="fc" id="L252">            final var params = com.irurueta.algebra.Utils.solve(m, b);</span>

            // g = -cx
<span class="fc" id="L255">            final var g = params[0];</span>
            // h = -cy
<span class="fc" id="L257">            final var h = params[1];</span>
            // i = -cz
<span class="fc" id="L259">            final var i = params[2];</span>
            // j = cx^2 + cy^2 + cz^2 - R^2
<span class="fc" id="L261">            final var j = params[3];</span>

            // compute center
<span class="fc" id="L264">            final var inhomCx = -g;</span>
<span class="fc" id="L265">            final var inhomCy = -h;</span>
<span class="fc" id="L266">            final var inhomCz = -i;</span>
<span class="fc" id="L267">            final var c = new InhomogeneousPoint3D(inhomCx, inhomCy, inhomCz);</span>

            // compute radius
<span class="fc" id="L270">            final var r = Math.sqrt(inhomCx * inhomCx + inhomCy * inhomCy + inhomCz * inhomCz - j);</span>

<span class="fc" id="L272">            setCenterAndRadius(c, r);</span>
<span class="fc" id="L273">        } catch (final AlgebraException e) {</span>
<span class="fc" id="L274">            throw new CoplanarPointsException(e);</span>
<span class="fc" id="L275">        }</span>
<span class="fc" id="L276">    }</span>

    /**
     * Returns volume of a sphere having provided radius.
     *
     * @param radius Radius of a sphere.
     * @return Volume of a sphere having provided radius.
     * @throws IllegalArgumentException Raised if provided radius is negative.
     */
    public static double volume(final double radius) {
<span class="pc bpc" id="L286" title="1 of 2 branches missed.">        if (radius &lt; MIN_RADIUS) {</span>
<span class="nc" id="L287">            throw new IllegalArgumentException();</span>
        }
<span class="fc" id="L289">        return 4.0 / 3.0 * Math.PI * radius * radius * radius;</span>
    }

    /**
     * Returns volume of this sphere.
     *
     * @return Volume of this sphere.
     */
    public double getVolume() {
<span class="fc" id="L298">        return volume(radius);</span>
    }

    /**
     * Returns surface of a sphere having provided radius.
     *
     * @param radius Radius of a sphere.
     * @return Surface of a sphere having provided radius.
     * @throws IllegalArgumentException Raised if provided radius is negative.
     */
    public static double surface(final double radius) {
<span class="pc bpc" id="L309" title="1 of 2 branches missed.">        if (radius &lt; MIN_RADIUS) {</span>
<span class="nc" id="L310">            throw new IllegalArgumentException();</span>
        }
<span class="fc" id="L312">        return 4.0 * Math.PI * radius * radius;</span>
    }

    /**
     * Returns surface of this sphere.
     *
     * @return Surface of this sphere.
     */
    public double getSurface() {
<span class="fc" id="L321">        return surface(radius);</span>
    }

    /**
     * Determines if provided point is inside this sphere or not up to a certain
     * threshold.
     * If provided threshold is positive, the sphere behaves as if it was a
     * larger sphere increased by threshold amount, if provided threshold is
     * negative, the sphere behaves as if it was a smaller sphere decreased by
     * threshold amount in radius.
     *
     * @param point     Point to be checked.
     * @param threshold Threshold to determine if point is inside or not
     * @return True if point is considered to be inside this sphere, false
     * otherwise.
     */
    public boolean isInside(final Point3D point, final double threshold) {
<span class="fc bfc" id="L338" title="All 2 branches covered.">        return point.distanceTo(center) - threshold &lt;= radius;</span>
    }

    /**
     * Determines if provided point is inside this sphere or not.
     *
     * @param point Point to be checked.
     * @return True if point is considered to be inside this sphere, false
     * otherwise.
     */
    public boolean isInside(final Point3D point) {
<span class="fc" id="L349">        return isInside(point, 0.0);</span>
    }

    /**
     * Returns distance from provided point to the closest point located in the
     * sphere boundary.
     * Returned distance will be negative when point is inside of sphere, and
     * positive otherwise.
     *
     * @param point Point to be checked.
     * @return Distance from point to sphere boundary.
     */
    public double getSignedDistance(final Point3D point) {
<span class="fc" id="L362">        return signedDistance(this, point);</span>
    }

    /**
     * Returns distance from provided point to the closest point located in
     * provided sphere boundary.
     * Returned distance will be negative when point is inside of sphere, and
     * positive otherwise.
     *
     * @param sphere A sphere.
     * @param point  Point to be checked.
     * @return Distance from point to provided sphere boundary.
     */
    public static double signedDistance(final Sphere sphere, final Point3D point) {
<span class="fc" id="L376">        return point.distanceTo(sphere.getCenter()) - sphere.getRadius();</span>
    }

    /**
     * Returns distance from provided point to the closest point located in the
     * sphere boundary.
     *
     * @param point Point to be checked.
     * @return Distance from point to sphere boundary.
     */
    public double getDistance(final Point3D point) {
<span class="fc" id="L387">        return Math.abs(getSignedDistance(point));</span>
    }

    /**
     * Returns distance from provided point to the closest point located in
     * provided sphere boundary.
     *
     * @param sphere A sphere.
     * @param point  Point to be checked.
     * @return Distance from point to provided sphere boundary.
     */
    public static double distance(final Sphere sphere, final Point3D point) {
<span class="fc" id="L399">        return Math.abs(signedDistance(sphere, point));</span>
    }

    /**
     * Returns closest point to provided point that is located in this sphere
     * boundary.
     *
     * @param point A point to be checked.
     * @return Closest point laying in sphere boundary.
     * @throws UndefinedPointException Raised if provided point is at sphere
     *                                 center or very close to it.
     */
    public Point3D getClosestPoint(final Point3D point) throws UndefinedPointException {
<span class="fc" id="L412">        final var result = Point3D.create();</span>
<span class="fc" id="L413">        closestPoint(point, result);</span>
<span class="fc" id="L414">        return result;</span>
    }

    /**
     * Computes closest point to provided point that is located in this sphere
     * boundary and stores the result in provided result instance.
     *
     * @param point  A point to be checked.
     * @param result Instance where result will be stored.
     * @throws UndefinedPointException Raised if provided point is at sphere
     *                                 center or very close to ti.
     */
    public void closestPoint(final Point3D point, final Point3D result) throws UndefinedPointException {

<span class="fc" id="L428">        var directionX = point.getInhomX() - center.getInhomX();</span>
<span class="fc" id="L429">        var directionY = point.getInhomY() - center.getInhomY();</span>
<span class="fc" id="L430">        var directionZ = point.getInhomZ() - center.getInhomZ();</span>
        // normalize direction and multiply by radius to set result as locus of
        // circle
<span class="fc" id="L433">        final var norm = Math.sqrt(directionX * directionX + directionY * directionY + directionZ * directionZ);</span>

        // check if point is at center or very close to center, in that case the
        // closest point cannot be found (would be all points of a circle)
<span class="fc bfc" id="L437" title="All 2 branches covered.">        if (norm &lt; EPS) {</span>
<span class="fc" id="L438">            throw new UndefinedPointException();</span>
        }

<span class="fc" id="L441">        directionX *= radius / norm;</span>
<span class="fc" id="L442">        directionY *= radius / norm;</span>
<span class="fc" id="L443">        directionZ *= radius / norm;</span>

<span class="fc" id="L445">        result.setInhomogeneousCoordinates(center.getInhomX() + directionX,</span>
<span class="fc" id="L446">                center.getInhomY() + directionY, center.getInhomZ() + directionZ);</span>
<span class="fc" id="L447">    }</span>

    /**
     * Determines whether provided point lies at sphere boundary or not up to
     * a certain threshold.
     *
     * @param point     Point to be checked.
     * @param threshold A small threshold to determine whether point lies at
     *                  sphere boundary.
     * @return True if point lies at sphere boundary, false otherwise.
     * @throws IllegalArgumentException Raised if provided threshold is negative.
     */
    public boolean isLocus(final Point3D point, final double threshold) {
<span class="fc bfc" id="L460" title="All 2 branches covered.">        if (threshold &lt; MIN_THRESHOLD) {</span>
<span class="fc" id="L461">            throw new IllegalArgumentException();</span>
        }

<span class="fc bfc" id="L464" title="All 2 branches covered.">        return Math.abs(point.distanceTo(center) - radius) &lt;= threshold;</span>
    }

    /**
     * Determines whether provided point lies at sphere boundary or not.
     *
     * @param point Point to be checked.
     * @return True if point lies at sphere boundary, false otherwise.
     */
    public boolean isLocus(final Point3D point) {
<span class="fc" id="L474">        return isLocus(point, DEFAULT_THRESHOLD);</span>
    }

    /**
     * Returns a plane tangent to this sphere at provided point. Provided point
     * must be locus of this sphere, otherwise a NotLocusException will be
     * thrown.
     *
     * @param point a locus point of this sphere.
     * @return a 3D plane tangent to this sphere at provided point.
     * @throws NotLocusException if provided point is not locus of this sphere
     *                           up to DEFAULT_THRESHOLD.
     */
    public Plane getTangentPlaneAt(final Point3D point) throws NotLocusException {
<span class="fc" id="L488">        return getTangentPlaneAt(point, DEFAULT_THRESHOLD);</span>
    }

    /**
     * Returns a plane tangent to this sphere at provided point. Provided point
     * must be locus of this sphere, otherwise a NotLocusException will be
     * thrown.
     *
     * @param point     a locus point of this sphere.
     * @param threshold threshold to determine if provided point is locus.
     * @return a 3D plane tangent to this circle at provided point.
     * @throws NotLocusException        if provided point is not locus of this sphere
     *                                  up to provided threshold.
     * @throws IllegalArgumentException if provided threshold is negative.
     */
    public Plane getTangentPlaneAt(final Point3D point, final double threshold) throws NotLocusException {
<span class="fc" id="L504">        final var plane = new Plane();</span>
<span class="fc" id="L505">        tangentPlaneAt(point, plane, threshold);</span>
<span class="fc" id="L506">        return plane;</span>
    }

    /**
     * Computes a plane tangent to this sphere at provided point. Provided point
     * must be locus of this sphere, otherwise a NotLocusException will be
     * thrown.
     *
     * @param point     a locus point of this sphere.
     * @param plane     instance of a 3D plane where result will be stored.
     * @param threshold threshold to determine if provided point is locus.
     * @throws NotLocusException        if provided point is not locus of this sphere.
     * @throws IllegalArgumentException if provided threshold is negative.
     */
    public void tangentPlaneAt(final Point3D point, final Plane plane, final double threshold)
            throws NotLocusException {
<span class="pc bpc" id="L522" title="1 of 2 branches missed.">        if (!isLocus(point, threshold)) {</span>
<span class="nc" id="L523">            throw new NotLocusException();</span>
        }

<span class="fc" id="L526">        point.normalize();</span>
<span class="fc" id="L527">        center.normalize();</span>

        // Q =   [a      d       f       g]
        //       [d      b       e       h]
        //       [f      e       c       i]
        //       [g      h       i       j]

        // Q =   [1      0       0       -cx]
        //       [0      1       0       -cy]
        //       [0      0       1       -cz]
        //       [-cx    -cy     -cz     cx^2 + cy^2 + cz^2 - r^2]

        // a = b = c = 1.0
        // d = e = f = 0.0
        // g = -cx, h = -cy, i = -cz
        // j = cx^2 + cy^2 + cz^2 - r^2

        // Hence plane is P = Q * p, where Q is the sphere quadric and p is
        // a point in the locus of the sphere

<span class="fc" id="L547">        final var homX = point.getHomX();</span>
<span class="fc" id="L548">        final var homY = point.getHomY();</span>
<span class="fc" id="L549">        final var homZ = point.getHomZ();</span>
<span class="fc" id="L550">        final var homW = point.getHomW();</span>
<span class="fc" id="L551">        final var cx = center.getInhomX();</span>
<span class="fc" id="L552">        final var cy = center.getInhomY();</span>
<span class="fc" id="L553">        final var cz = center.getInhomZ();</span>
<span class="fc" id="L554">        final var quadricG = -cx;</span>
<span class="fc" id="L555">        final var quadricH = -cy;</span>
<span class="fc" id="L556">        final var quadricI = -cz;</span>
<span class="fc" id="L557">        final var quadricJ = cx * cx + cy * cy + cz * cz - radius * radius;</span>

<span class="fc" id="L559">        final var planeA = homX + quadricG * homW;</span>
<span class="fc" id="L560">        final var planeB = homY + quadricH * homW;</span>
<span class="fc" id="L561">        final var planeC = homZ + quadricI * homW;</span>
<span class="fc" id="L562">        final var planeD = quadricG * homX + quadricH * homY + quadricI * homZ + quadricJ * homW;</span>
<span class="fc" id="L563">        plane.setParameters(planeA, planeB, planeC, planeD);</span>
<span class="fc" id="L564">    }</span>

    /**
     * Converts this sphere into a quadric.
     * Quadrics are a more general representation of spheres.
     *
     * @return A quadric representing this circle.
     */
    public Quadric toQuadric() {
<span class="fc" id="L573">        center.normalize();</span>
        // use inhomogeneous center coordinates
<span class="fc" id="L575">        final var cx = center.getInhomX();</span>
<span class="fc" id="L576">        final var cy = center.getInhomY();</span>
<span class="fc" id="L577">        final var cz = center.getInhomZ();</span>

<span class="fc" id="L579">        final var a = 1.0;</span>
<span class="fc" id="L580">        final var b = 1.0;</span>
<span class="fc" id="L581">        final var c = 1.0;</span>
<span class="fc" id="L582">        final var d = 0.0;</span>
<span class="fc" id="L583">        final var e = 0.0;</span>
<span class="fc" id="L584">        final var f = 0.0;</span>
<span class="fc" id="L585">        final var g = -cx;</span>
<span class="fc" id="L586">        final var h = -cy;</span>
<span class="fc" id="L587">        final var i = -cz;</span>
<span class="fc" id="L588">        final var j = cx * cx + cy * cy + cz * cz - radius * radius;</span>

<span class="fc" id="L590">        return new Quadric(a, b, c, d, e, f, g, h, i, j);</span>
    }

    /**
     * Sets parameters of this sphere from a valid quadric corresponding to a
     * sphere.
     *
     * @param quadric quadric to set parameters from.
     * @throws IllegalArgumentException if provided quadric is not a sphere.
     */
    public final void setFromQuadric(final Quadric quadric) {
<span class="pc bpc" id="L601" title="2 of 4 branches missed.">        final var isSphere = quadric.getA() == quadric.getB() &amp;&amp; quadric.getB() == quadric.getC()</span>
<span class="pc bpc" id="L602" title="3 of 8 branches missed.">                &amp;&amp; quadric.getA() != 0.0 &amp;&amp; quadric.getD() == 0.0 &amp;&amp; quadric.getE() == 0.0 &amp;&amp; quadric.getF() == 0.0;</span>

<span class="fc bfc" id="L604" title="All 2 branches covered.">        if (!isSphere) {</span>
<span class="fc" id="L605">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L608">        quadric.normalize();</span>

<span class="fc" id="L610">        final var a = quadric.getA();</span>
        // normalize parameters so that
        // a = b = c = 1.0
        // d = e = f = 0.0
        // g = -cx, h = -cy, i = -cz
        // j = cx^2 + cy^2 + cz^2 - r^2
<span class="fc" id="L616">        final var normG = quadric.getG() / a;</span>
<span class="fc" id="L617">        final var normH = quadric.getH() / a;</span>
<span class="fc" id="L618">        final var normI = quadric.getI() / a;</span>
<span class="fc" id="L619">        final var normJ = quadric.getJ() / a;</span>

<span class="fc" id="L621">        final var cx = -normG;</span>
<span class="fc" id="L622">        final var cy = -normH;</span>
<span class="fc" id="L623">        final var cz = -normI;</span>
<span class="fc" id="L624">        final var r = Math.sqrt(cx * cx + cy * cy + cz * cz - normJ);</span>

<span class="fc" id="L626">        center = new InhomogeneousPoint3D(cx, cy, cz);</span>
<span class="fc" id="L627">        this.radius = r;</span>
<span class="fc" id="L628">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>