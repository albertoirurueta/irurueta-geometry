<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Quadric.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-geometry</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.geometry</a> &gt; <span class="el_source">Quadric.java</span></div><h1>Quadric.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2012 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.geometry;

import com.irurueta.algebra.AlgebraException;
import com.irurueta.algebra.Matrix;
import com.irurueta.algebra.SingularValueDecomposer;
import com.irurueta.algebra.WrongSizeException;

import java.io.Serializable;

/**
 * This class contains the implementation of a quadric.
 */
@SuppressWarnings(&quot;DuplicatedCode&quot;)
public class Quadric extends BaseQuadric implements Serializable {

    /**
     * Constructor.
     */
    public Quadric() {
<span class="fc" id="L35">        super();</span>
<span class="fc" id="L36">    }</span>

    /**
     * Constructor of this class. This constructor accepts every parameter
     * describing a quadric (parameters a, b, c, d, e, f, g, h, i, j).
     *
     * @param a Parameter A of the quadric.
     * @param b Parameter B of the quadric.
     * @param c Parameter C of the quadric.
     * @param d Parameter D of the quadric.
     * @param e Parameter E of the quadric.
     * @param f Parameter F of the quadric.
     * @param g Parameter G of the quadric.
     * @param h Parameter H of the quadric.
     * @param i Parameter I of the quadric.
     * @param j Parameter J of the quadric.
     */
    public Quadric(final double a, final double b, final double c, final double d, final double e, final double f,
                   final double g, final double h, final double i, final double j) {
<span class="fc" id="L55">        super(a, b, c, d, e, f, g, h, i, j);</span>
<span class="fc" id="L56">    }</span>

    /**
     * Constructor of this class. This constructor accepts a Matrix describing
     * a quadric.
     *
     * @param m Matrix describing a quadric 4x4 Matrix describing the quadric.
     * @throws IllegalArgumentException    Raised when the size of the matrix is
     *                                     not 4x4.
     * @throws NonSymmetricMatrixException Raised when the quadric matrix is not
     *                                     symmetric.
     */
    public Quadric(final Matrix m) throws NonSymmetricMatrixException {
<span class="fc" id="L69">        super(m);</span>
<span class="fc" id="L70">    }</span>

    /**
     * Creates quadric where provided points are contained (are locus).
     *
     * @param point1 1st point.
     * @param point2 2nd point.
     * @param point3 3rd point.
     * @param point4 4th point.
     * @param point5 5th point.
     * @param point6 6th point.
     * @param point7 7th point.
     * @param point8 8th point.
     * @param point9 9th point.
     * @throws CoincidentPointsException Raised if points are coincident or
     *                                   produce a degenerated configuration.
     */
    public Quadric(final Point3D point1, final Point3D point2, final Point3D point3, final Point3D point4,
                   final Point3D point5, final Point3D point6, final Point3D point7, final Point3D point8,
<span class="fc" id="L89">                   final Point3D point9) throws CoincidentPointsException {</span>
<span class="fc" id="L90">        setParametersFromPoints(point1, point2, point3, point4, point5, point6, point7, point8, point9);</span>
<span class="fc" id="L91">    }</span>

    /**
     * Checks if the given point is locus (lies within) this quadric.
     *
     * @param point     Point to be checked.
     * @param threshold Threshold of distance to determine whether the point
     *                  is locus of the quadric or not. Threshold might be needed because of
     *                  machine precision. If not provided DEFAULT_LOCUS_THRESHOLD will be used
     *                  instead.
     * @return True if the point lies within this quadric, false otherwise.
     * @throws IllegalArgumentException Raised if threshold is negative.
     */
    public boolean isLocus(final Point3D point, final double threshold) {
<span class="pc bpc" id="L105" title="1 of 2 branches missed.">        if (threshold &lt; MIN_THRESHOLD) {</span>
<span class="nc" id="L106">            throw new IllegalArgumentException();</span>
        }

        try {
<span class="fc" id="L110">            normalize();</span>
<span class="fc" id="L111">            final var q = asMatrix();</span>
<span class="fc" id="L112">            final var homPoint = new Matrix(Point3D.POINT3D_HOMOGENEOUS_COORDINATES_LENGTH, 1);</span>
<span class="fc" id="L113">            point.normalize();</span>
<span class="fc" id="L114">            homPoint.setElementAt(0, 0, point.getHomX());</span>
<span class="fc" id="L115">            homPoint.setElementAt(1, 0, point.getHomY());</span>
<span class="fc" id="L116">            homPoint.setElementAt(2, 0, point.getHomZ());</span>
<span class="fc" id="L117">            homPoint.setElementAt(3, 0, point.getHomW());</span>
<span class="fc" id="L118">            final var locusMatrix = homPoint.transposeAndReturnNew();</span>
<span class="fc" id="L119">            locusMatrix.multiply(q);</span>
<span class="fc" id="L120">            locusMatrix.multiply(homPoint);</span>

<span class="fc bfc" id="L122" title="All 2 branches covered.">            return Math.abs(locusMatrix.getElementAt(0, 0)) &lt; threshold;</span>
<span class="nc" id="L123">        } catch (final WrongSizeException e) {</span>
<span class="nc" id="L124">            return false;</span>
        }
    }

    /**
     * Checks if the given point is locus (lies within) this quadric.
     *
     * @param point Point to be checked.
     * @return True if the point lies within this conic, false otherwise
     * @see #isLocus(Point3D, double)
     */
    public boolean isLocus(final Point3D point) {
<span class="fc" id="L136">        return isLocus(point, DEFAULT_LOCUS_THRESHOLD);</span>
    }

    /**
     * Computes the angle between two 3D points using this quadric as a geometry
     * base.
     *
     * @param pointA First point.
     * @param pointB Second point.
     * @return Angle between provided points given in radians.
     */
    public double angleBetweenPoints(final Point3D pointA, final Point3D pointB) {
        try {
            // retrieve quadric as matrix
<span class="fc" id="L150">            final var q = asMatrix();</span>
<span class="fc" id="L151">            final var transHomPointA = new Matrix(1, Point3D.POINT3D_HOMOGENEOUS_COORDINATES_LENGTH);</span>
<span class="fc" id="L152">            pointA.normalize();</span>
<span class="fc" id="L153">            transHomPointA.setElementAt(0, 0, pointA.getHomX());</span>
<span class="fc" id="L154">            transHomPointA.setElementAt(0, 1, pointA.getHomY());</span>
<span class="fc" id="L155">            transHomPointA.setElementAt(0, 2, pointA.getHomZ());</span>
<span class="fc" id="L156">            transHomPointA.setElementAt(0, 3, pointA.getHomW());</span>

<span class="fc" id="L158">            final var tmp = transHomPointA.multiplyAndReturnNew(q);</span>
<span class="fc" id="L159">            tmp.multiply(transHomPointA.transposeAndReturnNew()); //This is</span>
            // homPointA' * Q * homPointA

<span class="fc" id="L162">            final var normA = tmp.getElementAt(0, 0);</span>

<span class="fc" id="L164">            final var homPointB = new Matrix(Point3D.POINT3D_HOMOGENEOUS_COORDINATES_LENGTH, 1);</span>
<span class="fc" id="L165">            pointB.normalize();</span>
<span class="fc" id="L166">            homPointB.setElementAt(0, 0, pointB.getHomX());</span>
<span class="fc" id="L167">            homPointB.setElementAt(1, 0, pointB.getHomY());</span>
<span class="fc" id="L168">            homPointB.setElementAt(2, 0, pointB.getHomZ());</span>
<span class="fc" id="L169">            homPointB.setElementAt(3, 0, pointB.getHomW());</span>

<span class="fc" id="L171">            homPointB.transpose(tmp);</span>
<span class="fc" id="L172">            tmp.multiply(q);</span>
<span class="fc" id="L173">            tmp.multiply(homPointB);</span>

<span class="fc" id="L175">            final var normB = tmp.getElementAt(0, 0);</span>

<span class="fc" id="L177">            transHomPointA.multiply(q);</span>
<span class="fc" id="L178">            transHomPointA.multiply(homPointB);</span>
            // This is homPointA' * Q * homPointB

<span class="fc" id="L181">            final var angleNumerator = transHomPointA.getElementAt(0, 0);</span>

<span class="fc" id="L183">            final var cosTheta = angleNumerator / Math.sqrt(normA * normB);</span>
<span class="fc" id="L184">            return Math.acos(cosTheta);</span>
<span class="nc" id="L185">        } catch (final WrongSizeException ignore) {</span>
            // This will never happen
<span class="nc" id="L187">            return 0.0;</span>
        }
    }

    /**
     * Checks if two points are perpendicular in the geometry base generated by
     * this quadric.
     *
     * @param pointA    First point.
     * @param pointB    Second point.
     * @param threshold Threshold to determine whether the points are
     *                  perpendicular or not. If the dot product between provided points and this
     *                  quadric is greater than provided threshold, then points won't be assumed
     *                  to be perpendicular. Threshold is provided because of machine precision
     *                  limits, if not provided DEFAULT_PERPENDICULAR_THRESHOLD will be used
     *                  instead.
     * @return True if points are perpendicular, false otherwise.
     * @throws IllegalArgumentException Raised if threshold is negative.
     */
    public boolean arePerpendicularPoints(final Point3D pointA, final Point3D pointB, final double threshold) {
        try {
            // retrieve quadric as matrix
<span class="fc" id="L209">            final var transHomPointA = new Matrix(1, Point3D.POINT3D_HOMOGENEOUS_COORDINATES_LENGTH);</span>
<span class="fc" id="L210">            pointA.normalize();</span>
<span class="fc" id="L211">            transHomPointA.setElementAt(0, 0, pointA.getHomX());</span>
<span class="fc" id="L212">            transHomPointA.setElementAt(0, 1, pointA.getHomY());</span>
<span class="fc" id="L213">            transHomPointA.setElementAt(0, 2, pointA.getHomZ());</span>
<span class="fc" id="L214">            transHomPointA.setElementAt(0, 3, pointA.getHomW());</span>

<span class="fc" id="L216">            final var homPointB = new Matrix(Point3D.POINT3D_HOMOGENEOUS_COORDINATES_LENGTH, 1);</span>
<span class="fc" id="L217">            pointB.normalize();</span>
<span class="fc" id="L218">            homPointB.setElementAt(0, 0, pointB.getHomX());</span>
<span class="fc" id="L219">            homPointB.setElementAt(1, 0, pointB.getHomY());</span>
<span class="fc" id="L220">            homPointB.setElementAt(2, 0, pointB.getHomZ());</span>
<span class="fc" id="L221">            homPointB.setElementAt(3, 0, pointB.getHomW());</span>

<span class="fc" id="L223">            normalize();</span>
<span class="fc" id="L224">            final var q = asMatrix();</span>
<span class="fc" id="L225">            transHomPointA.multiply(q);</span>
<span class="fc" id="L226">            transHomPointA.multiply(homPointB);</span>
            // This is homPointA' * Q * homPointB

<span class="fc" id="L229">            final var perpend = transHomPointA.getElementAt(0, 0);</span>

<span class="fc bfc" id="L231" title="All 2 branches covered.">            return Math.abs(perpend) &lt; threshold;</span>
<span class="nc" id="L232">        } catch (final WrongSizeException ignore) {</span>
            // This will never happen
<span class="nc" id="L234">            return false;</span>
        }
    }

    /**
     * Checks if two points are perpendicular in the geometry base generated by
     * this quadric.
     *
     * @param pointA First point.
     * @param pointB Second point.
     * @return True if points are perpendicular, false otherwise.
     * @see #arePerpendicularPoints(Point3D, Point3D, double)
     */
    public boolean arePerpendicularPoints(final Point3D pointA, final Point3D pointB) {
<span class="fc" id="L248">        return arePerpendicularPoints(pointA, pointB, DEFAULT_PERPENDICULAR_THRESHOLD);</span>
    }

    /**
     * Sets the values of the dual quadric corresponding to this quadric
     * instance into provided dualQuadric instance.
     * The dual quadric is equal to the inverse of the quadric matrix.
     *
     * @param dualQuadric Dual quadric instance where the values of the dual
     *                    quadric of this quadric instance will be stored.
     * @throws DualQuadricNotAvailableException Raised if the dual quadric does
     *                                          not exist because this quadric instance is degenerate (its inverse
     *                                          cannot be computed).
     */
    public void dualQuadric(final DualQuadric dualQuadric) throws DualQuadricNotAvailableException {
<span class="fc" id="L263">        final var quadricMatrix = asMatrix();</span>
        try {
<span class="fc" id="L265">            final var invMatrix = com.irurueta.algebra.Utils.inverse(quadricMatrix);</span>

            // ensure that resulting matrix after inversion is symmetric
            // by computing the mean of off-diagonal elements
<span class="fc" id="L269">            final var a = invMatrix.getElementAt(0, 0);</span>
<span class="fc" id="L270">            final var b = invMatrix.getElementAt(1, 1);</span>
<span class="fc" id="L271">            final var c = invMatrix.getElementAt(2, 2);</span>
<span class="fc" id="L272">            final var d = 0.5 * (invMatrix.getElementAt(0, 1) + invMatrix.getElementAt(1, 0));</span>
<span class="fc" id="L273">            final var e = 0.5 * (invMatrix.getElementAt(2, 1) + invMatrix.getElementAt(1, 2));</span>
<span class="fc" id="L274">            final var f = 0.5 * (invMatrix.getElementAt(2, 0) + invMatrix.getElementAt(0, 2));</span>
<span class="fc" id="L275">            final var g = 0.5 * (invMatrix.getElementAt(3, 0) + invMatrix.getElementAt(0, 3));</span>
<span class="fc" id="L276">            final var h = 0.5 * (invMatrix.getElementAt(3, 1) + invMatrix.getElementAt(1, 3));</span>
<span class="fc" id="L277">            final var i = 0.5 * (invMatrix.getElementAt(3, 2) + invMatrix.getElementAt(2, 3));</span>
<span class="fc" id="L278">            final var j = invMatrix.getElementAt(3, 3);</span>
<span class="fc" id="L279">            dualQuadric.setParameters(a, b, c, d, e, f, g, h, i, j);</span>
<span class="nc" id="L280">        } catch (final AlgebraException e) {</span>
<span class="nc" id="L281">            throw new DualQuadricNotAvailableException(e);</span>
<span class="fc" id="L282">        }</span>
<span class="fc" id="L283">    }</span>

    /**
     * Computes the dual quadric of this quadric.
     * The dual quadric is equal to the inverse of the quadric matrix
     *
     * @return A new DualQuadric corresponding to the dual quadric of this
     * instance.
     * @throws DualQuadricNotAvailableException Raised if the dual quadric does
     *                                          not exist because this quadric instance is degenerate (its inverse cannot
     *                                          be computed).
     */
    public DualQuadric getDualQuadric() throws DualQuadricNotAvailableException {
<span class="fc" id="L296">        final var dualQuadric = new DualQuadric();</span>
<span class="fc" id="L297">        dualQuadric(dualQuadric);</span>
<span class="fc" id="L298">        return dualQuadric;</span>
    }

    /**
     * Sets parameters of this quadric so that provided points lie within it
     * (are locus).
     *
     * @param point1 1st point.
     * @param point2 2nd point.
     * @param point3 3rd point.
     * @param point4 4th point.
     * @param point5 5th point.
     * @param point6 6th point.
     * @param point7 7th point.
     * @param point8 8th point.
     * @param point9 9th point.
     * @throws CoincidentPointsException Raised if points are coincident or
     *                                   produce a degenerated configuration.
     */
    public final void setParametersFromPoints(
            final Point3D point1, final Point3D point2, final Point3D point3, final Point3D point4,
            final Point3D point5, final Point3D point6, final Point3D point7, final Point3D point8,
            final Point3D point9) throws CoincidentPointsException {

        // normalize points to increase accuracy
<span class="fc" id="L323">        point1.normalize();</span>
<span class="fc" id="L324">        point2.normalize();</span>
<span class="fc" id="L325">        point3.normalize();</span>
<span class="fc" id="L326">        point4.normalize();</span>
<span class="fc" id="L327">        point5.normalize();</span>
<span class="fc" id="L328">        point6.normalize();</span>
<span class="fc" id="L329">        point7.normalize();</span>
<span class="fc" id="L330">        point8.normalize();</span>
<span class="fc" id="L331">        point9.normalize();</span>

        try {
            // each point belonging to a quadric follows equation:
            // p' * Q * p = 0 ==&gt;
            // x^2 + y^2 + z^2 + 2*x*y + 2*x*z + 2*y*z + 2*x*w + 2*y*w +
            // 2*z*w + w^2 = 0

<span class="fc" id="L339">            final var m = new Matrix(9, 10);</span>
<span class="fc" id="L340">            var x = point1.getHomX();</span>
<span class="fc" id="L341">            var y = point1.getHomY();</span>
<span class="fc" id="L342">            var z = point1.getHomZ();</span>
<span class="fc" id="L343">            var w = point1.getHomW();</span>
<span class="fc" id="L344">            m.setElementAt(0, 0, x * x);</span>
<span class="fc" id="L345">            m.setElementAt(0, 1, y * y);</span>
<span class="fc" id="L346">            m.setElementAt(0, 2, z * z);</span>
<span class="fc" id="L347">            m.setElementAt(0, 3, 2.0 * x * y);</span>
<span class="fc" id="L348">            m.setElementAt(0, 4, 2.0 * x * z);</span>
<span class="fc" id="L349">            m.setElementAt(0, 5, 2.0 * y * z);</span>
<span class="fc" id="L350">            m.setElementAt(0, 6, 2.0 * x * w);</span>
<span class="fc" id="L351">            m.setElementAt(0, 7, 2.0 * y * w);</span>
<span class="fc" id="L352">            m.setElementAt(0, 8, 2.0 * z * w);</span>
<span class="fc" id="L353">            m.setElementAt(0, 9, w * w);</span>
<span class="fc" id="L354">            x = point2.getHomX();</span>
<span class="fc" id="L355">            y = point2.getHomY();</span>
<span class="fc" id="L356">            z = point2.getHomZ();</span>
<span class="fc" id="L357">            w = point2.getHomW();</span>
<span class="fc" id="L358">            m.setElementAt(1, 0, x * x);</span>
<span class="fc" id="L359">            m.setElementAt(1, 1, y * y);</span>
<span class="fc" id="L360">            m.setElementAt(1, 2, z * z);</span>
<span class="fc" id="L361">            m.setElementAt(1, 3, 2.0 * x * y);</span>
<span class="fc" id="L362">            m.setElementAt(1, 4, 2.0 * x * z);</span>
<span class="fc" id="L363">            m.setElementAt(1, 5, 2.0 * y * z);</span>
<span class="fc" id="L364">            m.setElementAt(1, 6, 2.0 * x * w);</span>
<span class="fc" id="L365">            m.setElementAt(1, 7, 2.0 * y * w);</span>
<span class="fc" id="L366">            m.setElementAt(1, 8, 2.0 * z * w);</span>
<span class="fc" id="L367">            m.setElementAt(1, 9, w * w);</span>
<span class="fc" id="L368">            x = point3.getHomX();</span>
<span class="fc" id="L369">            y = point3.getHomY();</span>
<span class="fc" id="L370">            z = point3.getHomZ();</span>
<span class="fc" id="L371">            w = point3.getHomW();</span>
<span class="fc" id="L372">            m.setElementAt(2, 0, x * x);</span>
<span class="fc" id="L373">            m.setElementAt(2, 1, y * y);</span>
<span class="fc" id="L374">            m.setElementAt(2, 2, z * z);</span>
<span class="fc" id="L375">            m.setElementAt(2, 3, 2.0 * x * y);</span>
<span class="fc" id="L376">            m.setElementAt(2, 4, 2.0 * x * z);</span>
<span class="fc" id="L377">            m.setElementAt(2, 5, 2.0 * y * z);</span>
<span class="fc" id="L378">            m.setElementAt(2, 6, 2.0 * x * w);</span>
<span class="fc" id="L379">            m.setElementAt(2, 7, 2.0 * y * w);</span>
<span class="fc" id="L380">            m.setElementAt(2, 8, 2.0 * z * w);</span>
<span class="fc" id="L381">            m.setElementAt(2, 9, w * w);</span>
<span class="fc" id="L382">            x = point4.getHomX();</span>
<span class="fc" id="L383">            y = point4.getHomY();</span>
<span class="fc" id="L384">            z = point4.getHomZ();</span>
<span class="fc" id="L385">            w = point4.getHomW();</span>
<span class="fc" id="L386">            m.setElementAt(3, 0, x * x);</span>
<span class="fc" id="L387">            m.setElementAt(3, 1, y * y);</span>
<span class="fc" id="L388">            m.setElementAt(3, 2, z * z);</span>
<span class="fc" id="L389">            m.setElementAt(3, 3, 2.0 * x * y);</span>
<span class="fc" id="L390">            m.setElementAt(3, 4, 2.0 * x * z);</span>
<span class="fc" id="L391">            m.setElementAt(3, 5, 2.0 * y * z);</span>
<span class="fc" id="L392">            m.setElementAt(3, 6, 2.0 * x * w);</span>
<span class="fc" id="L393">            m.setElementAt(3, 7, 2.0 * y * w);</span>
<span class="fc" id="L394">            m.setElementAt(3, 8, 2.0 * z * w);</span>
<span class="fc" id="L395">            m.setElementAt(3, 9, w * w);</span>
<span class="fc" id="L396">            x = point5.getHomX();</span>
<span class="fc" id="L397">            y = point5.getHomY();</span>
<span class="fc" id="L398">            z = point5.getHomZ();</span>
<span class="fc" id="L399">            w = point5.getHomW();</span>
<span class="fc" id="L400">            m.setElementAt(4, 0, x * x);</span>
<span class="fc" id="L401">            m.setElementAt(4, 1, y * y);</span>
<span class="fc" id="L402">            m.setElementAt(4, 2, z * z);</span>
<span class="fc" id="L403">            m.setElementAt(4, 3, 2.0 * x * y);</span>
<span class="fc" id="L404">            m.setElementAt(4, 4, 2.0 * x * z);</span>
<span class="fc" id="L405">            m.setElementAt(4, 5, 2.0 * y * z);</span>
<span class="fc" id="L406">            m.setElementAt(4, 6, 2.0 * x * w);</span>
<span class="fc" id="L407">            m.setElementAt(4, 7, 2.0 * y * w);</span>
<span class="fc" id="L408">            m.setElementAt(4, 8, 2.0 * z * w);</span>
<span class="fc" id="L409">            m.setElementAt(4, 9, w * w);</span>
<span class="fc" id="L410">            x = point6.getHomX();</span>
<span class="fc" id="L411">            y = point6.getHomY();</span>
<span class="fc" id="L412">            z = point6.getHomZ();</span>
<span class="fc" id="L413">            w = point6.getHomW();</span>
<span class="fc" id="L414">            m.setElementAt(5, 0, x * x);</span>
<span class="fc" id="L415">            m.setElementAt(5, 1, y * y);</span>
<span class="fc" id="L416">            m.setElementAt(5, 2, z * z);</span>
<span class="fc" id="L417">            m.setElementAt(5, 3, 2.0 * x * y);</span>
<span class="fc" id="L418">            m.setElementAt(5, 4, 2.0 * x * z);</span>
<span class="fc" id="L419">            m.setElementAt(5, 5, 2.0 * y * z);</span>
<span class="fc" id="L420">            m.setElementAt(5, 6, 2.0 * x * w);</span>
<span class="fc" id="L421">            m.setElementAt(5, 7, 2.0 * y * w);</span>
<span class="fc" id="L422">            m.setElementAt(5, 8, 2.0 * z * w);</span>
<span class="fc" id="L423">            m.setElementAt(5, 9, w * w);</span>
<span class="fc" id="L424">            x = point7.getHomX();</span>
<span class="fc" id="L425">            y = point7.getHomY();</span>
<span class="fc" id="L426">            z = point7.getHomZ();</span>
<span class="fc" id="L427">            w = point7.getHomW();</span>
<span class="fc" id="L428">            m.setElementAt(6, 0, x * x);</span>
<span class="fc" id="L429">            m.setElementAt(6, 1, y * y);</span>
<span class="fc" id="L430">            m.setElementAt(6, 2, z * z);</span>
<span class="fc" id="L431">            m.setElementAt(6, 3, 2.0 * x * y);</span>
<span class="fc" id="L432">            m.setElementAt(6, 4, 2.0 * x * z);</span>
<span class="fc" id="L433">            m.setElementAt(6, 5, 2.0 * y * z);</span>
<span class="fc" id="L434">            m.setElementAt(6, 6, 2.0 * x * w);</span>
<span class="fc" id="L435">            m.setElementAt(6, 7, 2.0 * y * w);</span>
<span class="fc" id="L436">            m.setElementAt(6, 8, 2.0 * z * w);</span>
<span class="fc" id="L437">            m.setElementAt(6, 9, w * w);</span>
<span class="fc" id="L438">            x = point8.getHomX();</span>
<span class="fc" id="L439">            y = point8.getHomY();</span>
<span class="fc" id="L440">            z = point8.getHomZ();</span>
<span class="fc" id="L441">            w = point8.getHomW();</span>
<span class="fc" id="L442">            m.setElementAt(7, 0, x * x);</span>
<span class="fc" id="L443">            m.setElementAt(7, 1, y * y);</span>
<span class="fc" id="L444">            m.setElementAt(7, 2, z * z);</span>
<span class="fc" id="L445">            m.setElementAt(7, 3, 2.0 * x * y);</span>
<span class="fc" id="L446">            m.setElementAt(7, 4, 2.0 * x * z);</span>
<span class="fc" id="L447">            m.setElementAt(7, 5, 2.0 * y * z);</span>
<span class="fc" id="L448">            m.setElementAt(7, 6, 2.0 * x * w);</span>
<span class="fc" id="L449">            m.setElementAt(7, 7, 2.0 * y * w);</span>
<span class="fc" id="L450">            m.setElementAt(7, 8, 2.0 * z * w);</span>
<span class="fc" id="L451">            m.setElementAt(7, 9, w * w);</span>
<span class="fc" id="L452">            x = point9.getHomX();</span>
<span class="fc" id="L453">            y = point9.getHomY();</span>
<span class="fc" id="L454">            z = point9.getHomZ();</span>
<span class="fc" id="L455">            w = point9.getHomW();</span>
<span class="fc" id="L456">            m.setElementAt(8, 0, x * x);</span>
<span class="fc" id="L457">            m.setElementAt(8, 1, y * y);</span>
<span class="fc" id="L458">            m.setElementAt(8, 2, z * z);</span>
<span class="fc" id="L459">            m.setElementAt(8, 3, 2.0 * x * y);</span>
<span class="fc" id="L460">            m.setElementAt(8, 4, 2.0 * x * z);</span>
<span class="fc" id="L461">            m.setElementAt(8, 5, 2.0 * y * z);</span>
<span class="fc" id="L462">            m.setElementAt(8, 6, 2.0 * x * w);</span>
<span class="fc" id="L463">            m.setElementAt(8, 7, 2.0 * y * w);</span>
<span class="fc" id="L464">            m.setElementAt(8, 8, 2.0 * z * w);</span>
<span class="fc" id="L465">            m.setElementAt(8, 9, w * w);</span>

            // normalize each row to increase accuracy
<span class="fc" id="L468">            final var row = new double[10];</span>
            double rowNorm;
<span class="fc bfc" id="L470" title="All 2 branches covered.">            for (var j = 0; j &lt; 9; j++) {</span>
<span class="fc" id="L471">                m.getSubmatrixAsArray(j, 0, j, 9, row);</span>
<span class="fc" id="L472">                rowNorm = com.irurueta.algebra.Utils.normF(row);</span>
<span class="fc bfc" id="L473" title="All 2 branches covered.">                for (var i = 0; i &lt; 10; i++) {</span>
<span class="fc" id="L474">                    m.setElementAt(j, i, m.getElementAt(j, i) / rowNorm);</span>
                }
            }

<span class="fc" id="L478">            final var decomposer = new SingularValueDecomposer(m);</span>
<span class="fc" id="L479">            decomposer.decompose();</span>

<span class="fc bfc" id="L481" title="All 2 branches covered.">            if (decomposer.getRank() &lt; 9) {</span>
<span class="fc" id="L482">                throw new CoincidentPointsException();</span>
            }

            // the right null-space of m contains the parameters a, b, c, d, e ,f
            // of the conic
<span class="fc" id="L487">            final var v = decomposer.getV();</span>

<span class="fc" id="L489">            final var a = v.getElementAt(0, 9);</span>
<span class="fc" id="L490">            final var b = v.getElementAt(1, 9);</span>
<span class="fc" id="L491">            final var c = v.getElementAt(2, 9);</span>
<span class="fc" id="L492">            final var d = v.getElementAt(3, 9);</span>

<span class="fc" id="L494">            final var f = v.getElementAt(4, 9);</span>
<span class="fc" id="L495">            final var e = v.getElementAt(5, 9);</span>

<span class="fc" id="L497">            final var g = v.getElementAt(6, 9);</span>
<span class="fc" id="L498">            final var h = v.getElementAt(7, 9);</span>
<span class="fc" id="L499">            final var i = v.getElementAt(8, 9);</span>
<span class="fc" id="L500">            final var j = v.getElementAt(9, 9);</span>

<span class="fc" id="L502">            setParameters(a, b, c, d, e, f, g, h, i, j);</span>
<span class="nc" id="L503">        } catch (final AlgebraException ex) {</span>
<span class="nc" id="L504">            throw new CoincidentPointsException(ex);</span>
<span class="fc" id="L505">        }</span>
<span class="fc" id="L506">    }</span>

    /**
     * Returns a plane tangent to this quadric at provided point, as long as
     * the provided point is locus of this quadric.
     *
     * @param point point where plane must be tangent to quadric.
     * @return a plane tangent to this quadric.
     * @throws NotLocusException if provided point is not locus of this quadric.
     */
    public Plane getTangentPlaneAt(final Point3D point) throws NotLocusException {
<span class="fc" id="L517">        final var plane = new Plane();</span>
<span class="fc" id="L518">        tangentPlaneAt(point, plane, DEFAULT_LOCUS_THRESHOLD);</span>
<span class="fc" id="L519">        return plane;</span>

    }

    /**
     * Computes a plane tangent to this quadric at provided point, as long as
     * the provided point is locus of this quadric up to provided threshold.
     *
     * @param point     point where plane must be tangent to quadric.
     * @param plane     plane where computed result will be stored.
     * @param threshold threshold to determine if provided point is locus or not
     *                  of this quadric. Usually this is a small value close to zero.
     * @throws NotLocusException        if provided point is not locus of this quadric.
     * @throws IllegalArgumentException if provided threshold is negative.
     */
    public void tangentPlaneAt(final Point3D point, final Plane plane, final double threshold)
            throws NotLocusException {

<span class="pc bpc" id="L537" title="1 of 2 branches missed.">        if (!isLocus(point, threshold)) {</span>
<span class="nc" id="L538">            throw new NotLocusException();</span>
        }

<span class="fc" id="L541">        point.normalize();</span>
<span class="fc" id="L542">        normalize();</span>

<span class="fc" id="L544">        final var q = asMatrix();</span>

        try {
<span class="fc" id="L547">            final var p = new Matrix(Point3D.POINT3D_HOMOGENEOUS_COORDINATES_LENGTH, 1);</span>
<span class="fc" id="L548">            p.setElementAt(0, 0, point.getHomX());</span>
<span class="fc" id="L549">            p.setElementAt(1, 0, point.getHomY());</span>
<span class="fc" id="L550">            p.setElementAt(2, 0, point.getHomZ());</span>
<span class="fc" id="L551">            p.setElementAt(3, 0, point.getHomW());</span>

<span class="fc" id="L553">            q.multiply(p);</span>
<span class="nc" id="L554">        } catch (final WrongSizeException ignore) {</span>
            // never happens
<span class="fc" id="L556">        }</span>

<span class="fc" id="L558">        plane.setParameters(q.getElementAt(0, 0), q.getElementAt(1, 0),</span>
<span class="fc" id="L559">                q.getElementAt(2, 0), q.getElementAt(3, 0));</span>
<span class="fc" id="L560">    }</span>

    /**
     * Intersects this quadric with provided plane.
     * Notice that result of intersection is expressed on original quadric
     * coordinates.
     * If resulting conic needs to be expressed in terms of plane coordinates,
     * then the plane and the conic must be rotated so that the plane becomes
     * an xy-plane.
     *
     * @param plane  plane to intersect this quadric with.
     * @param result instance where resulting intersection will be stored.
     */
    public void intersectWith(final Plane plane, final Conic result) {
        // A plane follows expression: A*x + B*y + C*z + D*w = 0

        // A quadric has the following matrix form:
        // Q =   [A  D   F   G]
        //       [D  B   E   H]
        //       [F  E   C   I]
        //       [G  H   I   J]
        // [x y z w][A D F G][x] = [x y z w][A*x + D*y + F*z + G*w] =
        //          [D B E H][y]            [D*x + B*y + E*z + H*w]
        //          [F E C I][z]            [F*x + E*y + C*z + I*w]
        //          [G H I J][w]            [G*x + H*y + I*z + J*w]
        // = A*x^2 + D*x*y + F*x*z + G*x*w + D*x*y + B*y^2 + E*y*z + H*y*w +
        // F*x*z + E*y*z + C*z^2 + I*z*w + G*x*w + H*y*w + I*z*w + J*w^2 =
        // = A*x^2 + B*y^2 + C*z^2 + 2*D*x*y + 2*E*y*z + 2*F*x*z + 2*G*x*w + 2*H*y*w + 2*I*z*w + J*w^2
        // which follows expression:
        // A*x^2 + B*y^2 + C*z^2 + 2*D*x*y + 2*E*y*z + 2*F*x*z + 2*G*x*w + 2*H*y*w + 2*I*z*w + J*w^2 = 0

        // A conic has the following matrix form:
        // C = [A    B   D]
        //     [B    C   E]
        //     [D    E   F]
        // [x y w][A B D][x] = [x y w][A*x + B*y + D*w] =
        //        [B C E][y]          [B*x + C*y + E*w]
        //        [D E F][w]          [D*x + E*y + F*w]
        // = A*x^2 + B*x*y + D*x*w + B*x*y + C*y^2 + E*y*w + D*x*w + E*y*w + F*w^2 =
        // = A*x^2 + 2*B*x*y + C*y^2 + 2*D*x*w + 2*E*y*w + F*w^2
        // which follows expression:
        // A*x^2 + 2*B*x*y + C*y^2 + 2*D*x*w + 2*E*y*w + F*w^2 = 0

        // Quadric parameters
<span class="fc" id="L604">        final var aQ = getA();</span>
<span class="fc" id="L605">        final var bQ = getB();</span>
<span class="fc" id="L606">        final var cQ = getC();</span>
<span class="fc" id="L607">        final var dQ = getD();</span>
<span class="fc" id="L608">        final var eQ = getE();</span>
<span class="fc" id="L609">        final var fQ = getF();</span>
<span class="fc" id="L610">        final var gQ = getG();</span>
<span class="fc" id="L611">        final var hQ = getH();</span>
<span class="fc" id="L612">        final var iQ = getI();</span>
<span class="fc" id="L613">        final var jQ = getJ();</span>

        // Plane parameters
<span class="fc" id="L616">        final var aP = plane.getA();</span>
<span class="fc" id="L617">        final var bP = plane.getB();</span>
<span class="fc" id="L618">        final var cP = plane.getC();</span>
<span class="fc" id="L619">        final var dP = plane.getD();</span>

        // we solve the following system of equations:
        // aQ*x^2 + bQ*y^2 + cQ*z^2 + 2*dQ*x*y + 2*eQ*y*z + 2*fQ*x*z + 2*gQ*x*w + 2*hQ*y*w + 2*iQ*z*w + jQ*w^2 = 0
        // aP*x + bP*y + cP*z + dP*w = 0

        // Isolating z in plane equation:
        // z = (- aP*x - bP*y - dP*w)/cP

        // and substituting in quadric equation:
        // aQ*x^2 + bQ*y^2 + cQ*(- aP*x - bP*y - dP*w)^2/cP^2 + 2*dQ*x*y +
        // 2*eQ*y*(- aP*x - bP*y - dP*w)/cP + 2*fQ*x*(- aP*x - bP*y - dP*w)/cP +
        // 2*gQ*x*w + 2*hQ*y*w + 2*iQ*(- aP*x - bP*y - dP*w)/cP*w + jQ*w^2 = 0

        // aQ*x^2 + bQ*y^2 + cQ*(- aP*x - bP*y - dP*w)^2/cP^2 + 2*dQ*x*y +
        // -2*eQ*aP/cP*x*y -2*eQ*bP/cP*y^2 -2*eQ*dP/cP*y*w +
        // -2*fQ*aP/cP*x^2 -2*fQ*bP/cP*x*y -2*fQ*dP/cP*x*w +
        // 2*gQ*x*w + 2*hQ*y*w +
        // -2*iQ*aP/cP*x*w -2*iQ*bP/cP*y*w -2*iQ*dP/cP*w^2 +
        // jQ*w^2 = 0

        // aQ*x^2 + bQ*y^2 +
        // aP^2*cQ/cP^2*x^2 + 2*aP*bP*cQ/cP^2*x*y + 2*aP*cQ*dP/cP^2*x*w +
        // bP^2*cQ/cP^2*y^2 + 2*bP*cQ*dP/cP^2*y*w + cQ*dP^2/cP^2*w^2 +
        // 2*dQ*x*y +
        // -2*eQ*aP/cP*x*y -2*eQ*bP/cP*y^2 -2*eQ*dP/cP*y*w +
        // -2*fQ*aP/cP*x^2 -2*fQ*bP/cP*x*y -2*fQ*dP/cP*x*w +
        // 2*gQ*x*w + 2*hQ*y*w +
        // -2*iQ*aP/cP*x*w -2*iQ*bP/cP*y*w -2*iQ*dP/cP*w^2 +
        // jQ*w^2 = 0

        // (aQ + aP^2*cQ/cP^2 -2*fQ*aP/cP)*x^2 +
        // (2*aP*bP*cQ/cP^2 + 2*dQ -2*eQ*aP/cP -2*fQ*bP/cP)*x*y +
        // (bQ + bP^2*cQ/cP^2 -2*eQ*bP/cP)*y^2 +
        // (2*aP*cQ*dP/cP^2 -2*fQ*dP/cP + 2*gQ -2*iQ*aP/cP)*x*w +
        // (2*bP*cQ*dP/cP^2 -2*eQ*dP/cP + 2*hQ -2*iQ*bP/cP)*y*w +
        // (cQ*dP^2/cP^2 -2*iQ*dP/cP + jQ)*w^2 = 0


        // (aQ - 2*aP*fQ/cP + cQ*aP^2/cP^2)*x^2 +
        // 2*(dQ - bP*fQ/cP - eQ*aP/cP + aP*bP*cQ/cP^2)*x*y +
        // 2*(gQ - dP*fQ/cP - aP*iQ/cP + cQ*aP*dP/cP^2)*x*w +
        // (bQ - 2*bP*eQ/cP + cQ*bP^2/cP^2)*y^2 +
        // 2*(hQ - bP*iQ/cP - eQ*dP/cP + cQ*bP*dP/cP^2)*y*w +
        // (jQ - 2*dP*iQ/cP + cQ*dP^2/cP^2)*w^2 = 0


        // Comparing with conic equation:
        // aC*x^2 + 2*bC*x*y + 2*dC*x*w + cC*y^2 + 2*eC*y*w + fC*w^2 = 0

        // then conic parameters become:
        // aC = aQ - 2*aP*fQ/cP + cQ*aP^2/cP^2
        // bC = dQ - bP*fQ/cP - eQ*aP/cP + aP*bP*cQ/cP^2
        // cC = bQ - 2*bP*eQ/cP + cQ*bP^2/cP^2
        // dC = gQ - dP*fQ/cP - aP*iQ/cP + cQ*aP*dP/cP^2
        // eC = hQ - bP*iQ/cP - eQ*dP/cP + cQ*bP*dP/cP^2
        // fC = jQ - 2*dP*iQ/cP + cQ*dP^2/cP^2

<span class="fc" id="L677">        final var aP2 = aP * aP;</span>
<span class="fc" id="L678">        final var bP2 = bP * bP;</span>
<span class="fc" id="L679">        final var cP2 = cP * cP;</span>
<span class="fc" id="L680">        final var dP2 = dP * dP;</span>

<span class="fc" id="L682">        final var aC = aQ - 2.0 * aP * fQ / cP + cQ * aP2 / cP2;</span>
<span class="fc" id="L683">        final var bC = dQ - bP * fQ / cP - eQ * aP / cP + aP * bP * cQ / cP2;</span>
<span class="fc" id="L684">        final var cC = bQ - 2.0 * bP * eQ / cP + cQ * bP2 / cP2;</span>
<span class="fc" id="L685">        final var dC = gQ - dP * fQ / cP - aP * iQ / cP + cQ * aP * dP / cP2;</span>
<span class="fc" id="L686">        final var eC = hQ - bP * iQ / cP - eQ * dP / cP + cQ * bP * dP / cP2;</span>
<span class="fc" id="L687">        final var fC = jQ - 2.0 * dP * iQ / cP + cQ * dP2 / cP2;</span>

<span class="fc" id="L689">        result.setParameters(aC, bC, cC, dC, eC, fC);</span>
<span class="fc" id="L690">    }</span>

    /**
     * Intersects this quadric with provided plane.
     *
     * @param plane plane to intersect this quadric with.
     * @return conic resulting from the intersection.
     */
    public Conic intersectWith(final Plane plane) {
<span class="fc" id="L699">        final var result = new Conic();</span>
<span class="fc" id="L700">        intersectWith(plane, result);</span>
<span class="fc" id="L701">        return result;</span>
    }

    //TODO: shorted distance of point to quadric
    //TODO: closest point to quadric
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>