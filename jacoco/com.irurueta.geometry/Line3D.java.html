<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Line3D.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-geometry</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.geometry</a> &gt; <span class="el_source">Line3D.java</span></div><h1>Line3D.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2012 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.geometry;

import com.irurueta.algebra.AlgebraException;
import com.irurueta.algebra.Matrix;
import com.irurueta.algebra.SingularValueDecomposer;
import com.irurueta.algebra.Utils;

import java.io.Serializable;

/**
 * This class defines a lines in 3D space.
 * A line in 3D space is defined as the intersection of two non-parallel planes.
 */
public class Line3D implements Serializable {

    /**
     * Positive threshold determine whether points lay inside (is locus) of a
     * given line or not.
     */
    public static final double DEFAULT_LOCUS_THRESHOLD = 1e-12;

    /**
     * Minimum allowed threshold
     */
    public static final double MIN_THRESHOLD = 0.0;

    /**
     * Constant defining the size of vector that define the direction of a line
     */
    private static final int INHOM_VECTOR_SIZE = 3;

    /**
     * 1st plane forming this 3D line.
     */
    private Plane plane1;

    /**
     * 2nd plane forming this 3D line.
     */
    private Plane plane2;

    /**
     * Constructor.
     * Sets planes intersecting into this 3D line.
     *
     * @param plane1 1st plane.
     * @param plane2 2nd plane.
     * @throws CoincidentPlanesException Raised if provided planes are
     *                                   coincident and hence never intersect. Notice that parallel planes are
     *                                   not coincident and they intersect at infinity.
     */
<span class="fc" id="L67">    public Line3D(final Plane plane1, final Plane plane2) throws CoincidentPlanesException {</span>
<span class="fc" id="L68">        setPlanes(plane1, plane2);</span>
<span class="fc" id="L69">    }</span>

    /**
     * Constructor.
     * Builds a 3D line passing through provided 2 points.
     *
     * @param point1 1st point.
     * @param point2 2nd point.
     * @throws CoincidentPointsException Raised if provided points are
     *                                   considered to be equal.
     */
<span class="fc" id="L80">    public Line3D(final Point3D point1, final Point3D point2) throws CoincidentPointsException {</span>
<span class="fc" id="L81">        setPlanesFromPoints(point1, point2);</span>
<span class="fc" id="L82">    }</span>

    /**
     * Determines whether provided planes are coincident.
     * Two planes are considered coincident if they are equal up to scale.
     *
     * @param plane1 1st plane.
     * @param plane2 2nd plane.
     * @return True if planes are coincident, false otherwise.
     */
    public static boolean areCoincidentPlanes(final Plane plane1, final Plane plane2) {
        // normalize planes to increase accuracy
<span class="fc" id="L94">        plane1.normalize();</span>
<span class="fc" id="L95">        plane2.normalize();</span>

        try {
<span class="fc" id="L98">            final var m = new Matrix(2, Plane.PLANE_NUMBER_PARAMS);</span>
<span class="fc" id="L99">            m.setElementAt(0, 0, plane1.getA());</span>
<span class="fc" id="L100">            m.setElementAt(0, 1, plane1.getB());</span>
<span class="fc" id="L101">            m.setElementAt(0, 2, plane1.getC());</span>
<span class="fc" id="L102">            m.setElementAt(0, 3, plane1.getD());</span>

<span class="fc" id="L104">            m.setElementAt(1, 0, plane2.getA());</span>
<span class="fc" id="L105">            m.setElementAt(1, 1, plane2.getB());</span>
<span class="fc" id="L106">            m.setElementAt(1, 2, plane2.getC());</span>
<span class="fc" id="L107">            m.setElementAt(1, 3, plane2.getD());</span>

            // check that matrix rank is 2 (and its nullity is also 2), in that
            // case its right null-space has dimension two, which is linear
            // combination of two 3D points (a line in 3D), and line is defined.
            // Note that rank cannot be greater than 2 because matrix m has only
            // 2 rows.
            // If rank is smaller than 2, then the 2 planes are parallel, and the
            // null-space has at least dimension 3, which is a perpendicular
            // plane or the whole space (Depending whether nullity is 3 or 4)
<span class="fc bfc" id="L117" title="All 2 branches covered.">            return Utils.rank(m) &lt; 2;</span>
<span class="nc" id="L118">        } catch (final AlgebraException e) {</span>
            // if for numerical reasons it cannot be determined whether planes
            // are parallel, it will be assumed the worst case, which is that
            // planes are parallel, which is something common for very large
            // values or planes close at infinity
<span class="nc" id="L123">            return true;</span>
        }
    }

    /**
     * Sets intersecting planes for this 3D line.
     * The intersection of provided planes will determine this 3D line.
     *
     * @param plane1 1st plane.
     * @param plane2 2nd plane.
     * @throws CoincidentPlanesException Raised if provided planes are
     *                                   coincident. Notice that parallel planes are not coincident and they
     *                                   intersect at infinity.
     */
    public final void setPlanes(final Plane plane1, final Plane plane2) throws CoincidentPlanesException {
<span class="fc bfc" id="L138" title="All 2 branches covered.">        if (areCoincidentPlanes(plane1, plane2)) {</span>
<span class="fc" id="L139">            throw new CoincidentPlanesException();</span>
        }

<span class="fc" id="L142">        this.plane1 = plane1;</span>
<span class="fc" id="L143">        this.plane2 = plane2;</span>
<span class="fc" id="L144">    }</span>

    /**
     * Sets planes of this 3D line so that it passes through provided points.
     *
     * @param point1 1st point.
     * @param point2 2nd point.
     * @throws CoincidentPointsException Raised if provided points are equal
     *                                   and hence a line cannot be determined.
     */
    public final void setPlanesFromPoints(final Point3D point1, final Point3D point2) throws CoincidentPointsException {
        // build matrix containing director vector on a row
        try {
<span class="fc" id="L157">            final var m = new Matrix(1, INHOM_VECTOR_SIZE);</span>
<span class="fc" id="L158">            m.setElementAt(0, 0, point2.getInhomX() - point1.getInhomX());</span>
<span class="fc" id="L159">            m.setElementAt(0, 1, point2.getInhomY() - point1.getInhomY());</span>
<span class="fc" id="L160">            m.setElementAt(0, 2, point2.getInhomZ() - point1.getInhomZ());</span>

            // m matrix will have rank 1 and nullity 2. The null-space will be
            // formed by two vectors perpendicular to the director vector
<span class="fc" id="L164">            final var decomposer = new SingularValueDecomposer(m);</span>
<span class="fc" id="L165">            decomposer.decompose();</span>

            // check that points are not coincident, and hence all the values of
            // matrix m are not zero
<span class="fc bfc" id="L169" title="All 2 branches covered.">            if (decomposer.getRank() &lt; 1) {</span>
<span class="fc" id="L170">                throw new CoincidentPointsException();</span>
            }

            // last two columns of V contains director vectors of plane1 and
            // plane2
<span class="fc" id="L175">            final var v = decomposer.getV();</span>

<span class="fc" id="L177">            final var directorVector1 = v.getSubmatrixAsArray(0, 1, 2, 1);</span>
<span class="fc" id="L178">            final var directorVector2 = v.getSubmatrixAsArray(0, 2, 2, 2);</span>

<span class="fc" id="L180">            plane1 = new Plane(point1, directorVector1);</span>
<span class="fc" id="L181">            plane2 = new Plane(point1, directorVector2);</span>
<span class="nc" id="L182">        } catch (final AlgebraException e) {</span>
<span class="nc" id="L183">            throw new CoincidentPointsException(e);</span>
<span class="fc" id="L184">        }</span>
<span class="fc" id="L185">    }</span>

    /**
     * Returns 1st plane determining this 3D line.
     * The intersection of plane1 and plane2 determines this 3D line.
     *
     * @return 1st plane.
     */
    public Plane getPlane1() {
<span class="fc" id="L194">        return plane1;</span>
    }

    /**
     * Returns 2nd plane determining this 3D line.
     * The intersection of plane1 and plane2 determines this 3D line.
     *
     * @return 2nd plane.
     */
    public Plane getPlane2() {
<span class="fc" id="L204">        return plane2;</span>
    }

    /**
     * Determines if provided point is locus of this 3D line up to provided
     * threshold.
     *
     * @param point     Point to be checked.
     * @param threshold Threshold to determine if provided point is locus or
     *                  not. This should usually be a small value.
     * @return True if provided point belongs to this 3D line, false otherwise.
     * @throws IllegalArgumentException Raised if provided threshold is negative.
     */
    public boolean isLocus(final Point3D point, final double threshold) {
<span class="pc bpc" id="L218" title="1 of 4 branches missed.">        return plane1.isLocus(point, threshold) &amp;&amp; plane2.isLocus(point, threshold);</span>
    }

    /**
     * Raised if provided point is locus of this 3D line.
     *
     * @param point Point to be checked.
     * @return True if provided point belongs to this 3D line, false otherwise.
     */
    public boolean isLocus(final Point3D point) {
<span class="fc" id="L228">        return isLocus(point, DEFAULT_LOCUS_THRESHOLD);</span>
    }

    /**
     * Returns shortest distance of provided point to this 3D line.
     * The shortest distance is obtained in perpendicular direction of this
     * line.
     *
     * @param point Point to be checked.
     * @return Shortest distance of provided point to this 3D line.
     */
    public double getDistance(final Point3D point) {
<span class="fc" id="L240">        final var closestPoint = getClosestPoint(point);</span>
<span class="fc" id="L241">        return point.distanceTo(closestPoint);</span>
    }

    /**
     * Returns closest point belonging to this 3D line respect provided point.
     *
     * @param point Point to be checked.
     * @return Closest point belonging to this 3D line respect provided point.
     */
    public Point3D getClosestPoint(final Point3D point) {
<span class="fc" id="L251">        return getClosestPoint(point, DEFAULT_LOCUS_THRESHOLD);</span>
    }

    /**
     * Returns closest point belonging to this 3D line respect provided point
     * up to provided threshold.
     *
     * @param point     Point to be checked.
     * @param threshold Threshold to determine the closest point.
     * @return Closest point belonging to this 3D line respect provided point.
     * @throws IllegalArgumentException Raised if provided threshold is negative.
     */
    public Point3D getClosestPoint(final Point3D point, final double threshold) {
<span class="fc" id="L264">        final var result = Point3D.create();</span>
<span class="fc" id="L265">        closestPoint(point, result, threshold);</span>
<span class="fc" id="L266">        return result;</span>
    }

    /**
     * Computes closest point belonging to this 3D line respect provided point
     * and stores the result in provided instance.
     *
     * @param point  Point to be checked.
     * @param result Instance where computed point will be stored.
     */
    public void closestPoint(final Point3D point, final Point3D result) {
<span class="fc" id="L277">        closestPoint(point, result, DEFAULT_LOCUS_THRESHOLD);</span>
<span class="fc" id="L278">    }</span>

    /**
     * Computes closest point belonging to this 3D line respect provided point
     * up to provided threshold and stores the result in provided instance.
     *
     * @param point     Point to be checked.
     * @param result    Instance where computed point will be stored.
     * @param threshold Threshold to determine the closest point.
     * @throws IllegalArgumentException Raised if provided threshold is negative.
     */
    public void closestPoint(final Point3D point, final Point3D result, final double threshold) {
<span class="fc bfc" id="L290" title="All 2 branches covered.">        if (threshold &lt; MIN_THRESHOLD) {</span>
<span class="fc" id="L291">            throw new IllegalArgumentException();</span>
        }

        // normalize to increase accuracy
<span class="fc" id="L295">        point.normalize();</span>

        // compute director vector perpendicular to director vectors of plane1
        // and plane2, and use it along provided point to set a 3rd plane.
        // Using plane1, plane2 and the 3rd plane, we can get their intersection
        // to obtain a point which will be locus of this line3 and will be
        // located at shortest distance of provided point to this line3.

        // This is a plane having as director vector this line 3D and passing
        // through provided point
<span class="fc" id="L305">        final var p = new Plane(point, getDirection());</span>
        try {
<span class="fc" id="L307">            intersection(p, result);</span>
<span class="nc" id="L308">        } catch (final NoIntersectionException ignore) {</span>
            // never happens
<span class="fc" id="L310">        }</span>
<span class="fc" id="L311">    }</span>

    /**
     * Normalize the planes forming this 3D line.
     */
    public void normalize() {
<span class="fc" id="L317">        plane1.normalize();</span>
<span class="fc" id="L318">        plane2.normalize();</span>
<span class="fc" id="L319">    }</span>

    /**
     * Determines whether the planes forming this 3D line are normalized or not.
     *
     * @return True if planes forming this 3D line are normalized, false
     * otherwise.
     */
    public boolean isNormalized() {
<span class="pc bpc" id="L328" title="1 of 4 branches missed.">        return plane1.isNormalized() &amp;&amp; plane2.isNormalized();</span>
    }

    /**
     * Returns array containing vector that indicates the direction of this 3D
     * line.
     *
     * @return Returns vector indicating the direction of this 3D line.
     */
    public double[] getDirection() {
        try {
<span class="fc" id="L339">            return Utils.crossProduct(plane1.getDirectorVector(), plane2.getDirectorVector());</span>
<span class="nc" id="L340">        } catch (final AlgebraException ignore) {</span>
<span class="nc" id="L341">            return null;</span>
        }
    }

    /**
     * Returns point where provided point intersects this 3D line.
     *
     * @param plane Plane to intersect this 3D line.
     * @return Point where provided point intersects this 3D line.
     * @throws NoIntersectionException Raised if provided plane does not
     *                                 intersect this 3D line.
     */
    public Point3D getIntersection(final Plane plane) throws NoIntersectionException {
<span class="fc" id="L354">        final var result = Point3D.create();</span>
<span class="fc" id="L355">        intersection(plane, result);</span>
<span class="fc" id="L356">        return result;</span>
    }

    /**
     * Computes point where provided point intersects this 3D line and stores
     * the result in provided instance.
     *
     * @param plane  Plane to intersect this 3D line.
     * @param result Instance where computes point will be stored.
     * @throws NoIntersectionException Raised if provided plane does not
     *                                 intersect this 3D line.
     */
    public void intersection(final Plane plane, final Point3D result) throws NoIntersectionException {
        // use plane1, plane2 and provided plane to find an intersection
<span class="fc" id="L370">        plane.intersection(plane1, plane2, result);</span>
<span class="fc" id="L371">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>