<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Triangle2D.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-geometry</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.geometry</a> &gt; <span class="el_source">Triangle2D.java</span></div><h1>Triangle2D.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2012 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.geometry;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;

/**
 * This class defines a triangle in the 2D space.
 */
@SuppressWarnings(&quot;DuplicatedCode&quot;)
public class Triangle2D implements Serializable {

    /**
     * Default threshold value. Thresholds are used to determine whether a point
     * lies inside the triangle or not, or if it's locus or not, etc.
     */
    public static final double DEFAULT_THRESHOLD = 1e-9;

    /**
     * Minimum allowed threshold value.
     */
    public static final double MIN_THRESHOLD = 0.0;

    /**
     * Constant defining number of vertices on a triangle.
     */
    public static final int NUM_VERTICES = 3;

    /**
     * 1st vertex of this triangle.
     */
    private Point2D vertex1;

    /**
     * 2nd vertex of this triangle.
     */
    private Point2D vertex2;

    /**
     * 3rd vertex of this triangle.
     */
    private Point2D vertex3;

    /**
     * Constructor.
     *
     * @param vertex1 1st vertex.
     * @param vertex2 2nd vertex.
     * @param vertex3 3rd vertex.
     * @throws NullPointerException Raised if any of the vertices is null.
     */
<span class="fc" id="L67">    public Triangle2D(final Point2D vertex1, final Point2D vertex2, final Point2D vertex3) {</span>
<span class="fc" id="L68">        setVertices(vertex1, vertex2, vertex3);</span>
<span class="fc" id="L69">    }</span>

    /**
     * Returns 1st vertex of this triangle.
     *
     * @return 1st vertex.
     */
    public Point2D getVertex1() {
<span class="fc" id="L77">        return vertex1;</span>
    }

    /**
     * Sets 1st vertex of this triangle.
     *
     * @param vertex1 1st vertex.
     * @throws NullPointerException Raised if provided vertex is null.
     */
    public void setVertex1(final Point2D vertex1) {
<span class="fc bfc" id="L87" title="All 2 branches covered.">        if (vertex1 == null) {</span>
<span class="fc" id="L88">            throw new NullPointerException();</span>
        }
<span class="fc" id="L90">        this.vertex1 = vertex1;</span>
<span class="fc" id="L91">    }</span>

    /**
     * Returns 2nd vertex of this triangle.
     *
     * @return 2nd vertex.
     */
    public Point2D getVertex2() {
<span class="fc" id="L99">        return vertex2;</span>
    }

    /**
     * Sets 2nd vertex of this triangle.
     *
     * @param vertex2 2nd vertex.
     * @throws NullPointerException Raised if provided vertex is null.
     */
    public void setVertex2(final Point2D vertex2) {
<span class="fc bfc" id="L109" title="All 2 branches covered.">        if (vertex2 == null) {</span>
<span class="fc" id="L110">            throw new NullPointerException();</span>
        }
<span class="fc" id="L112">        this.vertex2 = vertex2;</span>
<span class="fc" id="L113">    }</span>

    /**
     * Returns 3rd vertex of this triangle.
     *
     * @return 3rd vertex.
     */
    public Point2D getVertex3() {
<span class="fc" id="L121">        return vertex3;</span>
    }

    /**
     * Sets 3rd vertex of this triangle.
     *
     * @param vertex3 3rd vertex.
     * @throws NullPointerException Raised if provided vertex is null.
     */
    public void setVertex3(final Point2D vertex3) {
<span class="fc bfc" id="L131" title="All 2 branches covered.">        if (vertex3 == null) {</span>
<span class="fc" id="L132">            throw new NullPointerException();</span>
        }
<span class="fc" id="L134">        this.vertex3 = vertex3;</span>
<span class="fc" id="L135">    }</span>

    /**
     * Returns vertices of this triangle as a list of points.
     *
     * @return Vertices of this triangle.
     */
    public List&lt;Point2D&gt; getVertices() {
<span class="fc" id="L143">        final var vertices = new ArrayList&lt;Point2D&gt;(NUM_VERTICES);</span>
<span class="fc" id="L144">        vertices(vertices);</span>
<span class="fc" id="L145">        return vertices;</span>
    }

    /**
     * Stores vertices of this triangle in provided list. Note that content of
     * list will be cleared before storing this triangle's vertices.
     *
     * @param result list where vertices will be stored.
     */
    public void vertices(final List&lt;Point2D&gt; result) {
<span class="fc" id="L155">        result.clear();</span>
<span class="fc" id="L156">        result.add(vertex1);</span>
<span class="fc" id="L157">        result.add(vertex2);</span>
<span class="fc" id="L158">        result.add(vertex3);</span>
<span class="fc" id="L159">    }</span>

    /**
     * Sets all vertices of this triangle.
     *
     * @param vertex1 1st vertex.
     * @param vertex2 2nd vertex.
     * @param vertex3 3rd vertex.
     * @throws NullPointerException Raised if any of the vertices is null.
     */
    public final void setVertices(final Point2D vertex1, final Point2D vertex2, final Point2D vertex3) {
<span class="fc bfc" id="L170" title="All 6 branches covered.">        if (vertex1 == null || vertex2 == null || vertex3 == null) {</span>
<span class="fc" id="L171">            throw new NullPointerException();</span>
        }

<span class="fc" id="L174">        this.vertex1 = vertex1;</span>
<span class="fc" id="L175">        this.vertex2 = vertex2;</span>
<span class="fc" id="L176">        this.vertex3 = vertex3;</span>
<span class="fc" id="L177">    }</span>

    /**
     * Returns area of provided triangle with sign. If vertices are defined
     * clockwise area is positive, otherwise returned area is negative.
     *
     * @param triangle Triangle to be evaluated.
     * @return Area of triangle with sign. Positive sign indicates that vertices
     * are clockwise, negative sign indicates that vertices are counterclockwise.
     */
    public static double signedArea(final Triangle2D triangle) {
<span class="fc" id="L188">        return signedArea(triangle.getVertex1(), triangle.getVertex2(), triangle.getVertex3());</span>
    }

    /**
     * Returns area with sign of the triangle formed by provided vertices. If
     * vertices are defined clockwise area is negative, otherwise returned area
     * is positive.
     *
     * @param vertex1 1st vertex of a triangle.
     * @param vertex2 2nd vertex of a triangle.
     * @param vertex3 3rd vertex of a triangle.
     * @return Area of a triangle with sign. Negative sign indicates that
     * vertices are clockwise, positive sign indicates that vertices are
     * counterclockwise.
     */
    public static double signedArea(final Point2D vertex1, final Point2D vertex2, final Point2D vertex3) {
        // The signed area of a triangle is half the determinant of its vectors,
        // or half the modulus of the cross product of its vectors

        // Hence, having the vectors of the triangle defined as:
        // v1 = vertex2 - vertex1, and v2 = vertex3 - vertex1, then:
<span class="fc" id="L209">        final var p1x = vertex1.getInhomX();</span>
<span class="fc" id="L210">        final var p1y = vertex1.getInhomY();</span>

<span class="fc" id="L212">        final var x1 = vertex2.getInhomX() - p1x;</span>
<span class="fc" id="L213">        final var y1 = vertex2.getInhomY() - p1y;</span>

<span class="fc" id="L215">        final var x2 = vertex3.getInhomX() - p1x;</span>
<span class="fc" id="L216">        final var y2 = vertex3.getInhomY() - p1y;</span>

        // Considering the matrix:
        // [x1   x2]
        // [y1   y2]
        // Then half its determinant or half the cross product of its column
        // vectors is:
<span class="fc" id="L223">        return 0.5 * (x1 * y2 - x2 * y1);</span>
    }

    /**
     * Returns area of this triangle with sign. If vertices are defined
     * clockwise area is positive, otherwise returned area is negative.
     *
     * @return Area of this triangle with sign. Positive sign indicates that
     * vertices are clockwise, negative sign indicates that vertices are
     * counterclockwise.
     */
    public double getSignedArea() {
<span class="fc" id="L235">        return signedArea(vertex1, vertex2, vertex3);</span>
    }

    /**
     * Returns area of provided triangle.
     *
     * @param triangle Triangle to be checked.
     * @return Area of triangle.
     */
    public static double area(final Triangle2D triangle) {
<span class="fc" id="L245">        return area(triangle.getVertex1(), triangle.getVertex2(), triangle.getVertex3());</span>
    }

    /**
     * Returns area of a triangle formed by provided vertices.
     *
     * @param vertex1 1st vertex of a triangle.
     * @param vertex2 2nd vertex of a triangle.
     * @param vertex3 3rd vertex of a triangle.
     * @return Area of a triangle.
     */
    public static double area(final Point2D vertex1, final Point2D vertex2, final Point2D vertex3) {
<span class="fc" id="L257">        return Math.abs(signedArea(vertex1, vertex2, vertex3));</span>
    }

    /**
     * Returns area of this triangle.
     *
     * @return Area of this triangle.
     */
    public double getArea() {
<span class="fc" id="L266">        return area(vertex1, vertex2, vertex3);</span>
    }

    /**
     * Determines whether vertices of this triangle are considered to be
     * co-linear. Points are considered to be colinear when area of triangle is
     * very small.
     *
     * @return True if vertices are colinear, false otherwise.
     */
    public boolean areVerticesColinear() {
<span class="fc" id="L277">        return areVerticesColinear(DEFAULT_THRESHOLD);</span>
    }

    /**
     * Determines whether vertices of this triangle are considered to be
     * co-linear up to certain threshold. Points are considered to be colinear
     * when are of triangle is very small.
     *
     * @param threshold Threshold to determine whether vertices are colinear.
     *                  Vertices will be colinear when area of triangle is smaller than provided
     *                  threshold.
     * @return True if vertices are colinear, false otherwise.
     * @throws IllegalArgumentException Raised if provided threshold is negative.
     */
    public boolean areVerticesColinear(final double threshold) {
<span class="fc bfc" id="L292" title="All 2 branches covered.">        if (threshold &lt; MIN_THRESHOLD) {</span>
<span class="fc" id="L293">            throw new IllegalArgumentException();</span>
        }
<span class="fc bfc" id="L295" title="All 2 branches covered.">        return getArea() &lt;= threshold;</span>
    }

    /**
     * Returns perimeter of provided triangle.
     *
     * @param triangle Perimeter of provided triangle.
     * @return Perimeter of provided triangle.
     */
    public static double perimeter(final Triangle2D triangle) {
<span class="fc" id="L305">        return perimeter(triangle.getVertex1(), triangle.getVertex2(), triangle.getVertex3());</span>
    }

    /**
     * Returns perimeter of triangle formed by provided vertices.
     *
     * @param vertex1 1st vertex of a triangle.
     * @param vertex2 2nd vertex of a triangle.
     * @param vertex3 3rd vertex of a triangle.
     * @return Perimeter of a triangle.
     */
    public static double perimeter(final Point2D vertex1, final Point2D vertex2, final Point2D vertex3) {
<span class="fc" id="L317">        return vertex1.distanceTo(vertex2) + vertex2.distanceTo(vertex3) + vertex3.distanceTo(vertex1);</span>
    }

    /**
     * Returns perimeter of this triangle.
     *
     * @return Perimeter of this triangle.
     */
    public double getPerimeter() {
<span class="fc" id="L326">        return perimeter(this);</span>
    }

    /**
     * Indicates whether provided point lies inside this triangle or not.
     *
     * @param point Point to be checked.
     * @return True if point lies inside this triangle, false otherwise.
     */
    public boolean isInside(final Point2D point) {
<span class="fc" id="L336">        return isInside(point, DEFAULT_THRESHOLD);</span>
    }

    /**
     * Indicates whether provided point lies inside this triangle or not up to
     * a certain threshold.
     *
     * @param point     Point to be checked.
     * @param threshold Threshold to determine whether point is inside this
     *                  triangle, or not. This should usually be a small value.
     * @return True if point lies inside this triangle, false otherwise.
     * @throws IllegalArgumentException Raised if provided threshold is negative.
     */
    public boolean isInside(final Point2D point, final double threshold) {
<span class="fc" id="L350">        return isInside(vertex1, vertex2, vertex3, point, threshold);</span>
    }

    /**
     * Indicates whether provided point lies inside provided triangle or not.
     *
     * @param triangle A triangle.
     * @param point    Point to be checked.
     * @return True if point lies inside provided triangle, false otherwise.
     */
    public static boolean isInside(final Triangle2D triangle, final Point2D point) {
<span class="fc" id="L361">        return isInside(triangle, point, DEFAULT_THRESHOLD);</span>
    }

    /**
     * Indicates whether provided point lies inside provided triangle or not up
     * to a certain threshold.
     *
     * @param triangle  A triangle.
     * @param point     Point to be checked.
     * @param threshold Threshold to determine whether point is inside this
     *                  triangle, or not. This should usually be a small value.
     * @return True if point lies inside this triangle, false otherwise.
     * @throws IllegalArgumentException Raised if provided threshold is negative.
     */
    public static boolean isInside(final Triangle2D triangle, final Point2D point, final double threshold) {
<span class="fc" id="L376">        return isInside(triangle.getVertex1(), triangle.getVertex2(), triangle.getVertex3(), point, threshold);</span>
    }

    /**
     * Indicates whether provided point lies inside a triangle formed by
     * provided vertices or not.
     *
     * @param vertex1 1st vertex of a triangle.
     * @param vertex2 2nd vertex of a triangle.
     * @param vertex3 3rd vertex of a triangle.
     * @param point   Point to be checked.
     * @return True if point lies inside triangle formed by provided vertices,
     * false otherwise.
     */
    public static boolean isInside(
            final Point2D vertex1, final Point2D vertex2, final Point2D vertex3, final Point2D point) {
<span class="fc" id="L392">        return isInside(vertex1, vertex2, vertex3, point, DEFAULT_THRESHOLD);</span>
    }

    /**
     * Indicates whether provided point lies inside a triangle formed by
     * provided vertices or not up to a certain threshold.
     *
     * @param vertex1   1st vertex of a triangle.
     * @param vertex2   2nd vertex of a triangle.
     * @param vertex3   3rd vertex of a triangle.
     * @param point     Point to be checked.
     * @param threshold Threshold to determine whether point is inside the
     *                  triangle formed by provided vertices or not. This should usually be a
     *                  small value.
     * @return True if point lies inside triangle formed by provided vertices,
     * false otherwise.
     * @throws IllegalArgumentException Raised if provided threshold is negative.
     */
    public static boolean isInside(
            final Point2D vertex1, final Point2D vertex2, final Point2D vertex3, final Point2D point,
            final double threshold) {
<span class="fc bfc" id="L413" title="All 2 branches covered.">        if (threshold &lt; MIN_THRESHOLD) {</span>
<span class="fc" id="L414">            throw new IllegalArgumentException();</span>
        }
        // given triangle ABC made by vectors:
        // ab = p2 - p1, and ac = p3 - p1

        // If point (x, y) lies within triangle ABC, then we have 3 sub-triangles
        // ApB, BpC and ApC made of points:
        // ApB: mVertex1, point, mVertex2
        // BpC: mVertex2, point, mVertex3
        // ApC: mVertex3, point, mVertex1

        // The point will lie inside triangle ABC if the sum of the areas of the
        // 3 sub-triangles ApB, BpC and ApC equals the area of triangle ABC (up to
        // certain accuracy to account for numerical precision)

        // Then the areas of triangles are:
<span class="fc" id="L430">        final var areaABC = area(vertex1, vertex2, vertex3);</span>

<span class="fc" id="L432">        final var areaApB = area(vertex1, point, vertex2);</span>
<span class="fc" id="L433">        final var areaBpC = area(vertex2, point, vertex3);</span>
<span class="fc" id="L434">        final var areaApC = area(vertex3, point, vertex1);</span>

<span class="fc bfc" id="L436" title="All 2 branches covered.">        return Math.abs(areaApB + areaBpC + areaApC - areaABC) &lt;= threshold;</span>
    }

    /**
     * Returns center of this triangle, which is the result of averaging its
     * vertices.
     *
     * @return Center of this triangle.
     */
    public Point2D getCenter() {
<span class="fc" id="L446">        final var result = Point2D.create();</span>
<span class="fc" id="L447">        center(result);</span>
<span class="fc" id="L448">        return result;</span>
    }

    /**
     * Computes the center of this triangle and stores the result in provided
     * point. The center of this triangle is computed as the average of its
     * vertices.
     *
     * @param result Point instance where center will be stored.
     */
    public void center(final Point2D result) {
<span class="fc" id="L459">        center(vertex1, vertex2, vertex3, result);</span>
<span class="fc" id="L460">    }</span>

    /**
     * Computes the center of a triangle formed by provided vertices.
     * The center is computed as the average of the three vertices.
     *
     * @param vertex1 1st vertex of a triangle.
     * @param vertex2 2nd vertex of a triangle.
     * @param vertex3 3rd vertex of a triangle.
     * @return Center of a triangle formed by provided vertices.
     */
    public static Point2D center(final Point2D vertex1, final Point2D vertex2, final Point2D vertex3) {
<span class="fc" id="L472">        final var result = Point2D.create();</span>
<span class="fc" id="L473">        center(vertex1, vertex2, vertex3, result);</span>
<span class="fc" id="L474">        return result;</span>
    }

    /**
     * Computes the center of provided triangle.
     * The center is computed as the average of the vertices of provided
     * triangle.
     *
     * @param t A triangle.
     * @return Center of provided triangle.
     */
    public static Point2D center(final Triangle2D t) {
<span class="fc" id="L486">        return center(t.getVertex1(), t.getVertex2(), t.getVertex3());</span>
    }

    /**
     * Computes the center of a triangle formed by provided vertices and stores
     * the result in provided result point.
     * The center is computed as the average of provided vertices.
     *
     * @param vertex1 1st vertex of a triangle.
     * @param vertex2 2nd vertex of a triangle.
     * @param vertex3 3rd vertex of a triangle.
     * @param result  Point instance where center will be stored.
     */
    public static void center(
            final Point2D vertex1, final Point2D vertex2, final Point2D vertex3, final Point2D result) {

<span class="fc" id="L502">        final var x = (vertex1.getInhomX() + vertex2.getInhomX() + vertex3.getInhomX()) / 3.0;</span>
<span class="fc" id="L503">        final var y = (vertex1.getInhomY() + vertex2.getInhomY() + vertex3.getInhomY()) / 3.0;</span>

<span class="fc" id="L505">        result.setInhomogeneousCoordinates(x, y);</span>
<span class="fc" id="L506">    }</span>

    /**
     * Computes the center of provided triangle and stores the result in
     * provided result point.
     * The center is computed as the average of the vertices of provided
     * triangle.
     *
     * @param t      A triangle.
     * @param result Point instance where center will be stored.
     */
    public static void center(final Triangle2D t, final Point2D result) {
<span class="fc" id="L518">        center(t.getVertex1(), t.getVertex2(), t.getVertex3(), result);</span>
<span class="fc" id="L519">    }</span>

    /**
     * Computes the shortest distance from a given point to the boundaries of
     * this triangle, considering its boundaries as lines with a finite length
     * Distance is computed up to triangle boundary, no matter if point lies
     * inside the triangle or not.
     *
     * @param point Point to be checked.
     * @return Shortest distance to this triangle.
     */
    public double getShortestDistance(final Point2D point) {
<span class="fc" id="L531">        return shortestDistance(this, point);</span>
    }

    /**
     * Computes the shortest distance from a given point to the boundaries of
     * provided triangle, considering its boundaries as lines with a finite
     * length.
     * Distance is computed up to triangle boundary, no matter if point lies
     * inside the triangle or not.
     *
     * @param triangle A triangle.
     * @param point    Point to be checked.
     * @return Shortest distance to this triangle.
     */
    public static double shortestDistance(final Triangle2D triangle, final Point2D point) {
<span class="fc" id="L546">        return shortestDistance(triangle.getVertex1(), triangle.getVertex2(), triangle.getVertex3(), point);</span>
    }

    // shortest distance to the sides of the triangle, no matter if the point
    // lies inside the triangle or not

    /**
     * Computes the shortest distance from a given point to the boundaries of
     * a triangle formed by provided vertices, where those boundaries are
     * considered to be lines with a finite length.
     * Distance is computed up to triangle boundary, no matter if point lies
     * inside the triangle or not.
     *
     * @param vertex1 1st vertex of a triangle.
     * @param vertex2 2nd vertex of a triangle.
     * @param vertex3 3rd vertex of a triangle.
     * @param point   Point to be checked.
     * @return Shortest distance to the triangle formed by provided vertices.
     */
    public static double shortestDistance(
            final Point2D vertex1, final Point2D vertex2, final Point2D vertex3, final Point2D point) {

        // normalize points to increase accuracy
<span class="fc" id="L569">        vertex1.normalize();</span>
<span class="fc" id="L570">        vertex2.normalize();</span>
<span class="fc" id="L571">        vertex3.normalize();</span>
<span class="fc" id="L572">        point.normalize();</span>

        double bestDist;
        double dist;

<span class="fc" id="L577">        final var line = new Line2D();</span>
<span class="fc" id="L578">        line.setParametersFromPairOfPoints(vertex1, vertex2);</span>
        // to increase accuracy
<span class="fc" id="L580">        line.normalize();</span>
<span class="fc bfc" id="L581" title="All 2 branches covered.">        if (line.isLocus(point)) {</span>
<span class="fc bfc" id="L582" title="All 2 branches covered.">            if (point.isBetween(vertex1, vertex2)) {</span>
<span class="fc" id="L583">                return 0.0;</span>
            } else {
                // point is outside the triangle and
                // point belongs to the line forming this side of the triangle,
                // hence the closest vertex of this line will be the shortest
                // distance
<span class="fc" id="L589">                bestDist = vertex1.distanceTo(point);</span>
<span class="fc" id="L590">                dist = vertex2.distanceTo(point);</span>
<span class="pc bpc" id="L591" title="1 of 2 branches missed.">                if (dist &lt; bestDist) {</span>
<span class="nc" id="L592">                    bestDist = dist;</span>
                }

<span class="fc" id="L595">                return bestDist;</span>
            }
        }

        // point does not belong to the first line
<span class="fc" id="L600">        bestDist = Math.abs(line.signedDistance(point));</span>

        // try on second side of the triangle
<span class="fc" id="L603">        line.setParametersFromPairOfPoints(vertex1, vertex3);</span>
        // to increase accuracy
<span class="fc" id="L605">        line.normalize();</span>
<span class="fc bfc" id="L606" title="All 2 branches covered.">        if (line.isLocus(point)) {</span>
<span class="pc bpc" id="L607" title="1 of 2 branches missed.">            if (point.isBetween(vertex1, vertex3)) {</span>
<span class="fc" id="L608">                return 0.0;</span>
            } else {
                // point belongs to the line forming this side of the triangle,
                // hence the closest vertex of this line will be the shortest
                // distance
<span class="nc" id="L613">                bestDist = vertex1.distanceTo(point);</span>
<span class="nc" id="L614">                dist = vertex3.distanceTo(point);</span>
<span class="nc bnc" id="L615" title="All 2 branches missed.">                if (dist &lt; bestDist) {</span>
<span class="nc" id="L616">                    bestDist = dist;</span>
                }

<span class="nc" id="L619">                return bestDist;</span>
            }
        }

        // point does not belong to the first or second line
<span class="fc" id="L624">        dist = Math.abs(line.signedDistance(point));</span>

        // check if second line is closest to first line
<span class="fc bfc" id="L627" title="All 2 branches covered.">        if (dist &lt; bestDist) {</span>
<span class="fc" id="L628">            bestDist = dist;</span>
        }

        // try on third side of the triangle
<span class="fc" id="L632">        line.setParametersFromPairOfPoints(vertex2, vertex3);</span>
        // to increase accuracy
<span class="fc" id="L634">        line.normalize();</span>
<span class="fc bfc" id="L635" title="All 2 branches covered.">        if (line.isLocus(point)) {</span>
<span class="pc bpc" id="L636" title="1 of 2 branches missed.">            if (point.isBetween(vertex2, vertex3)) {</span>
<span class="fc" id="L637">                return 0.0;</span>
            } else {
                // point belongs to the line forming this side of the triangle,
                // hence the closest vertex of this line will be the shortest
                // distance
<span class="nc" id="L642">                bestDist = vertex2.distanceTo(point);</span>
<span class="nc" id="L643">                dist = vertex3.distanceTo(point);</span>
<span class="nc bnc" id="L644" title="All 2 branches missed.">                if (dist &lt; bestDist) {</span>
<span class="nc" id="L645">                    bestDist = dist;</span>
                }

<span class="nc" id="L648">                return bestDist;</span>
            }
        }

        // point does not belong to any line forming a side of the triangle
<span class="fc" id="L653">        dist = Math.abs(line.signedDistance(point));</span>

        // check if distance to third line is the shortest
<span class="fc bfc" id="L656" title="All 2 branches covered.">        if (dist &lt; bestDist) {</span>
<span class="fc" id="L657">            bestDist = dist;</span>
        }

<span class="fc" id="L660">        return bestDist;</span>
    }

    /**
     * Returns the point which is locus of this triangle closest to provided
     * point.
     *
     * @param point Point to be checked.
     * @return Closest point laying in this triangle boundaries.
     */
    public Point2D getClosestPoint(final Point2D point) {
<span class="fc" id="L671">        return getClosestPoint(point, DEFAULT_THRESHOLD);</span>
    }

    /**
     * Returns the point which is locus of this triangle (up to a certain
     * threshold) closest to provided point.
     *
     * @param point     Point to be checked.
     * @param threshold Threshold to determine when a point is locus of this
     *                  triangle or not.
     * @return Closest point laying in this triangle boundaries.
     * @throws IllegalArgumentException Raised if provided threshold is negative.
     */
    public Point2D getClosestPoint(final Point2D point, final double threshold) {
<span class="fc" id="L685">        final var result = Point2D.create();</span>
<span class="fc" id="L686">        closestPoint(point, result, threshold);</span>
<span class="fc" id="L687">        return result;</span>
    }

    /**
     * Computes the point which is locus of this triangle closest to provided
     * point and stores the result in provided result point.
     *
     * @param point  Point to be checked.
     * @param result Point where result will be stored.
     */
    public void closestPoint(final Point2D point, final Point2D result) {
<span class="fc" id="L698">        closestPoint(point, result, DEFAULT_THRESHOLD);</span>
<span class="fc" id="L699">    }</span>

    /**
     * Computes the point which is locus of this triangle (up to a certain
     * threshold) closest to provided point and stores the result in provided
     * result point.
     *
     * @param point     Point to be checked.
     * @param result    Point where result will be stored.
     * @param threshold Threshold to determine when a point is locus of this
     *                  triangle or not.
     * @throws IllegalArgumentException Raised if provided threshold is negative.
     */
    public void closestPoint(final Point2D point, final Point2D result, final double threshold) {
<span class="pc bpc" id="L713" title="1 of 2 branches missed.">        if (threshold &lt; MIN_THRESHOLD) {</span>
<span class="nc" id="L714">            throw new IllegalArgumentException();</span>
        }

        // normalize vertices and point to increase accuracy
<span class="fc" id="L718">        vertex1.normalize();</span>
<span class="fc" id="L719">        vertex2.normalize();</span>
<span class="fc" id="L720">        vertex3.normalize();</span>
<span class="fc" id="L721">        point.normalize();</span>

<span class="fc" id="L723">        final var line1 = new Line2D(vertex1, vertex2);</span>
        // to increase accuracy
<span class="fc" id="L725">        line1.normalize();</span>
<span class="fc bfc" id="L726" title="All 2 branches covered.">        if (line1.isLocus(point)) {</span>
<span class="fc bfc" id="L727" title="All 2 branches covered.">            if (point.isBetween(vertex1, vertex2)) {</span>
                // point is on this side of the triangle, so point must be the
                // result
<span class="fc" id="L730">                result.setCoordinates(point);</span>
            } else {
                // point belongs to the line forming this side of the triangle,
                // hence the closest vertex of this line will be the closest
                // point to the triangle
<span class="fc" id="L735">                final var dist1 = vertex1.distanceTo(point);</span>
<span class="fc" id="L736">                final var dist2 = vertex2.distanceTo(point);</span>
<span class="fc bfc" id="L737" title="All 2 branches covered.">                if (dist1 &lt; dist2) {</span>
<span class="fc" id="L738">                    result.setCoordinates(vertex1);</span>
                } else {
<span class="fc" id="L740">                    result.setCoordinates(vertex2);</span>
                }
            }
<span class="fc" id="L743">            return;</span>
        }

        // try on second side of the triangle
<span class="fc" id="L747">        final var line2 = new Line2D(vertex1, vertex3);</span>
        // to increase accuracy
<span class="fc" id="L749">        line2.normalize();</span>
<span class="fc bfc" id="L750" title="All 2 branches covered.">        if (line2.isLocus(point)) {</span>
<span class="pc bpc" id="L751" title="1 of 2 branches missed.">            if (point.isBetween(vertex1, vertex3)) {</span>
                // point is on this side of the triangle, so point must be the
                // result
<span class="fc" id="L754">                result.setCoordinates(point);</span>
            } else {
                // point belongs to the line forming this side of the triangle,
                // hence the closest vertex of this line will be the closest
                // point to the triangle
<span class="nc" id="L759">                final var dist1 = vertex1.distanceTo(point);</span>
<span class="nc" id="L760">                final var dist3 = vertex3.distanceTo(point);</span>
<span class="nc bnc" id="L761" title="All 2 branches missed.">                if (dist1 &lt; dist3) {</span>
<span class="nc" id="L762">                    result.setCoordinates(vertex1);</span>
                } else {
<span class="nc" id="L764">                    result.setCoordinates(vertex3);</span>
                }
            }
<span class="fc" id="L767">            return;</span>
        }

        // try on third side of the triangle
<span class="fc" id="L771">        final var line3 = new Line2D(vertex2, vertex3);</span>
        // to increase accuracy
<span class="fc" id="L773">        line3.normalize();</span>
<span class="pc bpc" id="L774" title="1 of 2 branches missed.">        if (line3.isLocus(point)) {</span>
<span class="nc bnc" id="L775" title="All 2 branches missed.">            if (point.isBetween(vertex2, vertex3)) {</span>
                // point is on this side of the triangle, so point must be the
                // result
<span class="nc" id="L778">                result.setCoordinates(point);</span>
            } else {
                // point belongs to the line forming this side of the triangle,
                // hence the closest vertex of this line will be the closest
                // point to the triangle
<span class="nc" id="L783">                final var dist2 = vertex2.distanceTo(point);</span>
<span class="nc" id="L784">                final var dist3 = vertex3.distanceTo(point);</span>
<span class="nc bnc" id="L785" title="All 2 branches missed.">                if (dist2 &lt; dist3) {</span>
<span class="nc" id="L786">                    result.setCoordinates(vertex2);</span>
                } else {
<span class="nc" id="L788">                    result.setCoordinates(vertex3);</span>
                }
            }
<span class="nc" id="L791">            return;</span>
        }

        // point does not belong to any line forming a side of the triangle,
        // so we find the closest point for each side
<span class="fc" id="L796">        final var closest1 = line1.getClosestPoint(point, threshold);</span>
        // to increase accuracy
<span class="fc" id="L798">        closest1.normalize();</span>
<span class="fc" id="L799">        final var closest2 = line2.getClosestPoint(point, threshold);</span>
        // to increase accuracy
<span class="fc" id="L801">        closest2.normalize();</span>
<span class="fc" id="L802">        final var closest3 = line3.getClosestPoint(point, threshold);</span>
        // to increase accuracy
<span class="fc" id="L804">        closest3.normalize();</span>

        // check if points lie within sides of triangle
<span class="fc" id="L807">        final var between1 = closest1.isBetween(vertex1, vertex2);</span>
<span class="fc" id="L808">        final var between2 = closest2.isBetween(vertex1, vertex3);</span>
<span class="fc" id="L809">        final var between3 = closest3.isBetween(vertex2, vertex3);</span>

<span class="fc" id="L811">        final var distClosest1 = closest1.distanceTo(point);</span>
<span class="fc" id="L812">        final var distClosest2 = closest2.distanceTo(point);</span>
<span class="fc" id="L813">        final var distClosest3 = closest3.distanceTo(point);</span>

<span class="fc" id="L815">        final var distVertex1 = vertex1.distanceTo(point);</span>
<span class="fc" id="L816">        final var distVertex2 = vertex2.distanceTo(point);</span>
<span class="fc" id="L817">        final var distVertex3 = vertex3.distanceTo(point);</span>

<span class="pc bpc" id="L819" title="2 of 6 branches missed.">        if (between1 &amp;&amp; !between2 &amp;&amp; !between3) {</span>
            // choose closest1 or opposite vertex (vertex3)
<span class="fc bfc" id="L821" title="All 2 branches covered.">            if (distClosest1 &lt; distVertex3) {</span>
<span class="fc" id="L822">                result.setCoordinates(closest1);</span>
            } else {
<span class="fc" id="L824">                result.setCoordinates(vertex3);</span>
            }
<span class="pc bpc" id="L826" title="5 of 6 branches missed.">        } else if (!between1 &amp;&amp; between2 &amp;&amp; !between3) {</span>
            // choose closest2 or opposite vertex (vertex2)
<span class="nc bnc" id="L828" title="All 2 branches missed.">            if (distClosest2 &lt; distVertex2) {</span>
<span class="nc" id="L829">                result.setCoordinates(closest2);</span>
            } else {
<span class="nc" id="L831">                result.setCoordinates(vertex2);</span>
            }
<span class="pc bpc" id="L833" title="5 of 6 branches missed.">        } else if (!between1 &amp;&amp; !between2 &amp;&amp; between3) {</span>
            // choose closest3 or opposite vertex (vertex1)
<span class="nc bnc" id="L835" title="All 2 branches missed.">            if (distClosest3 &lt; distVertex1) {</span>
<span class="nc" id="L836">                result.setCoordinates(closest3);</span>
            } else {
<span class="nc" id="L838">                result.setCoordinates(vertex1);</span>
            }
<span class="pc bpc" id="L840" title="3 of 6 branches missed.">        } else if (between1 &amp;&amp; between2 &amp;&amp; !between3) {</span>
            // determine if closest1 or closest2
<span class="nc bnc" id="L842" title="All 2 branches missed.">            if (distClosest1 &lt; distClosest2) {</span>
<span class="nc" id="L843">                result.setCoordinates(closest1);</span>
            } else {
<span class="nc" id="L845">                result.setCoordinates(closest2);</span>
            }
<span class="pc bpc" id="L847" title="3 of 4 branches missed.">        } else if (!between1 &amp;&amp; between2) {</span>
            // and between3

            // determine if closest2 or closest3
<span class="nc bnc" id="L851" title="All 2 branches missed.">            if (distClosest2 &lt; distClosest3) {</span>
<span class="nc" id="L852">                result.setCoordinates(closest2);</span>
            } else {
<span class="nc" id="L854">                result.setCoordinates(closest3);</span>
            }
<span class="pc bpc" id="L856" title="2 of 4 branches missed.">        } else if (between1 &amp;&amp; !between2) {</span>
            // and between3

            //determine if closest1 or closest3
<span class="nc bnc" id="L860" title="All 2 branches missed.">            if (distClosest1 &lt; distClosest3) {</span>
<span class="nc" id="L861">                result.setCoordinates(closest1);</span>
            } else {
<span class="nc" id="L863">                result.setCoordinates(closest3);</span>
            }
<span class="pc bpc" id="L865" title="1 of 2 branches missed.">        } else if (between1) {</span>
            // and between2 and between3

            //determine if closest1, closest2 or closest3
<span class="pc bpc" id="L869" title="3 of 4 branches missed.">            if (distClosest1 &lt; distClosest2 &amp;&amp; distClosest1 &lt; distClosest3) {</span>
                // pick closest1
<span class="nc" id="L871">                result.setCoordinates(closest1);</span>
<span class="pc bpc" id="L872" title="2 of 4 branches missed.">            } else if (distClosest2 &lt; distClosest1 &amp;&amp;</span>
                    distClosest2 &lt; distClosest3) {
                // pick closest2
<span class="fc" id="L875">                result.setCoordinates(closest2);</span>
            } else {
                // pick closest3
<span class="nc" id="L878">                result.setCoordinates(closest3);</span>
            }
        } else {
            // all closest points are outside vertex limits, so we pick the
            // closest vertex

<span class="nc bnc" id="L884" title="All 4 branches missed.">            if (distVertex1 &lt; distVertex2 &amp;&amp; distVertex1 &lt; distVertex3) {</span>
                // pick vertex1
<span class="nc" id="L886">                result.setCoordinates(vertex1);</span>
<span class="nc bnc" id="L887" title="All 4 branches missed.">            } else if (distVertex2 &lt; distVertex1 &amp;&amp; distVertex2 &lt; distVertex3) {</span>
                // pick vertex2
<span class="nc" id="L889">                result.setCoordinates(vertex2);</span>
            } else {
                // pick vertex3
<span class="nc" id="L892">                result.setCoordinates(vertex3);</span>
            }
        }
<span class="fc" id="L895">    }</span>

    /**
     * Returns boolean indicating if provided point is locus of this triangle
     * (i.e. lies within this triangle boundaries) up to a certain threshold.
     *
     * @param point     Point to be checked.
     * @param threshold Threshold to determine if point is locus or not. This
     *                  should usually be a small value.
     * @return True if provided point is locus, false otherwise.
     * @throws IllegalArgumentException Raised if provided threshold is negative.
     */
    public boolean isLocus(final Point2D point, final double threshold) {
<span class="fc bfc" id="L908" title="All 2 branches covered.">        if (threshold &lt; MIN_THRESHOLD) {</span>
<span class="fc" id="L909">            throw new IllegalArgumentException();</span>
        }

<span class="fc bfc" id="L912" title="All 4 branches covered.">        return point.isBetween(vertex1, vertex2, threshold) || point.isBetween(vertex1, vertex3, threshold)</span>
<span class="pc bpc" id="L913" title="1 of 2 branches missed.">                || point.isBetween(vertex2, vertex3, threshold);</span>
    }

    /**
     * Returns boolean indicating if provided point is locus of this triangle
     * (i.e. lies within this triangle boundaries).
     *
     * @param point Point to be checked.
     * @return True if provided point is locus, false otherwise.
     */
    public boolean isLocus(final Point2D point) {
<span class="fc" id="L924">        return isLocus(point, DEFAULT_THRESHOLD);</span>
    }

    /**
     * Indicates whether the vertices of this triangle are provided in clockwise
     * order or not.
     * Vertices of a triangle are in clockwise order when the triangle's signed
     * area is negative.
     *
     * @param threshold Threshold to determine if vertices are clockwise or not.
     *                  This should usually be 0.0 and there is no restriction in sign
     * @return True if vertices of this triangle are in clockwise order, false
     * if they are in counterclockwise order.
     */
    public boolean areVerticesClockwise(final double threshold) {
<span class="fc bfc" id="L939" title="All 2 branches covered.">        return getSignedArea() &lt; threshold;</span>
    }

    /**
     * Indicates whether the vertices of this triangle are provided in clockwise
     * order or not.
     *
     * @return True if vertices of this triangle are in clockwise order, false
     * if they are in counterclockwise order.
     */
    public boolean areVerticesClockwise() {
<span class="fc" id="L950">        return areVerticesClockwise(0.0); // default threshold to check sign</span>
    }

    //TODO: compute surrounding circle and inner circle
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>