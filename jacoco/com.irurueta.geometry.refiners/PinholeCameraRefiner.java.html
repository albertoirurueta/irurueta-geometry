<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PinholeCameraRefiner.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-geometry</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.geometry.refiners</a> &gt; <span class="el_source">PinholeCameraRefiner.java</span></div><h1>PinholeCameraRefiner.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2017 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.geometry.refiners;

import com.irurueta.geometry.CameraException;
import com.irurueta.geometry.InhomogeneousPoint2D;
import com.irurueta.geometry.InhomogeneousPoint3D;
import com.irurueta.geometry.NotAvailableException;
import com.irurueta.geometry.PinholeCamera;
import com.irurueta.geometry.PinholeCameraIntrinsicParameters;
import com.irurueta.geometry.Quaternion;
import com.irurueta.geometry.estimators.LockedException;
import com.irurueta.geometry.estimators.NotReadyException;
import com.irurueta.numerical.robust.InliersData;

import java.util.BitSet;
import java.util.List;

/**
 * Base class for pinhole camera refiners.
 * Implementations of this class refine a pinhole camera by taking into account
 * an initial estimation, inlier point or line matches and their residuals.
 * This class can be used to find a solution that minimizes error of inliers in
 * LMSE terms.
 * Typically, a refiner is used by a robust estimator, however it can also be
 * useful in some other situations.
 *
 * @param &lt;S1&gt; type of matched samples in 1st set.
 * @param &lt;S2&gt; type of matched samples in 2nd set.
 */
@SuppressWarnings(&quot;DuplicatedCode&quot;)
public abstract class PinholeCameraRefiner&lt;S1, S2&gt; extends PairMatchesAndInliersDataRefiner&lt;PinholeCamera, S1, S2&gt; {

    /**
     * Default value indicating whether skewness value is suggested or not.
     * By default, this is disabled.
     */
    public static final boolean DEFAULT_SUGGEST_SKEWNESS_VALUE_ENABLED = false;

    /**
     * Default value of skewness to be suggested when suggestion is enabled.
     * By default suggested skewness is zero.
     */
    public static final double DEFAULT_SUGGESTED_SKEWNESS_VALUE = 0.0;

    /**
     * Default value indicating whether horizontal focal length value is
     * suggested or not. By default, this is disabled.
     */
    public static final boolean DEFAULT_SUGGEST_HORIZONTAL_FOCAL_LENGTH_ENABLED = false;

    /**
     * Default value indicating whether vertical focal length value is suggested
     * or not. By default, this is disabled.
     */
    public static final boolean DEFAULT_SUGGEST_VERTICAL_FOCAL_LENGTH_ENABLED = false;

    /**
     * Default value indicating whether aspect ratio is suggested or not. By
     * default, this is disabled.
     */
    public static final boolean DEFAULT_SUGGEST_ASPECT_RATIO_ENABLED = false;

    /**
     * Default value of aspect ratio to be suggested when suggestion is enabled.
     * By default, suggested aspect ratio is 1.0, although also -1.0 is a typical
     * value when vertical coordinates increase downwards.
     */
    public static final double DEFAULT_SUGGESTED_ASPECT_RATIO_VALUE = 1.0;

    /**
     * Default value indicating whether principal point is suggested or not. By
     * default, this is disabled.
     */
    public static final boolean DEFAULT_SUGGEST_PRINCIPAL_POINT_ENABLED = false;

    /**
     * Default value indicating whether rotation is suggested or not. By default,
     * this is disabled.
     */
    public static final boolean DEFAULT_SUGGEST_ROTATION_ENABLED = false;

    /**
     * Default value indicating whether center is suggested or not. By default,
     * this is disabled.
     */
    public static final boolean DEFAULT_SUGGEST_CENTER_ENABLED = false;

    /**
     * Standard deviation used for Levenberg-Marquardt fitting during
     * refinement.
     * Returned value gives an indication of how much variance each residual
     * has.
     * Typically, this value is related to the threshold used on each robust
     * estimation, since residuals of found inliers are within the range of
     * such threshold.
     */
    protected double refinementStandardDeviation;

    /**
     * Indicates whether skewness value is suggested or not. When enabled, the
     * estimator will attempt to enforce suggested value in an iterative manner
     * starting from an initially estimated camera.
     * Even when suggestion is enabled, the iterative algorithm might not reach
     * suggested value if the initial value largely differs from the suggested
     * value.
     */
<span class="fc" id="L121">    private boolean suggestSkewnessValueEnabled = DEFAULT_SUGGEST_SKEWNESS_VALUE_ENABLED;</span>

    /**
     * Suggested skewness value to be reached when suggestion is enabled.
     * Suggested value should be close to the initially estimated value
     * otherwise the iterative refinement might not converge to provided
     * value.
     */
<span class="fc" id="L129">    private double suggestedSkewnessValue = DEFAULT_SUGGESTED_SKEWNESS_VALUE;</span>

    /**
     * Indicates whether horizontal focal length is suggested or not. When
     * enabled, the estimator will attempt to enforce suggested value in an
     * iterative manner starting from an initially estimated camera.
     * Even when suggestion is enabled, the iterative algorithm might not reach
     * suggested value if the initial value largely differs from the suggested
     * value.
     */
<span class="fc" id="L139">    private boolean suggestHorizontalFocalLengthEnabled = DEFAULT_SUGGEST_HORIZONTAL_FOCAL_LENGTH_ENABLED;</span>

    /**
     * Suggested horizontal focal length value to be reached when suggestion is
     * enabled.
     * Suggested value should be close to the initially estimated value
     * otherwise the iterative refinement might not converge to provided value.
     */
    private double suggestedHorizontalFocalLengthValue;

    /**
     * Indicates whether vertical focal length is suggested or not. When
     * enabled, the estimator will attempt to enforce suggested value in an
     * iterative manner starting from an initially estimated camera.
     * Even when suggestion is enabled, the iterative algorithm might not reach
     * suggested value if the initial value largely differs from the suggested
     * value.
     */
<span class="fc" id="L157">    private boolean suggestVerticalFocalLengthEnabled = DEFAULT_SUGGEST_VERTICAL_FOCAL_LENGTH_ENABLED;</span>

    /**
     * Suggested vertical focal length value to be reached when suggestion is
     * enabled.
     * Suggested value should be close to the initially estimated value
     * otherwise the iterative refinement might not converge to provided value.
     */
    private double suggestedVerticalFocalLengthValue;

    /**
     * Indicates whether aspect ratio is suggested or not. When enabled, the
     * estimator will attempt to enforce suggested value in an iterative manner
     * starting from an initially estimated camera.
     * Even when suggestion is enabled, the iterative algorithm might not reach
     * suggested value if the initial value largely differs from the suggested
     * value.
     */
<span class="fc" id="L175">    private boolean suggestAspectRatioEnabled = DEFAULT_SUGGEST_ASPECT_RATIO_ENABLED;</span>

    /**
     * Suggested aspect ratio value to be reached when suggestion is enabled.
     * Suggested value should be close to the initially estimated value
     * otherwise the iterative refinement might not converge to provided value.
     */
<span class="fc" id="L182">    private double suggestedAspectRatioValue = DEFAULT_SUGGESTED_ASPECT_RATIO_VALUE;</span>

    /**
     * Indicates whether principal point is suggested or not. When enabled, the
     * estimator will attempt to enforce suggested value in an iterative manner
     * starting from an initially estimated camera.
     * Even when suggestion is enabled, the iterative algorithm might not reach
     * suggested value if the initial value largely differs from the suggested
     * value.
     */
<span class="fc" id="L192">    private boolean suggestPrincipalPointEnabled = DEFAULT_SUGGEST_PRINCIPAL_POINT_ENABLED;</span>

    /**
     * Suggested principal point value to be reached when suggestion is enabled.
     * Suggested value should be close to the initially estimated value
     * otherwise the iterative refinement might not converge to provided value.
     */
    private InhomogeneousPoint2D suggestedPrincipalPointValue;

    /**
     * Indicates whether camera rotation is suggested or not. When enabled, the
     * estimator will attempt to enforce suggested value in an iterative manner
     * starting from an initially estimated camera.
     * Even when suggestion is enabled, the iterative algorithm might not reach
     * suggested value if the initial value largely differs from the suggested
     * value.
     */
<span class="fc" id="L209">    private boolean suggestRotationEnabled = DEFAULT_SUGGEST_ROTATION_ENABLED;</span>

    /**
     * Suggested rotation to be reached when suggestion is enabled.
     * Suggested value should be close to the initially estimated value
     * otherwise the iterative refinement might not converge to provided value.
     */
    private Quaternion suggestedRotationValue;

    /**
     * Indicates whether camera center is suggested or not. When enabled, the
     * estimator will attempt to enforce suggested value in an iterative manner
     * starting from an initially estimated camera.
     * Even when suggestion is enabled, the iterative algorithm might not reach
     * suggested value if the initial value largely differs from the suggested
     * value.
     */
    private boolean suggestCenterEnabled;

    /**
     * Suggested center to be reached when suggestion is enabled.
     * Suggested value should be close to the initially estimated value
     * otherwise the iterative refinement might not converge to provided value.
     */
    private InhomogeneousPoint3D suggestedCenterValue;

    /**
     * Instance to be reused to compute residual for intrinsic parameters.
     */
    private PinholeCameraIntrinsicParameters residualIntrinsic;

    /**
     * Instance to be reused to compute residual on principal point.
     */
    private InhomogeneousPoint2D residualPrincipalPoint;

    /**
     * Instance to be reused to compute residual on rotation.
     */
    private Quaternion residualRotation;

    /**
     * Instance to be reused to compute center.
     */
    private InhomogeneousPoint3D residualCenter;

    /**
     * Constructor.
     */
<span class="fc" id="L258">    protected PinholeCameraRefiner() {</span>
<span class="fc" id="L259">    }</span>

    /**
     * Constructor.
     *
     * @param initialEstimation           initial estimation to be set.
     * @param keepCovariance              true if covariance of estimation must be kept after
     *                                    refinement, false otherwise.
     * @param inliers                     set indicating which of the provided matches are inliers.
     * @param residuals                   residuals for matched samples.
     * @param numInliers                  number of inliers on initial estimation.
     * @param samples1                    1st set of paired samples.
     * @param samples2                    2nd set of paired samples.
     * @param refinementStandardDeviation standard deviation used for
     *                                    Levenberg-Marquardt fitting.
     */
    protected PinholeCameraRefiner(
            final PinholeCamera initialEstimation, final boolean keepCovariance, final BitSet inliers,
            final double[] residuals, final int numInliers, final List&lt;S1&gt; samples1, final List&lt;S2&gt; samples2,
            final double refinementStandardDeviation) {
<span class="fc" id="L279">        super(initialEstimation, keepCovariance, inliers, residuals, numInliers, samples1, samples2);</span>
<span class="fc" id="L280">        this.refinementStandardDeviation = refinementStandardDeviation;</span>
<span class="fc" id="L281">    }</span>

    /**
     * Constructor.
     *
     * @param initialEstimation           initial estimation to be set.
     * @param keepCovariance              true if covariance of estimation must be kept after
     *                                    refinement, false otherwise.
     * @param inliersData                 inlier data, typically obtained from a robust
     *                                    estimator.
     * @param samples1                    1st set of paired samples.
     * @param samples2                    2nd set of paired samples.
     * @param refinementStandardDeviation standard deviation used for
     *                                    Levenberg-Marquardt fitting.
     */
    protected PinholeCameraRefiner(
            final PinholeCamera initialEstimation, final boolean keepCovariance, final InliersData inliersData,
            final List&lt;S1&gt; samples1, final List&lt;S2&gt; samples2, final double refinementStandardDeviation) {
<span class="fc" id="L299">        super(initialEstimation, keepCovariance, inliersData, samples1, samples2);</span>
<span class="fc" id="L300">        this.refinementStandardDeviation = refinementStandardDeviation;</span>
<span class="fc" id="L301">    }</span>

    /**
     * Gets standard deviation used for Levenberg-Marquardt fitting during
     * refinement.
     * Returned value gives an indication of how much variance each residual
     * has.
     * Typically, this value is related to the threshold used on each robust
     * estimation, since residuals of found inliers are within the range of such
     * threshold.
     *
     * @return standard deviation used for refinement.
     */
    public double getRefinementStandardDeviation() {
<span class="fc" id="L315">        return refinementStandardDeviation;</span>
    }

    /**
     * Sets standard deviation used for Levenberg-Marquardt fitting during
     * refinement.
     * Returned value gives an indication of how much variance each residual
     * has.
     * Typically, this value is related to the threshold used on each robust
     * estimation, since residuals of found inliers are within the range of such
     * threshold.
     *
     * @param refinementStandardDeviation standard deviation used for
     *                                    refinement.
     * @throws LockedException if estimator is locked.
     */
    public void setRefinementStandardDeviation(final double refinementStandardDeviation) throws LockedException {
<span class="fc bfc" id="L332" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L333">            throw new LockedException();</span>
        }
<span class="fc" id="L335">        this.refinementStandardDeviation = refinementStandardDeviation;</span>
<span class="fc" id="L336">    }</span>

    /**
     * Indicates whether skewness value is suggested or not. When enabled, the
     * estimator will attempt to enforce suggested value in an iterative manner
     * starting from an initially estimated camera.
     * Even when suggestion is enabled, the iterative algorithm might not reach
     * suggested value if the initial value largely differs from the suggested
     * value.
     *
     * @return true if skewness value is suggested, false otherwise.
     */
    public boolean isSuggestSkewnessValueEnabled() {
<span class="fc" id="L349">        return suggestSkewnessValueEnabled;</span>
    }

    /**
     * Specifies whether skewness value is suggested or not. When enabled, the
     * estimator will attempt to enforce suggested value in an iterative manner
     * starting from an initially estimated camera.
     * Even when suggestion is enabled, the iterative algorithm might not reach
     * suggested value if the initial value largely differs from the suggested
     * value.
     *
     * @param suggestSkewnessValueEnabled true if skewness value is suggested,
     *                                    false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setSuggestSkewnessValueEnabled(final boolean suggestSkewnessValueEnabled) throws LockedException {
<span class="fc bfc" id="L365" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L366">            throw new LockedException();</span>
        }
<span class="fc" id="L368">        this.suggestSkewnessValueEnabled = suggestSkewnessValueEnabled;</span>
<span class="fc" id="L369">    }</span>

    /**
     * Gets suggested skewness value to be reached when suggestion is enabled.
     * Suggested value should be close to the initially estimated value
     * otherwise the iterative refinement might not converge to provided value.
     *
     * @return suggested skewness value.
     */
    public double getSuggestedSkewnessValue() {
<span class="fc" id="L379">        return suggestedSkewnessValue;</span>
    }

    /**
     * Sets suggested skewness value to be reached when suggestion is enabled.
     * Suggested value should be close to the initially estimated value
     * otherwise the iterative refinement might not converge to provided value.
     *
     * @param suggestedSkewnessValue suggested skewness value.
     * @throws LockedException if estimator is locked.
     */
    public void setSuggestedSkewnessValue(final double suggestedSkewnessValue) throws LockedException {
<span class="fc bfc" id="L391" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L392">            throw new LockedException();</span>
        }
<span class="fc" id="L394">        this.suggestedSkewnessValue = suggestedSkewnessValue;</span>
<span class="fc" id="L395">    }</span>

    /**
     * Indicates whether horizontal focal length is suggested or not. When
     * enabled, the estimator will attempt to enforce suggested value in an
     * iterative manner starting from an initially estimated camera.
     * Even when suggestion is enabled, the iterative algorithm might not reach
     * suggested value if the initial value largely differs from the suggested
     * value.
     *
     * @return true if horizontal focal length is suggested, false otherwise.
     */
    public boolean isSuggestHorizontalFocalLengthEnabled() {
<span class="fc" id="L408">        return suggestHorizontalFocalLengthEnabled;</span>
    }

    /**
     * Specifies whether horizontal focal length is suggested or not. When
     * enabled, the estimator will attempt to enforce suggested value in an
     * iterative manner starting from an initially estimated camera.
     * Even when suggestion is enabled, the iterative algorithm might not reach
     * suggested value if the initial value largely differs from the suggested
     * value.
     *
     * @param suggestHorizontalFocalLengthEnabled true if horizontal focal
     *                                            length is suggested, false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setSuggestHorizontalFocalLengthEnabled(final boolean suggestHorizontalFocalLengthEnabled)
            throws LockedException {
<span class="fc bfc" id="L425" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L426">            throw new LockedException();</span>
        }
<span class="fc" id="L428">        this.suggestHorizontalFocalLengthEnabled = suggestHorizontalFocalLengthEnabled;</span>
<span class="fc" id="L429">    }</span>

    /**
     * Gets suggested horizontal focal length value to be reached when
     * suggestion is enabled.
     * Suggested value should be close to the initially estimated value
     * otherwise the iterative refinement might not converge to provided value.
     *
     * @return suggested horizontal focal length value.
     */
    public double getSuggestedHorizontalFocalLengthValue() {
<span class="fc" id="L440">        return suggestedHorizontalFocalLengthValue;</span>
    }

    /**
     * Sets suggested horizontal focal length value to be reached when
     * suggestion is enabled.
     * Suggested value should be close to the initially estimated value
     * otherwise the iterative refinement might not converge to provided value.
     *
     * @param suggestedHorizontalFocalLengthValue suggested horizontal focal
     *                                            length value.
     * @throws LockedException if estimator is locked.
     */
    public void setSuggestedHorizontalFocalLengthValue(final double suggestedHorizontalFocalLengthValue)
            throws LockedException {
<span class="fc bfc" id="L455" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L456">            throw new LockedException();</span>
        }
<span class="fc" id="L458">        this.suggestedHorizontalFocalLengthValue = suggestedHorizontalFocalLengthValue;</span>
<span class="fc" id="L459">    }</span>

    /**
     * Indicates whether vertical focal length is suggested or not. When
     * enabled, the estimator will attempt to enforce suggested value in an
     * iterative manner starting from an initially estimated camera.
     * Even when suggestion is enabled, the iterative algorithm might not reach
     * suggested value if the initial value largely differs from the suggested
     * value.
     *
     * @return true if vertical focal length is suggested, false otherwise.
     */
    public boolean isSuggestVerticalFocalLengthEnabled() {
<span class="fc" id="L472">        return suggestVerticalFocalLengthEnabled;</span>
    }

    /**
     * Specifies whether vertical focal length is suggested or not. When
     * enabled, the estimator will attempt to enforce suggested value in an
     * iterative manner starting from an initially estimated camera.
     * Even when suggestion is enabled, the iterative algorithm might not reach
     * suggested value if the initial value largely differs from the suggested
     * value.
     *
     * @param suggestVerticalFocalLengthEnabled true if vertical focal length is
     *                                          suggested, false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setSuggestVerticalFocalLengthEnabled(final boolean suggestVerticalFocalLengthEnabled)
            throws LockedException {
<span class="fc bfc" id="L489" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L490">            throw new LockedException();</span>
        }
<span class="fc" id="L492">        this.suggestVerticalFocalLengthEnabled = suggestVerticalFocalLengthEnabled;</span>
<span class="fc" id="L493">    }</span>

    /**
     * Gets suggested vertical focal length value to be reached when suggestion
     * is enabled.
     * Suggested value should be close to the initially estimated value
     * otherwise the iterative refinement might not converge to provided value.
     *
     * @return suggested vertical focal length.
     */
    public double getSuggestedVerticalFocalLengthValue() {
<span class="fc" id="L504">        return suggestedVerticalFocalLengthValue;</span>
    }

    /**
     * Sets suggested vertical focal length value to be reached when suggestion
     * is enabled.
     * Suggested value should be close to the initially estimated value
     * otherwise the iterative refinement might not converge to provided value.
     *
     * @param suggestedVerticalFocalLengthValue suggested vertical focal length.
     * @throws LockedException if estimator is locked.
     */
    public void setSuggestedVerticalFocalLengthValue(final double suggestedVerticalFocalLengthValue)
            throws LockedException {
<span class="fc bfc" id="L518" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L519">            throw new LockedException();</span>
        }
<span class="fc" id="L521">        this.suggestedVerticalFocalLengthValue = suggestedVerticalFocalLengthValue;</span>
<span class="fc" id="L522">    }</span>

    /**
     * Indicates whether aspect ratio is suggested or not. When enabled, the
     * estimator will attempt to enforce suggested value in an iterative manner
     * starting from an initially estimated camera.
     * Even when suggestion is enabled, the iterative algorithm might not reach
     * suggested value if the initial value largely differs from the suggested
     * value.
     *
     * @return true if aspect ratio is suggested, false otherwise.
     */
    public boolean isSuggestAspectRatioEnabled() {
<span class="fc" id="L535">        return suggestAspectRatioEnabled;</span>
    }

    /**
     * Specifies whether aspect ratio is suggested or not. When enabled, the
     * estimator will attempt to enforce suggested value in an iterative manner
     * starting from an initially estimated camera.
     * Even when suggestion is enabled, the iterative algorithm might not reach
     * suggested value if the initial value largely differs from the suggested
     * value.
     *
     * @param suggestAspectRatioEnabled true if aspect ratio is suggested, false
     *                                  otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setSuggestAspectRatioEnabled(final boolean suggestAspectRatioEnabled) throws LockedException {
<span class="fc bfc" id="L551" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L552">            throw new LockedException();</span>
        }
<span class="fc" id="L554">        this.suggestAspectRatioEnabled = suggestAspectRatioEnabled;</span>
<span class="fc" id="L555">    }</span>

    /**
     * Gets suggested aspect ratio value to be reached when suggestion is
     * enabled. Suggested value should be close to the initially estimated value
     * otherwise the iterative refinement might not converge to provided value.
     *
     * @return suggested aspect ratio value.
     */
    public double getSuggestedAspectRatioValue() {
<span class="fc" id="L565">        return suggestedAspectRatioValue;</span>
    }

    /**
     * Sets suggested aspect ratio value to be reached when suggestion is
     * enabled. Suggested value should be close to the initially estimated value
     * otherwise the iterative refinement might not converge to provided value.
     *
     * @param suggestedAspectRatioValue suggested aspect ratio value.
     * @throws LockedException if estimator is locked.
     */
    public void setSuggestedAspectRatioValue(final double suggestedAspectRatioValue) throws LockedException {
<span class="fc bfc" id="L577" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L578">            throw new LockedException();</span>
        }
<span class="fc" id="L580">        this.suggestedAspectRatioValue = suggestedAspectRatioValue;</span>
<span class="fc" id="L581">    }</span>

    /**
     * Indicates whether principal point is suggested or not. When enabled, the
     * estimator will attempt to enforce suggested value in an iterative manner
     * starting from an initially estimated camera.
     * Even when suggestion is enabled, the iterative algorithm might not reach
     * suggested value if the initial value largely differs from the suggested
     * value.
     *
     * @return true if principal point is suggested, false otherwise.
     */
    public boolean isSuggestPrincipalPointEnabled() {
<span class="fc" id="L594">        return suggestPrincipalPointEnabled;</span>
    }

    /**
     * Specifies whether principal point is suggested or not. When enabled, the
     * estimator will attempt to enforce suggested value in an iterative manner
     * starting from an initially estimated camera.
     * Even when suggestion is enabled, the iterative algorithm might not reach
     * suggested value if the initial value largely differs from the suggested
     * value.
     *
     * @param suggestPrincipalPointEnabled true if principal point is suggested,
     *                                     false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setSuggestPrincipalPointEnabled(final boolean suggestPrincipalPointEnabled) throws LockedException {
<span class="fc bfc" id="L610" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L611">            throw new LockedException();</span>
        }
<span class="fc" id="L613">        this.suggestPrincipalPointEnabled = suggestPrincipalPointEnabled;</span>
<span class="pc bpc" id="L614" title="1 of 4 branches missed.">        if (suggestPrincipalPointEnabled &amp;&amp; suggestedPrincipalPointValue == null) {</span>
<span class="fc" id="L615">            suggestedPrincipalPointValue = new InhomogeneousPoint2D();</span>
        }
<span class="fc" id="L617">    }</span>

    /**
     * Gets suggested principal point value to be reached when suggestion is
     * enabled. Suggested value should be close to the initially estimated value
     * otherwise the iterative refinement might not converge to provided value.
     *
     * @return suggested principal point value to be reached when suggestion is
     * enabled.
     */
    public InhomogeneousPoint2D getSuggestedPrincipalPointValue() {
<span class="fc" id="L628">        return suggestedPrincipalPointValue;</span>
    }

    /**
     * Sets suggested principal point value to be reached when suggestion is
     * enabled. Suggested value should be close to the initially estimated value
     * otherwise the iterative refinement might not converge to provided value.
     *
     * @param suggestedPrincipalPointValue suggested principal point value to be
     *                                     reached when suggestion is enabled.
     * @throws LockedException if estimator is locked.
     */
    public void setSuggestedPrincipalPointValue(final InhomogeneousPoint2D suggestedPrincipalPointValue)
            throws LockedException {
<span class="fc bfc" id="L642" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L643">            throw new LockedException();</span>
        }
<span class="fc" id="L645">        this.suggestedPrincipalPointValue = suggestedPrincipalPointValue;</span>
<span class="fc" id="L646">    }</span>

    /**
     * Indicates whether camera rotation is suggested or not. When enabled, the
     * estimator will attempt to enforce suggested value in an iterative manner
     * starting from an initially estimated camera.
     * Even when suggestion is enabled, the iterative algorithm might not reach
     * suggested value if the initial value largely differs from the suggested
     * value.
     *
     * @return true if camera rotation is suggested, false otherwise.
     */
    public boolean isSuggestRotationEnabled() {
<span class="fc" id="L659">        return suggestRotationEnabled;</span>
    }

    /**
     * Specifies whether camera rotation is suggested or not. When enabled, the
     * estimator will attempt to enforce suggested value in an iterative manner
     * starting from an initially estimated camera.
     * Even when suggestion is enabled, the iterative algorithm might not reach
     * suggested value if the initial value largely differs from the suggested
     * value.
     *
     * @param suggestRotationEnabled true if camera rotation is suggested, false
     *                               otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setSuggestRotationEnabled(final boolean suggestRotationEnabled) throws LockedException {
<span class="fc bfc" id="L675" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L676">            throw new LockedException();</span>
        }
<span class="fc" id="L678">        this.suggestRotationEnabled = suggestRotationEnabled;</span>
<span class="pc bpc" id="L679" title="1 of 4 branches missed.">        if (suggestRotationEnabled &amp;&amp; suggestedRotationValue == null) {</span>
<span class="fc" id="L680">            suggestedRotationValue = new Quaternion();</span>
        }

<span class="fc" id="L683">    }</span>

    /**
     * Gets suggested rotation to be reached when suggestion is enabled.
     * Suggested value should be close to the initially estimated value
     * otherwise the iterative refinement might not converge to provided value.
     *
     * @return suggested rotation to be reached when suggestion is enabled.
     */
    public Quaternion getSuggestedRotationValue() {
<span class="fc" id="L693">        return suggestedRotationValue;</span>
    }

    /**
     * Sets suggested rotation to be reached when suggestion is enabled.
     * Suggested value should be close to the initially estimated value
     * otherwise the iterative refinement might not converge to provided value.
     *
     * @param suggestedRotationValue suggested rotation to be reached when
     *                               suggestion is enabled.
     * @throws LockedException if estimator is locked.
     */
    public void setSuggestedRotationValue(final Quaternion suggestedRotationValue) throws LockedException {
<span class="fc bfc" id="L706" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L707">            throw new LockedException();</span>
        }
<span class="fc" id="L709">        this.suggestedRotationValue = suggestedRotationValue;</span>
<span class="fc" id="L710">    }</span>

    /**
     * Indicates whether camera center is suggested or not. When enabled, the
     * estimator will attempt to enforce suggested value in an iterative manner
     * starting from an initially estimated camera.
     * Even when suggestion is enabled, the iterative algorithm might not reach
     * suggested value if the initial value largely differs from the suggested
     * value.
     *
     * @return true if camera center is suggested, false otherwise.
     */
    public boolean isSuggestCenterEnabled() {
<span class="fc" id="L723">        return suggestCenterEnabled;</span>
    }

    /**
     * Specifies whether camera center is suggested or not. When enabled, the
     * estimator will attempt to enforce suggested value in an iterative manner
     * starting from an initially estimated camera.
     * Even when suggestion is enabled, the iterative algorithm might not reach
     * suggested value if the initial value largely differs from the suggested
     * value.
     *
     * @param suggestCenterEnabled true if camera is suggested, false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setSuggestCenterEnabled(final boolean suggestCenterEnabled) throws LockedException {
<span class="fc bfc" id="L738" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L739">            throw new LockedException();</span>
        }
<span class="fc" id="L741">        this.suggestCenterEnabled = suggestCenterEnabled;</span>
<span class="pc bpc" id="L742" title="1 of 4 branches missed.">        if (suggestCenterEnabled &amp;&amp; suggestedCenterValue == null) {</span>
<span class="fc" id="L743">            suggestedCenterValue = new InhomogeneousPoint3D();</span>
        }
<span class="fc" id="L745">    }</span>

    /**
     * Gets suggested center to be reached when suggestion is enabled.
     * Suggested value should be close to the initially estimated value
     * otherwise the iterative refinement might not converge to provided value.
     *
     * @return suggested center to be reached when suggestion is enabled.
     */
    public InhomogeneousPoint3D getSuggestedCenterValue() {
<span class="fc" id="L755">        return suggestedCenterValue;</span>
    }

    /**
     * Sets suggested center to be reached when suggestion is enabled.
     * Suggested value should be close to the initially estimated value
     * otherwise the iterative refinement might not converge to provided value.
     *
     * @param suggestedCenterValue suggested center to be reached when
     *                             suggestion is enabled.
     * @throws LockedException if estimator is locked.
     */
    public void setSuggestedCenterValue(final InhomogeneousPoint3D suggestedCenterValue) throws LockedException {
<span class="fc bfc" id="L768" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L769">            throw new LockedException();</span>
        }
<span class="fc" id="L771">        this.suggestedCenterValue = suggestedCenterValue;</span>
<span class="fc" id="L772">    }</span>

    /**
     * Refines provided initial estimation.
     *
     * @return refines estimation.
     * @throws NotReadyException if not enough input data has been provided.
     * @throws LockedException   if estimator is locked because refinement is
     *                           already in progress.
     * @throws RefinerException  if refinement fails for some reason (e.g. unable
     *                           to converge to a result).
     */
    @Override
    public PinholeCamera refine() throws NotReadyException, LockedException, RefinerException {
<span class="fc" id="L786">        final var result = new PinholeCamera();</span>
<span class="fc" id="L787">        refine(result);</span>
<span class="fc" id="L788">        return result;</span>
    }

    /**
     * Residual term for any required suggestions.
     *
     * @param params parameters being optimized. In the following order:
     *               skewness, horizontal focal length, vertical focal length,
     *               horizontal principal point, vertical principal point, quaternion A,
     *               quaternion B, quaternion C, quaternion D, center x, center y, center z.
     * @param weight weight to apply to obtained residual. This weight increases
     *               on each iteration to help into achieving required suggested values.
     * @return term for any required suggestion.
     */
    protected double suggestionResidual(final double[] params, final double weight) {
<span class="fc" id="L803">        double residual = 0.0;</span>

<span class="fc bfc" id="L805" title="All 2 branches covered.">        if (suggestSkewnessValueEnabled) {</span>
<span class="fc" id="L806">            residual += Math.pow(params[0] - suggestedSkewnessValue, 2.0);</span>
        }

<span class="fc bfc" id="L809" title="All 2 branches covered.">        if (suggestHorizontalFocalLengthEnabled) {</span>
<span class="fc" id="L810">            residual += Math.pow(params[1] - suggestedHorizontalFocalLengthValue, 2.0);</span>
        }

<span class="fc bfc" id="L813" title="All 2 branches covered.">        if (suggestVerticalFocalLengthEnabled) {</span>
<span class="fc" id="L814">            residual += Math.pow(params[2] - suggestedVerticalFocalLengthValue, 2.0);</span>
        }

<span class="fc bfc" id="L817" title="All 2 branches covered.">        if (suggestAspectRatioEnabled) {</span>
<span class="fc" id="L818">            final var aspectRatio = params[2] / params[1];</span>
<span class="fc" id="L819">            residual += Math.pow(aspectRatio - suggestedAspectRatioValue, 2.0);</span>
        }

<span class="fc bfc" id="L822" title="All 2 branches covered.">        if (suggestPrincipalPointEnabled) {</span>
<span class="fc bfc" id="L823" title="All 2 branches covered.">            if (residualPrincipalPoint == null) {</span>
<span class="fc" id="L824">                residualPrincipalPoint = new InhomogeneousPoint2D(params[3], params[4]);</span>
            } else {
<span class="fc" id="L826">                residualPrincipalPoint.setInhomogeneousCoordinates(params[3], params[4]);</span>
            }

<span class="fc" id="L829">            residual += Math.pow(residualPrincipalPoint.distanceTo(suggestedPrincipalPointValue), 2.0);</span>
        }

<span class="fc bfc" id="L832" title="All 2 branches covered.">        if (suggestRotationEnabled) {</span>
<span class="pc bpc" id="L833" title="1 of 2 branches missed.">            if (residualRotation == null) {</span>
<span class="nc" id="L834">                residualRotation = new Quaternion(params[5], params[6], params[7], params[8]);</span>
            } else {
<span class="fc" id="L836">                residualRotation.setA(params[5]);</span>
<span class="fc" id="L837">                residualRotation.setB(params[6]);</span>
<span class="fc" id="L838">                residualRotation.setC(params[7]);</span>
<span class="fc" id="L839">                residualRotation.setD(params[8]);</span>
            }
<span class="fc" id="L841">            residualRotation.normalize();</span>
<span class="fc" id="L842">            suggestedRotationValue.normalize();</span>
<span class="fc" id="L843">            residual += Math.pow(residualRotation.getA() - suggestedRotationValue.getA(), 2.0)</span>
<span class="fc" id="L844">                    + Math.pow(residualRotation.getB() - suggestedRotationValue.getB(), 2.0)</span>
<span class="fc" id="L845">                    + Math.pow(residualRotation.getC() - suggestedRotationValue.getC(), 2.0)</span>
<span class="fc" id="L846">                    + Math.pow(residualRotation.getD() - suggestedRotationValue.getD(), 2.0);</span>
        }

<span class="fc bfc" id="L849" title="All 2 branches covered.">        if (suggestCenterEnabled) {</span>
<span class="fc bfc" id="L850" title="All 2 branches covered.">            if (residualCenter == null) {</span>
<span class="fc" id="L851">                residualCenter = new InhomogeneousPoint3D(params[9], params[10], params[11]);</span>
            } else {
<span class="fc" id="L853">                residualCenter.setInhomogeneousCoordinates(params[9], params[10], params[11]);</span>
            }
<span class="fc" id="L855">            residual += Math.pow(residualCenter.distanceTo(suggestedCenterValue), 2.0);</span>
        }

<span class="fc" id="L858">        return weight * residual;</span>
    }

    /**
     * Sets array of parameters into a pinhole camera.
     * This method is used internally during refinement.
     *
     * @param params parameters to be set. In the following order:
     *               skewness, horizontal focal length, vertical focal length,
     *               horizontal principal point, vertical principal point, quaternion A,
     *               quaternion B, quaternion C, quaternion D, center x, center y, center z.
     * @param result instance where parameters will be set.
     */
    protected void parametersToCamera(final double[] params, final PinholeCamera result) {

<span class="fc bfc" id="L873" title="All 2 branches covered.">        if (residualIntrinsic == null) {</span>
<span class="fc" id="L874">            residualIntrinsic = new PinholeCameraIntrinsicParameters();</span>
        }
<span class="fc" id="L876">        residualIntrinsic.setSkewness(params[0]);</span>
<span class="fc" id="L877">        residualIntrinsic.setHorizontalFocalLength(params[1]);</span>
<span class="fc" id="L878">        residualIntrinsic.setVerticalFocalLength(params[2]);</span>
<span class="fc" id="L879">        residualIntrinsic.setHorizontalPrincipalPoint(params[3]);</span>
<span class="fc" id="L880">        residualIntrinsic.setVerticalPrincipalPoint(params[4]);</span>

<span class="pc bpc" id="L882" title="1 of 2 branches missed.">        if (residualRotation == null) {</span>
<span class="nc" id="L883">            residualRotation = new Quaternion(params[5], params[6], params[7], params[8]);</span>
        } else {
<span class="fc" id="L885">            residualRotation.setA(params[5]);</span>
<span class="fc" id="L886">            residualRotation.setB(params[6]);</span>
<span class="fc" id="L887">            residualRotation.setC(params[7]);</span>
<span class="fc" id="L888">            residualRotation.setD(params[8]);</span>
        }
<span class="fc" id="L890">        residualRotation.normalize();</span>

<span class="fc bfc" id="L892" title="All 2 branches covered.">        if (residualCenter == null) {</span>
<span class="fc" id="L893">            residualCenter = new InhomogeneousPoint3D(params[9], params[10], params[11]);</span>
        } else {
<span class="fc" id="L895">            residualCenter.setInhomogeneousCoordinates(params[9], params[10], params[11]);</span>
        }
<span class="fc" id="L897">        residualCenter.normalize();</span>

<span class="fc" id="L899">        result.setIntrinsicAndExtrinsicParameters(residualIntrinsic, residualRotation, residualCenter);</span>
<span class="fc" id="L900">        result.normalize();</span>
<span class="fc" id="L901">    }</span>

    /**
     * Sets camera parameters into array of parameters.
     * This method is used internally during refinement.
     *
     * @param camera camera to obtain parameters to be set into array.
     * @param result array where extracted parameters are stored. In the
     *               following order:
     *               skewness, horizontal focal length, vertical focal length,
     *               horizontal principal point, vertical principal point, quaternion A,
     *               quaternion B, quaternion C, quaternion D, center x, center y, center z.
     * @throws CameraException       if camera cannot be decomposed.
     * @throws NotAvailableException if any camera component cannot be
     *                               retrieved.
     */
    protected void cameraToParameters(final PinholeCamera camera, final double[] result) throws CameraException,
            NotAvailableException {

<span class="fc" id="L920">        camera.decompose();</span>

<span class="fc" id="L922">        final var intrinsic = camera.getIntrinsicParameters();</span>
<span class="fc" id="L923">        result[0] = intrinsic.getSkewness();</span>
<span class="fc" id="L924">        result[1] = intrinsic.getHorizontalFocalLength();</span>
<span class="fc" id="L925">        result[2] = intrinsic.getVerticalFocalLength();</span>
<span class="fc" id="L926">        result[3] = intrinsic.getHorizontalPrincipalPoint();</span>
<span class="fc" id="L927">        result[4] = intrinsic.getVerticalPrincipalPoint();</span>

<span class="fc" id="L929">        final var rotation = camera.getCameraRotation();</span>
<span class="fc bfc" id="L930" title="All 2 branches covered.">        if (residualRotation == null) {</span>
<span class="fc" id="L931">            residualRotation = rotation.toQuaternion();</span>
        } else {
<span class="fc" id="L933">            rotation.toQuaternion(residualRotation);</span>
        }
<span class="fc" id="L935">        residualRotation.normalize();</span>

<span class="fc" id="L937">        result[5] = residualRotation.getA();</span>
<span class="fc" id="L938">        result[6] = residualRotation.getB();</span>
<span class="fc" id="L939">        result[7] = residualRotation.getC();</span>
<span class="fc" id="L940">        result[8] = residualRotation.getD();</span>

<span class="fc" id="L942">        final var center = camera.getCameraCenter();</span>

<span class="fc" id="L944">        result[9] = center.getInhomX();</span>
<span class="fc" id="L945">        result[10] = center.getInhomY();</span>
<span class="fc" id="L946">        result[11] = center.getInhomZ();</span>
<span class="fc" id="L947">    }</span>

    /**
     * Indicates whether obtained solution requires refinement to apply provided
     * suggestions.
     *
     * @return true if solution requires refinement to apply provided
     * suggestions, false otherwise.
     */
    protected boolean hasSuggestions() {
<span class="fc bfc" id="L957" title="All 4 branches covered.">        return hasIntrinsicSuggestions() || hasExtrinsicSuggestions();</span>
    }

    /**
     * Indicates whether suggestions for any intrinsic parameter are required
     * or not.
     *
     * @return true if suggestions for any intrinsic parameters are required,
     * false otherwise.
     */
    private boolean hasIntrinsicSuggestions() {
<span class="fc bfc" id="L968" title="All 8 branches covered.">        return suggestSkewnessValueEnabled || suggestHorizontalFocalLengthEnabled || suggestVerticalFocalLengthEnabled</span>
                || suggestAspectRatioEnabled;
    }

    /**
     * Indicates whether suggestions for any extrinsic parameter are required
     * or not.
     *
     * @return true if suggestions for any extrinsic parameter are required,
     * false otherwise.
     */
    private boolean hasExtrinsicSuggestions() {
<span class="fc bfc" id="L980" title="All 6 branches covered.">        return suggestPrincipalPointEnabled || suggestRotationEnabled || suggestCenterEnabled;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>