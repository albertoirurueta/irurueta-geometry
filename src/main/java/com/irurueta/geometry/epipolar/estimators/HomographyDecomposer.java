/**
 * @file
 * This file contains implementation of
 * com.irurueta.geometry.epipolar.estimators.HomographyDecomposer
 * 
 * @author Alberto Irurueta (alberto@irurueta.com)
 * @date May 24, 2017.
 */
package com.irurueta.geometry.epipolar.estimators;

import com.irurueta.algebra.AlgebraException;
import com.irurueta.algebra.Matrix;
import com.irurueta.algebra.SingularValueDecomposer;
import com.irurueta.geometry.EuclideanTransformation3D;
import com.irurueta.geometry.InvalidRotationMatrixException;
import com.irurueta.geometry.MatrixRotation3D;
import com.irurueta.geometry.PinholeCameraIntrinsicParameters;
import com.irurueta.geometry.Transformation2D;
import com.irurueta.geometry.estimators.LockedException;
import com.irurueta.geometry.estimators.NotReadyException;
import java.util.ArrayList;
import java.util.List;

/**
 * Decomposes a 2D homography to extract its internal geometry structure. There 
 * are four possible solutions, with two that are physically possible. The 
 * physically possible solution can be found by imposing a positive depth
 * constraint (reconstructed points must lie in front of the cameras).
 * An homography matrix is defined as H = (R + (1/d)*T*N<sup>T</sup>), where R 
 * is a 3x3 rotation matrix, d is the distance of the plane, N is the plane's 
 * normal, T is the translation vector. The decomposition works by computing the
 * SVD of H<sup>T</sup>H and then following the procedure defined in 
 * O. Faugeras, Motion and structure from motion in a piecewise planar 
 * environment.
 */
public class HomographyDecomposer {
    
    /**
     * Number of inhomogeneous coordinates in 3D.
     */
    public static final int NUM_COORDS_3D = 3;
    
    /**
     * Threshold to determine that two singular values are equal.
     */
    public static final double EQUAL_SINGULAR_VALUE_THRESHOLD = 1e-12;
        
    /**
     * 2D transformation relating two views (left view to right view).
     */
    private Transformation2D mHomography;
    
    /**
     * Intrinsic parameters to be used on left view.
     */
    private PinholeCameraIntrinsicParameters mLeftIntrinsics;
    
    /**
     * Intrinsic parameters to be used on right view.
     */
    private PinholeCameraIntrinsicParameters mRightIntrinsics;
    
    /**
     * Listener to handle events raised by this instance.
     */
    private HomographyDecomposerListener mListener;
    
    /**
     * Indicates whether decomposer is locked while computing decomposition.
     */
    private boolean mLocked;
    
    /**
     * Constructor.
     */
    public HomographyDecomposer() { }
    
    /**
     * Constructor.
     * @param homography 2D transformation relating two views (left view to 
     * right view).
     * @param leftIntrinsics intrinsic parameters to be used on left view.
     * @param rightIntrinsics intrinsic parameters to be used on right view.
     */
    public HomographyDecomposer(Transformation2D homography,
            PinholeCameraIntrinsicParameters leftIntrinsics,
            PinholeCameraIntrinsicParameters rightIntrinsics) {
        mHomography = homography;
        mLeftIntrinsics = leftIntrinsics;
        mRightIntrinsics = rightIntrinsics;
    }
    
    /**
     * Constructor.
     * @param homography 2D transformation relating two views (left view to 
     * right view).
     * @param leftIntrinsics intrinsic parameters to be used on left view.
     * @param rightIntrinsics intrinsic parameters to be used on right view.
     * @param listener listener to attend events generated by this instance.
     */
    public HomographyDecomposer(Transformation2D homography,
            PinholeCameraIntrinsicParameters leftIntrinsics,
            PinholeCameraIntrinsicParameters rightIntrinsics,
            HomographyDecomposerListener listener) {
        this(homography, leftIntrinsics, rightIntrinsics);
        mListener = listener;
    }
    
    /**
     * Gets 2D transformation relating two views (left view to right view).
     * @return 2D transformation relating two views.
     */
    public Transformation2D getHomography() {
        return mHomography;
    }
    
    /**
     * Sets 2D transformation relating two views (left view to right view).
     * @param homography 2D transformation relating two views.
     * @throws LockedException if estimator is locked.
     */
    public void setHomography(Transformation2D homography) 
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mHomography = homography;
    }
    
    /**
     * Gets intrinsic parameters to be used on left view.
     * @return intrinsic parameters to be used on left view.
     */
    public PinholeCameraIntrinsicParameters getLeftIntrinsics() {
        return mLeftIntrinsics;
    }
    
    /**
     * Sets intrinsic parameters to be used on left view.
     * @param leftIntrinsics intrinsic parameters to be used on left view.
     * @throws LockedException if estimator is locked.
     */
    public void setLeftIntrinsics(
            PinholeCameraIntrinsicParameters leftIntrinsics) 
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mLeftIntrinsics = leftIntrinsics;
    }
    
    /**
     * Gets intrinsic parameters to be used on right view.
     * @return intrinsic parameters to be used on right view.
     */
    public PinholeCameraIntrinsicParameters getRightIntrinsics() {
        return mRightIntrinsics;
    }
    
    /**
     * Sets intrinsic parameters to be used on right view.
     * @param rightIntrinsics intrinsic parameters to be used on right view.
     * @throws LockedException if estimator is locked.
     */
    public void setRightIntrinsics(
            PinholeCameraIntrinsicParameters rightIntrinsics) 
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mRightIntrinsics = rightIntrinsics;
    }
    
    /**
     * Gets listener to handle events raised by this instance.
     * @return listener to handle events raised by this instance.
     */
    public HomographyDecomposerListener getListener() {
        return mListener;
    }
    
    /**
     * Sets listener to handle events raised by this instance.
     * @param listener listener to handle events raised by this instance.
     */
    public void setListener(HomographyDecomposerListener listener) {
        mListener = listener;
    }
    
    /**
     * Indicates whether estimator is locked while computing decomposition.
     * @return true if decomposer is locked, false otherwise.
     */
    public boolean isLocked() {
        return mLocked;
    }
    
    /**
     * Indicates whether decomposer is ready to start the decomposition when all
     * required data has been provided.
     * @return true if decomposer is ready, false otherwise.
     */
    public boolean isReady() {
        return mHomography != null && mLeftIntrinsics != null &&
                mRightIntrinsics != null;
    }
    
    /**
     * Decomposes homography into possible solutions containing possible 3D
     * rotation, 3D translation and normal and distance of the plane relating
     * two views via provided homography.
     * @return possible solutions.
     * @throws LockedException if decomposer is locked.
     * @throws NotReadyException if decomposer is not ready.
     * @throws HomographyDecomposerException if decomposition fails for some 
     * other reason (i.e. numerical instabilities).
     */
    public List<HomographyDecomposition> decompose() throws LockedException, 
            NotReadyException, HomographyDecomposerException {
        List<HomographyDecomposition> result = 
                new ArrayList<HomographyDecomposition>();
        decompose(result);
        return result;
    }
    
    /**
     * Decomposes homography into possible solutions containing possible 3D
     * rotation, 3D translation and normal and distance of the plane relating
     * two views via provided homography.
     * @param result instance where possible solutions will be stored.
     * @throws LockedException if decomposer is locked.
     * @throws NotReadyException if decomposer is not ready.
     * @throws HomographyDecomposerException if decomposition fails for some
     * other reason (i.e. numerical instabilities).
     */
    public void decompose(List<HomographyDecomposition> result) 
            throws LockedException, NotReadyException, 
            HomographyDecomposerException {
        if(isLocked()) {
            throw new LockedException();
        }
        
        if(!isReady()) {
            throw new NotReadyException();
        }
        
        try {
            mLocked = true;
            result.clear();
            
            if (mListener != null) {
                mListener.onDecomposeStart(this);
            }   
            
            Matrix H = computeNormalizedCoordinatesHomographyMatrix();
            
            //Homography matrix H can be expressed as:
            //H = d*R + t*n^T
            //where d is the distance to the plane used to relate both views, R 
            //is a rotation relating both views so that R*R^T = I and 
            //det(R) = 1, t is the translation relating both views and n is the 
            //normal of the plane relating both views.
            
            //By using SVD decomposition, we get:
            //H = U*A'*V^T
            
            //where U and V are orthonormal matrices and A' is a diagonal matrix
            //containing singular values in decreasing order d1 >= d2 >= d3
            
            //Hence A' can also be expressed similarly to H as:
            //A' = d'*R' + t'*n'^T, and the relation to d, R, t and n is as 
            //follows:
            //H = U*(d'*R' + t'*n'^T)*V^T = d'*U*R'*V^T + U*t'*n'^T*V^T
            //d = d'
            //R = U*R'*V^T
            //t = U*t'
            //n^T = n'T*V^T --> n = V*n'
            
            SingularValueDecomposer svdDecomposer = 
                    new SingularValueDecomposer(H);
            svdDecomposer.decompose();
            Matrix U = svdDecomposer.getU();
            double[] singularValues = svdDecomposer.getSingularValues();
            Matrix V = svdDecomposer.getV();
            
            List<double[]> n = new ArrayList<double[]>();
            List<Matrix> R = new ArrayList<Matrix>();
            List<double[]> t = new ArrayList<double[]>();
            List<Double> d = new ArrayList<Double>();
            int numSolutions = decomposeAllFromSingularValues(singularValues, n,
                    R, t, d);
            
            Matrix transV = V.transposeAndReturnNew();
            Matrix translationMatrix = new Matrix(NUM_COORDS_3D, 1);
            Matrix planeNormalMatrix = new Matrix(NUM_COORDS_3D, 1);
            
            for (int i = 0; i < numSolutions; i++) {
                //undo U, V decomposition

                //R = U*R'*V^T
                Matrix denormalizedR = U.clone();
                denormalizedR.multiply(R.get(i));
                denormalizedR.multiply(transV);
                
                //t = U*t'
                translationMatrix.fromArray(t.get(i), true);
                Matrix denormalizedTranslationMatrix = U.multiplyAndReturnNew(
                        translationMatrix);
                
                //n = V*n'
                planeNormalMatrix.fromArray(n.get(i));
                Matrix denormalizedPlaneNormalMatrix = V.multiplyAndReturnNew(
                        planeNormalMatrix);
                
                double denormalizedPlaneDistance = d.get(i);

                //rotation
                MatrixRotation3D denormalizedRotation = new MatrixRotation3D(
                        denormalizedR);
                double[] denormalizedTranslation = 
                        denormalizedTranslationMatrix.getBuffer();
                double[] denormalizedPlaneNormal = 
                        denormalizedPlaneNormalMatrix.getBuffer();
                
                //set rotation and translation
                EuclideanTransformation3D transformation = 
                        new EuclideanTransformation3D(denormalizedRotation, 
                                denormalizedTranslation);
        
                result.add(new HomographyDecomposition(transformation, 
                        denormalizedPlaneNormal, denormalizedPlaneDistance));                
            }
        } catch (InvalidRotationMatrixException e) {
            throw new HomographyDecomposerException(e);
        } catch (AlgebraException e) {
            throw new HomographyDecomposerException(e);            
        } finally {
            if (mListener != null) {
                mListener.onDecomposeEnd(this, result);
            }
            mLocked = false;
        }        
    }
    
    /**
     * Decompose solutions from singular values.
     * @param singularValues input singular values.
     * @param n list containing possible plane normals.
     * @param R list containing possible camera rotations.
     * @param t list containing possible camera translations.
     * @param d list of distances to plane.
     * @return number of solutions.
     * @throws HomographyDecomposerException if decomposition fails (i.e. numerical instabilities, etc).
     */
    private int decomposeAllFromSingularValues(double[] singularValues, 
            List<double[]> n, List<Matrix> R, List<double[]> t, List<Double> d) 
            throws HomographyDecomposerException {
        
        n.clear();
        R.clear();
        t.clear();
        d.clear();
        
        if(areThreeDifferentSingularValues(singularValues)) {
            //Three different singular values
            double[] n1 = new double[NUM_COORDS_3D];
            double[] n2 = new double[NUM_COORDS_3D];
            double[] n3 = new double[NUM_COORDS_3D];
            double[] n4 = new double[NUM_COORDS_3D];
            Matrix R1 = null, R2 = null, R3 = null, R4 = null;
            try {
                R1 = new Matrix(NUM_COORDS_3D, NUM_COORDS_3D);
                R2 = new Matrix(NUM_COORDS_3D, NUM_COORDS_3D);
                R3 = new Matrix(NUM_COORDS_3D, NUM_COORDS_3D);
                R4 = new Matrix(NUM_COORDS_3D, NUM_COORDS_3D);
            } catch(AlgebraException ignore) { /* never thrown */ }
            double[] t1 = new double[NUM_COORDS_3D];
            double[] t2 = new double[NUM_COORDS_3D];
            double[] t3 = new double[NUM_COORDS_3D];
            double[] t4 = new double[NUM_COORDS_3D];
                        
            double planeDistance1 = decomposeFromSingularValues(singularValues, 
                    n1, R1, t1, true, true);
            double planeDistance2 = decomposeFromSingularValues(singularValues, 
                    n2, R2, t2, false, true);
            double planeDistance3 = decomposeFromSingularValues(singularValues, 
                    n3, R3, t3, true, false);
            double planeDistance4 = decomposeFromSingularValues(singularValues, 
                    n4, R4, t4, false, false);
            
            n.add(n1);
            n.add(n2);
            n.add(n3);
            n.add(n4);
            
            R.add(R1);
            R.add(R2);
            R.add(R3);
            R.add(R4);
            
            t.add(t1);
            t.add(t2);
            t.add(t3);
            t.add(t4);
            
            d.add(planeDistance1);
            d.add(planeDistance2);
            d.add(planeDistance3);
            d.add(planeDistance4);
            
            return n.size();
            
        } else if (areTwoEqualSingularValues(singularValues)) {
            //Two different singular values
            double[] n1 = new double[NUM_COORDS_3D];
            double[] n2 = new double[NUM_COORDS_3D];
            Matrix R1 = null, R2 = null;
            try {
                R1 = new Matrix(NUM_COORDS_3D, NUM_COORDS_3D);
                R2 = new Matrix(NUM_COORDS_3D, NUM_COORDS_3D);
            } catch(AlgebraException ignore) { /* never thrown */ }
            double[] t1 = new double[NUM_COORDS_3D];
            double[] t2 = new double[NUM_COORDS_3D];
            
            double planeDistance1 = decomposeFromSingularValues(singularValues, 
                    n1, R1, t1, true, true);
            double planeDistance2 = decomposeFromSingularValues(singularValues, 
                    n2, R2, t2, true, false);            
            
            n.add(n1);
            n.add(n2);
            
            R.add(R1);
            R.add(R2);
            
            t.add(t1);
            t.add(t2);
            
            d.add(planeDistance1);
            d.add(planeDistance2);
            
            return n.size();
            
        } else {
            //Three equal singular values
            throw new HomographyDecomposerException("undefined plane normal");            
        }
    }
    
    /**
     * Determines whether there are three different singular values or not.
     * @param singularValues singular values to be checked.
     * @return true if there are three different singular values, false 
     * otherwise.
     */
    private static boolean areThreeDifferentSingularValues(
            double[] singularValues) {
        double d1 = singularValues[0];
        double d2 = singularValues[1];
        double d3 = singularValues[2];        
        
        return (Math.abs(d1 - d2) > EQUAL_SINGULAR_VALUE_THRESHOLD) &&
                (Math.abs(d2 - d3) > EQUAL_SINGULAR_VALUE_THRESHOLD);
    }
    
    /**
     * Determines whether there are two equal singular values or not.
     * @param singularValues singular values to be checked.
     * @return true if there are two equal singular values, false otherwise.
     */
    private static boolean areTwoEqualSingularValues(double[] singularValues) {
        double d1 = singularValues[0];
        double d2 = singularValues[1];
        double d3 = singularValues[2];        
        
        return ((Math.abs(d1 - d2) <= EQUAL_SINGULAR_VALUE_THRESHOLD) && 
                (Math.abs(d2 - d3) > EQUAL_SINGULAR_VALUE_THRESHOLD)) ||
                ((Math.abs(d1 - d2) > EQUAL_SINGULAR_VALUE_THRESHOLD) &&
                (Math.abs(d2 - d3) <= EQUAL_SINGULAR_VALUE_THRESHOLD));
    }
    
    /**
     * Decomposes one possible solution using provided singular values and signs
     * @param singularValues singular values to use for 
     * @param n array where plane normal will be store.
     * @param R matrix where rotation will be stored.
     * @param t array where translation will be stored.
     * @param positive1 sign of 1st coordinate of plane normal.
     * @param positive3 sign of 2nd coordinate of plane normal.
     * @return plane distance.
     * @throws HomographyDecomposerException if decomposition is undetermined
     * when all three singular values are equal.
     */
    private double decomposeFromSingularValues(double[] singularValues, 
            double[] n, Matrix R, double[] t, boolean positive1, 
            boolean positive3) throws HomographyDecomposerException {
        double d1 = singularValues[0];
        double d2 = singularValues[1];
        double d3 = singularValues[2];
        
        if (areThreeDifferentSingularValues(singularValues)) {
            //Three different singular values
            if (d2 > 0.0) {
                //Three different singular values d1 != d2 != d3 and d'= d2 > 0
                return decomposeFromThreeDifferentSingularValuesPositive(d1, d2,
                        d3, n, R, t, positive1, positive3);
            } else {
                //Three different singular values and d' = d2 < 0
                return decomposeFromThreeDifferentSingularValuesNegative(d1, d2,
                        d3, n, R, t, positive1, positive3);                
            }
        } if (areTwoEqualSingularValues(singularValues)) {
            //Two different singular values
            if (d2 > 0.0) {
                //Two different singular values d1 = d2 != d3 or d1 != d2 = d3 
                //and d2 > 0
                return decomposeFromTwoDifferentSingularValuesPositive(d1, d2, 
                        d3, n, R, t, positive3);
            } else {
                //Two different singular values d1 = d2 != d3 or d1 != d2 = d3 
                //and d2 < 0
                return decomposeFromTwoDifferentSingularValuesNegative(d1, d2, 
                        d3, n, R, t, positive3);
            }
        } else {
            //Three equal singular values
            throw new HomographyDecomposerException("undefined plane normal");
        }                
    }
    
    /**
     * Generates one homography decomposition using provided singular values and
     * assuming that there are two equal singular values and that d2 is 
     * negative.
     * @param d1 1st singular value.
     * @param d2 2nd singular value.
     * @param d3 3rd singular value.
     * @param n plane normal.
     * @param R rotation.
     * @param t translation.
     * @param positive3 true to assume positive x3, false otherwise.
     * @return distance to plane.
     */
    private double decomposeFromTwoDifferentSingularValuesNegative(double d1,
            double d2, double d3, double[] n, Matrix R, double[] t, 
            boolean positive3) {

        //fill plane normal solution
        n[0] = 0.0;
        n[1] = 0.0;
        n[2] = positive3 ? 1.0 : -1.0;     
        
        
        //compute rotation
        
        //fill rotation matrix
        R.setElementAt(0, 0, -1.0);
        R.setElementAt(1, 0, 0.0);
        R.setElementAt(2, 0, 0.0);
        
        R.setElementAt(0, 1, 0.0);
        R.setElementAt(1, 1, -1.0);
        R.setElementAt(2, 1, 0.0);
        
        R.setElementAt(0, 2, 0.0);
        R.setElementAt(1, 2, 0.0);
        R.setElementAt(2, 2, 1.0);

        //compute translation
        double sum = d3 + d1;
        t[0] = 0.0;
        t[1] = 0.0;
        t[2] = sum*n[2];
        
        //plane distance
        return d2;        
    }
    
    /**
     * Generates one homography decomposition using provided singular values and
     * assuming that there are two equal singular values and that d2 is 
     * positive.
     * @param d1 1st singular value.
     * @param d2 2nd singular value.
     * @param d3 3rd singular value.
     * @param n plane normal.
     * @param R rotation.
     * @param t translation.
     * @param positive3 true to assume positive x3, false otherwise.
     * @return distance to plane.
     */
    private double decomposeFromTwoDifferentSingularValuesPositive(double d1,
            double d2, double d3, double[] n, Matrix R, double[] t, 
            boolean positive3) {

        //fill plane normal solution
        n[0] = 0.0;
        n[1] = 0.0;
        n[2] = positive3 ? 1.0 : -1.0;     
        
        
        //compute rotation
        
        //fill rotation matrix
        R.setElementAt(0, 0, 1.0);
        R.setElementAt(1, 0, 0.0);
        R.setElementAt(2, 0, 0.0);
        
        R.setElementAt(0, 1, 0.0);
        R.setElementAt(1, 1, 1.0);
        R.setElementAt(2, 1, 0.0);
        
        R.setElementAt(0, 2, 0.0);
        R.setElementAt(1, 2, 0.0);
        R.setElementAt(2, 2, 1.0);

        //compute translation
        double diff = d1 - d3;
        t[0] = 0.0;
        t[1] = 0.0;
        t[2] = -diff*n[2];
        
        //plane distance
        return d2;        
    }
    
    /**
     * Generates one homography decomposition using provided singular values and
     * assuming that there are three different singular values and that d2 is 
     * negative.
     * @param d1 1st singular value.
     * @param d2 2nd singular value.
     * @param d3 3rd singular value.
     * @param n plane normal.
     * @param R rotation.
     * @param t translation.
     * @param positive1 true to assume positive x1, false otherwise.
     * @param positive3 true to assume positive x3, false otherwise.
     * @return distance to plane.
     */    
    private double decomposeFromThreeDifferentSingularValuesNegative(double d1, 
            double d2, double d3, double[] n, Matrix R, double[] t,
            boolean positive1, boolean positive3) {
        double d1Sqr = d1*d1;
        double d2Sqr = d2*d2;
        double d3Sqr = d3*d3;
        
        //compute plane normal
        double denom = d1Sqr - d3Sqr;
        
        double x1 = Math.sqrt((d1Sqr - d2Sqr) / denom);
        if (!positive1) {
            x1 = -x1;
        }
        
        double x2 = 0.0;
        
        double x3 = Math.sqrt((d2Sqr - d3Sqr) / denom);
        if (!positive3) {
            x3 = -x3;
        }
        
        //fill plane normal solution
        n[0] = x1;
        n[1] = x2;
        n[2] = x3;     
        
        
        //compute rotation
        double x1Sqr = x1*x1;
        double x3Sqr = x3*x3;
        
        double sinTheta = (d1 + d3)*x1*x3/d2;
        double cosTheta = (d3*x1Sqr - d1*x3Sqr)/d2;
        
        //fill rotation matrix
        R.setElementAt(0, 0, cosTheta);
        R.setElementAt(1, 0, 0.0);
        R.setElementAt(2, 0, sinTheta);
        
        R.setElementAt(0, 1, 0.0);
        R.setElementAt(1, 1, 1.0);
        R.setElementAt(2, 1, 0.0);
        
        R.setElementAt(0, 2, -sinTheta);
        R.setElementAt(1, 2, 0.0);
        R.setElementAt(2, 2, cosTheta);
        
        
        //compute translation
        double sum = d1 + d3;
        t[0] = sum*x1;
        t[1] = 0.0;
        t[2] = sum*x3;
        
        //plane distance
        return d2;        
    }
    
    /**
     * Generates one homography decomposition using provided singular values and
     * assuming that there are three different singular values and that d2 is 
     * positive.
     * @param d1 1st singular value.
     * @param d2 2nd singular value.
     * @param d3 3rd singular value.
     * @param n plane normal.
     * @param R rotation.
     * @param t translation.
     * @param positive1 true to assume positive x1, false otherwise.
     * @param positive3 true to assume positive x3, false otherwise.
     * @return distance to plane.
     */
    private double decomposeFromThreeDifferentSingularValuesPositive(
            double d1, double d2, double d3, double[] n, Matrix R, double[] t, 
            boolean positive1, boolean positive3) {
        double d1Sqr = d1*d1;
        double d2Sqr = d2*d2;
        double d3Sqr = d3*d3;
        
        //compute plane normal
        double denom = d1Sqr - d3Sqr;
        
        double x1 = Math.sqrt((d1Sqr - d2Sqr) / denom);
        if (!positive1) {
            x1 = -x1;
        }
        
        double x2 = 0.0;
        
        double x3 = Math.sqrt((d2Sqr - d3Sqr) / denom);
        if (!positive3) {
            x3 = -x3;
        }
        
        //fill plane normal solution
        n[0] = x1;
        n[1] = x2;
        n[2] = x3;     
        
        
        //compute rotation
        double x1Sqr = x1*x1;
        double x3Sqr = x3*x3;
        
        double sinTheta = (d1 - d3)*x1*x3/d2;
        double cosTheta = (d1*x3Sqr + d3*x1Sqr)/d2;
        
        //fill rotation matrix
        R.setElementAt(0, 0, cosTheta);
        R.setElementAt(1, 0, 0.0);
        R.setElementAt(2, 0, sinTheta);
        
        R.setElementAt(0, 1, 0.0);
        R.setElementAt(1, 1, 1.0);
        R.setElementAt(2, 1, 0.0);
        
        R.setElementAt(0, 2, -sinTheta);
        R.setElementAt(1, 2, 0.0);
        R.setElementAt(2, 2, cosTheta);
        
        
        //compute translation
        double diff = d1 - d3;
        t[0] = diff*x1;
        t[1] = 0.0;
        t[2] = -diff*x3;
        
        //plane distance
        return d2;        
    }
    
    /**
     * Computes homography matrix in terms of normalized point coordinates by 
     * taking into account intrinsic camera parameters on left and right views.
     * @return normalized homography matrix
     * @throws AlgebraException if there are numerical instabilities.
     */
    private Matrix computeNormalizedCoordinatesHomographyMatrix() 
            throws AlgebraException {
            //we know that point p1 in the left view is related to point p2
            //in the right view by homography G so that:
            //p2 = G*p1
            //where:
            //p1 = K1*m1
            //p2 = K2*m2
            //where K1 and K2 are intrinsic parameters on left and right views
            //and m1, m2 are normalized point coordinates on left and right 
            //views.
            //Hence:
            //K2*m2 = G*K1*m1 --> m2 = K2^-1*G*K1*m1
            //and so we obtain:
            //H = K2^-1*G*K1, which is an homography in normalized coordinates
            
            Matrix K1 = mLeftIntrinsics.getInternalMatrix();
            Matrix invK2 = mRightIntrinsics.getInverseInternalMatrix();
            Matrix G = mHomography.asMatrix();
            
            //compute H = K2^-1*G*K1
            G.multiply(K1);
            invK2.multiply(G);   
            return invK2;
    }    
}
