/**
 * @file
 * This file contains implementation of
 * com.irurueta.geometry.refiners.Refiner
 * 
 * @author Alberto Irurueta (alberto@irurueta.com)
 * @date March 28, 2017.
 */
package com.irurueta.geometry.refiners;

import com.irurueta.algebra.Matrix;
import com.irurueta.geometry.estimators.LockedException;
import com.irurueta.geometry.estimators.NotReadyException;

/**
 * Refines an instance of type T by taking into account an initial estimation.
 * This class can be used to find a solution that minimizes error of inliers in
 * LMSE terms.
 * Typically a refiner is used by a robust estimator, however it can also be 
 * useful in some other situations.
 * This is a base abstract class to be used by any refiner implementation.
 * @param <T> type of instance to be refined.
 */
public abstract class Refiner<T> {
    
    /**
     * Indicates whether by default covariance of estimation must be kept.
     */
    public static final boolean DEFAULT_KEEP_COVARIANCE = false;
    
    /**
     * Initial estimation.
     */
    protected T mInitialEstimation;
    
    /**
     * Indicates whether covariance of estimation must be kept after refinement.
     */
    protected boolean mKeepCovariance = DEFAULT_KEEP_COVARIANCE;
    
    /**
     * Estimated covariance after refinement.
     */
    protected Matrix mCovariance;
    
    /**
     * Indicates if this estimator is locked because a refinement is being 
     * computed.
     */
    protected boolean mLocked;
    
    /**
     * Listener in charge of attending events generated by this instance.
     */
    protected RefinerListener<T> mListener;

    /**
     * Constructor.
     */
    public Refiner() { }
    
    /**
     * Constructor.
     * @param initialEstimation initial estimation to be set.
     * @param keepCovariance true if covariance of estimation must be kept after
     * refinement, false otherwise.
     */
    public Refiner(T initialEstimation, boolean keepCovariance) {
        mInitialEstimation = initialEstimation;
        mKeepCovariance = keepCovariance;
    }
    
    /**
     * Gets listener in charge of attending events generated by this instance.
     * @return listener in charge of attending events generated by this 
     * instance.
     */
    public RefinerListener<T> getListener() {
        return mListener;
    }
    
    /**
     * Sets listener in charge of attending events generated by this instance.
     * @param listener listener in charge of attending events generated by this
     * instance.
     */
    public void setListener(RefinerListener<T> listener) {
        mListener = listener;
    }        
    
    /**
     * Gets initial estimation.
     * @return initial estimation.
     */
    public T getInitialEstimation() {
        return mInitialEstimation;
    }
    
    /**
     * Sets initial estimation.
     * @param initialEstimation initial estimation.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialEstimation(T initialEstimation) 
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mInitialEstimation = initialEstimation;
    }
    
    /**
     * Indicates whether covariance of estimation must be kept after refinement 
     * or not.
     * @return true if covariance of estimation must be kept after refinement,
     * false otherwise.
     */
    public boolean isCovarianceKept() {
        return mKeepCovariance;
    }
    
    /**
     * Specifies whether covariance of estimation must be kept after refinement
     * or not.
     * @param keepCovariance true if covariance of estimation must be kept after
     * refinement, false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setCovarianceKept(boolean keepCovariance) 
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mKeepCovariance = keepCovariance;
    }
    
    
    /**
     * Indicates if this estimator is locked because a refinement is being 
     * computed.
     * @return true if estimator is locked, false otherwise.
     */
    public boolean isLocked() {
        return mLocked;
    }
    
    /**
     * Gets estimated covariance after refinement.
     * @return estimated covariance after refinement.
     */
    public Matrix getCovariance() {
        return mCovariance;
    }    
    
    /**
     * Indicates whether this refiner is ready to start refinement computation.
     * @return true if refiner is ready, false otherwise.
     */    
    public abstract boolean isReady();
    
    /**
     * Refines provided initial estimation.
     * Notice that implementations of this method might set a value into result
     * even if error is not improved in LMSE terms.
     * @param result instance where refined estimation will be stored.
     * @return true if result improves (decreases) in LMSE terms respect to 
     * initial estimation, false if no improvement has been achieved.
     * @throws NotReadyException if not enough input data has been provided.
     * @throws LockedException if estimator is locked because refinement is 
     * already in progress.
     * @throws RefinerException if refinement fails for some reason (e.g. unable 
     * to converge to a result).
     */
    public abstract boolean refine(T result) throws NotReadyException, 
            LockedException, RefinerException;
    
    /**
     * Refines provided initial estimation.
     * @return refined estimation.
     * @throws NotReadyException if not enough input data has been provided.
     * @throws LockedException if estimator is locked because refinement is 
     * already in progress.
     * @throws RefinerException if refinement fails for some reason (e.g. unable 
     * to converge to a result).
     */    
    public abstract T refine() throws NotReadyException, LockedException, 
            RefinerException;
    
}
